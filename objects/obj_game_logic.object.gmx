<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_logic_processor</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-6</depth>
  <persistent>-1</persistent>
  <parentName>obj_activate_parent</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Init Setup
//Input Variables
//2D Array Parameters:
//[0,0] = D-Pad
//[1,0] = Buttons
//[2,0] = Toggles

//D-Pad Movement
joy_input[0,0] = 0    //Joystick Right
joy_input[0,1] = 0    //Joystick Down
joy_input[0,2] = 0    //Joystick Left
joy_input[0,3] = 0    //Joystick Up

//Player Actions
joy_input[1,0] = 0    //Joystick A
joy_input[1,2] = 0    //Joystick B
joy_input[1,3] = 0    //Joystick C
joy_input[1,4] = 0    //Joystick D
joy_input[1,5] = 0    //Joystick Proxy For "Start"

//D-Pad Button Aliases
joy_button_left  = 0
joy_button_right = 0
joy_button_up    = 0
joy_button_down  = 0

joy_mouse_button_switch = 0
joy_mouse_button_frame = 0
joy_mouse_button_alpha = 0
joy_mouse_button_flash = 0
joy_mouse_button_timer = 0
joy_mouse_button_counter = 0
joy_mouse_button_iterate = 0
joy_mouse_button_cooldown = 0
joy_mouse_button_busy_angle = 0
joy_mouse_button_busy_timer = 0

//Pause and Other Toggles
joy_input[2,0] = 0    //Joystick "Start"
joy_input[2,1] = 0    //Joystick Input Switch (Keyboard or Joystick? Keyboard By Default)
joy_input[2,2] = 0    //Joystick Connected
joy_input[2,3] = 0    //Joystick Legacy Or Modern Switch
joy_input[2,4] = 0    //Joystick Jump   Lock
joy_input[2,5] = 0    //Joystick Attack Lock
joy_input[2,6] = 0    //Joystick Lock; Lock All Player Inputs
joy_input[2,7] = 0    //Joystick Button Press; Detect C Button Presses Only
joy_input[2,8] = 0    //Joystick Left Press; Detect Left Button Presses Only
joy_input_mode = 1    //Joystick Input Mode (1 = Xinput Mode; 2 = Legacy Mode)
joy_input_id   = 2    //Joystick ID (Legacy Mode Only)
joy_modern_id  = 0    //Joystick ID (Modern Mode Only)
joy_overlay    = 0    //Joystick HUD Overlay

key_reset_timer = 0   //64 Frame Timer For Resetting The Game
key_reset_alpha = 0   //Alpha Transparency For Transitional Effect

//Screensaver Variables
joy_input_fullscreen_timer = 0
joy_input_screen_saver = 0
joy_input_screen_saver_alpha = 0

//Controller Type
joy_type = 0

//Editor Mode Input Variables

//D-Pad Movement
edit_input[0,0] = 0    //Joystick Right
edit_input[0,1] = 0    //Joystick Down
edit_input[0,2] = 0    //Joystick Left
edit_input[0,3] = 0    //Joystick Up

//Panning Movement
edit_input[2,0] = 0    //Joystick Right
edit_input[2,1] = 0    //Joystick Down
edit_input[2,2] = 0    //Joystick Left
edit_input[2,3] = 0    //Joystick Up

//Analog Stick Movement
edit_x = 0
edit_y = 0

//Editor Actions
edit_input[1,0] = 0    //Move
edit_input[1,2] = 0    //Delete
edit_input[1,3] = 0    //Put Here
edit_input[1,4] = 0    //Copy

//Editor Quick Actions
edit_input[1,5] = 0    //Layer Up
edit_input[1,6] = 0    //Layer Down
edit_input[1,7] = 0    //Snap Up
edit_input[1,8] = 0    //Snap Down

//Editor Menus
edit_input[1,9]  = 0    //Exit
edit_input[1,10] = 0    //Mode

//Initialize Pause Menu Localization Text
scr_lang_pause_menu()

//=========Collect User Configuration from INI Configuration File=========//
nsfs_init()
devstory_check = 0.8
if directory_exists_ns(program_directory + "Campaign")
    devstory_check = 1;
ini_open_ns(program_directory + "gamedata.dat")
//Look for visual settings to change.
vblank      = real(ini_read_string("main_settings","vblank",1))
fullscreen  = real(ini_read_string("main_settings","fullscreen",0))
performance = ini_read_string("main_settings","performance_profile",0)
view_scale  = real(ini_read_string("main_settings","window_scaling",2))
music_volume    = real(ini_read_string("main_settings","music_volume",100))
game_sound_volume = real(ini_read_string("main_settings","sound_volume",100))
performance_profile = real(ini_read_string("main_settings","performance_profile",1))
enable_shaders = real(ini_read_string("main_settings","enable_shaders",1))
screen_shake = real(ini_read_string("main_settings","screen_shake",1))
mouse_scale = real(ini_read_string("main_settings","mouse_scale",1))
alt_skin_default = real(ini_read_string("main_settings","alt_skin_default",0))
reverse_mouse_buttons = real(ini_read_string("main_settings","reverse_mouse_buttons",0))
mouse_cursor_transparency = real(ini_read_string("main_settings","mouse_cursor_transparency",1))
user_combat_freeze_frame = 1
user_combat_freeze_timer = 0
devmode_check = ini_read_string("main_settings","devmode","")
devmode_key   = "FV~'+cEmXD2yV]h"
first_time = real(ini_read_string("main_settings","first_time","1"))
//Look for favorite palettes
use_favorite_palette[spr_lilac,0] = real(ini_read_string("main_palettes","lilac_0",0))
use_favorite_palette[spr_lilac,1] = real(ini_read_string("main_palettes","lilac_1",0))
use_favorite_palette[spr_carol,0] = real(ini_read_string("main_palettes","carol_0",0))
use_favorite_palette[spr_carol,1] = real(ini_read_string("main_palettes","carol_1",0))
use_favorite_palette[spr_milla,0] = real(ini_read_string("main_palettes","milla_0",0))
use_favorite_palette[spr_milla,1] = real(ini_read_string("main_palettes","milla_1",0))
use_favorite_palette[spr_spade,0] = real(ini_read_string("main_palettes","spade_0",0))
use_favorite_palette[spr_spade,1] = real(ini_read_string("main_palettes","spade_1",0))
//Save Data Player 1
player_current = 0

player_gems[1] = 0 //Campaign Mode Gem Counter
player_gems[2] = 0 //Campaign Mode Gem Counter
player_gems[3] = 0 //Campaign Mode Gem Counter
player_gems[4] = 0 //Player Mode Gem Counter

player_shards[0] = 0
player_shards[1] = 0
player_shards[2] = 0
player_shards[3] = 0
player_shards[4] = 0

scr_set_init_sava_data()

player_gems[player_current] = real(ini_read_string("save_file_1","player_gems",0))
player_shards[player_current] = real(ini_read_string("save_file_1","player_shards",0))
player_world_state[0] = real(ini_read_string("save_file_1","world_state",0))
potion_petal_potion_save[0] = real(ini_read_string("save_file_1","potion_petal_potion",0))
potion_petal_core_save[0] = real(ini_read_string("save_file_1","potion_petal_core",0))
potion_stamina_drink_save[0] = real(ini_read_string("save_file_1","potion_stamina_drink",0))
potion_stamina_core_save[0] = real(ini_read_string("save_file_1","potion_stamina_core",0))
potion_feather_potion_save[0] = real(ini_read_string("save_file_1","potion_feather_potion",0))
potion_mystery_potion_save[0] = real(ini_read_string("save_file_1","potion_mystery_potion",0))

potion_petal_potion = 0
potion_petal_core = 0
potion_petal_timer = 0
potion_stamina_drink = 0
potion_stamina_core = 0
potion_feather_potion = 0
potion_feather_timer = 0
potion_mystery_potion = 0
potion_mystery_timer = 0
potion_mystery_effect = 0

//Adjust Volume Of All Sound Effects If The Volume Is Not 100%
if game_sound_volume != 100 scr_adjust_sounds(game_sound_volume/100);
//Keyboard Bindings (Player Mode)
key_left    = real(ini_read_string("keyboard_bindings","key_left","37"))
key_right   = real(ini_read_string("keyboard_bindings","key_right","39"))
key_up      = real(ini_read_string("keyboard_bindings","key_up","38"))
key_down    = real(ini_read_string("keyboard_bindings","key_down","40"))
key_a       = real(ini_read_string("keyboard_bindings","key_a","88"))
key_b       = real(ini_read_string("keyboard_bindings","key_b","90"))
key_c       = real(ini_read_string("keyboard_bindings","key_c","67"))
key_d       = real(ini_read_string("keyboard_bindings","key_d","83"))
key_start   = real(ini_read_string("keyboard_bindings","key_start","13"))
//Mouse Bindings (Player Mode)
mouse_left        = real(ini_read_string("mouse_bindings","mouse_left","0"))
mouse_right       = real(ini_read_string("mouse_bindings","mouse_right","2"))
mouse_middle      = real(ini_read_string("mouse_bindings","mouse_middle","3"))
mouse_scroll_up   = real(ini_read_string("mouse_bindings","mouse_scroll_up","4"))
mouse_scroll_down = real(ini_read_string("mouse_bindings","mouse_scroll_down","5"))
mouse_deadzone_up = real(ini_read_string("mouse_bindings","mouse_deadzone_up","0"))
mouse_deadzone_down = real(ini_read_string("mouse_bindings","mouse_deadzone_down","0"))
mouse_deadzone_left = real(ini_read_string("mouse_bindings","mouse_deadzone_left","0"))
mouse_deadzone_right = real(ini_read_string("mouse_bindings","mouse_deadzone_right","0"))
//Keyboard Bindings (Editor Mode)
key_move_left   = real(ini_read_string("keyboard_editor_bindings","move_left","65"))
key_move_right  = real(ini_read_string("keyboard_editor_bindings","move_right","68"))
key_move_up     = real(ini_read_string("keyboard_editor_bindings","move_up","87"))
key_move_down   = real(ini_read_string("keyboard_editor_bindings","move_down","83"))
key_alt_left    = real(ini_read_string("keyboard_editor_bindings","alt_left","37"))
key_alt_right   = real(ini_read_string("keyboard_editor_bindings","alt_right","39"))
key_alt_up      = real(ini_read_string("keyboard_editor_bindings","alt_up","38"))
key_alt_down    = real(ini_read_string("keyboard_editor_bindings","alt_down","40"))
key_mode        = real(ini_read_string("keyboard_editor_bindings","mode","16"))
key_delete      = real(ini_read_string("keyboard_editor_bindings","delete","69"))
key_put_here    = real(ini_read_string("keyboard_editor_bindings","put_here","32"))
key_copy        = real(ini_read_string("keyboard_editor_bindings","copy","67"))
key_layer_up    = real(ini_read_string("keyboard_editor_bindings","layer_up","49"))
key_layer_down  = real(ini_read_string("keyboard_editor_bindings","layer_down","81"))
key_snap_up     = real(ini_read_string("keyboard_editor_bindings","snap_up","17"))
key_zoom        = real(ini_read_string("keyboard_editor_bindings","zoom","88"))
key_pause       = real(ini_read_string("keyboard_editor_bindings","pause","13"))
key_new_tile    = real(ini_read_string("keyboard_editor_bindings","new_tile","9"))
key_undo        = real(ini_read_string("keyboard_editor_bindings","undo","90"))
key_redo        = real(ini_read_string("keyboard_editor_bindings","redo","89"))
//Keyboard Alt Code Translations (Player Mode)
key_left_s    = scr_translate_alt_codes_keyboard(key_left)
key_right_s   = scr_translate_alt_codes_keyboard(key_right)
key_up_s      = scr_translate_alt_codes_keyboard(key_up)
key_down_s    = scr_translate_alt_codes_keyboard(key_down)
key_a_s       = scr_translate_alt_codes_keyboard(key_a)
key_b_s       = scr_translate_alt_codes_keyboard(key_b)
key_c_s       = scr_translate_alt_codes_keyboard(key_c)
key_d_s       = scr_translate_alt_codes_keyboard(key_d)
key_start_s   = scr_translate_alt_codes_keyboard(key_start)
//Keyboard Alt Code Translations (Editor Mode)
key_move_left_s   = scr_translate_alt_codes_keyboard(key_move_left)
key_move_right_s  = scr_translate_alt_codes_keyboard(key_move_right)
key_move_up_s     = scr_translate_alt_codes_keyboard(key_move_up)
key_move_down_s   = scr_translate_alt_codes_keyboard(key_move_down)
key_mode_s        = scr_translate_alt_codes_keyboard(key_mode)
key_delete_s      = scr_translate_alt_codes_keyboard(key_delete)
key_put_here_s    = scr_translate_alt_codes_keyboard(key_put_here)
key_copy_s        = scr_translate_alt_codes_keyboard(key_copy)
key_layer_up_s    = scr_translate_alt_codes_keyboard(key_layer_up)
key_layer_down_s  = scr_translate_alt_codes_keyboard(key_layer_down)
key_snap_up_s     = scr_translate_alt_codes_keyboard(key_snap_up)
key_zoom_s        = scr_translate_alt_codes_keyboard(key_zoom)
key_pause_s       = scr_translate_alt_codes_keyboard(key_pause)
key_new_tile_s    = scr_translate_alt_codes_keyboard(key_new_tile)
key_undo_s        = scr_translate_alt_codes_keyboard(key_undo)
key_redo_s        = scr_translate_alt_codes_keyboard(key_redo)

//Joystick Modern Bindings (Player Mode)
deadzone_mod    = real(ini_read_string("joystick_modern_bindings","deadzone",0.15))
joy_left_mod    = real(ini_read_string("joystick_modern_bindings","joy_left","32783"))
joy_right_mod   = real(ini_read_string("joystick_modern_bindings","joy_right","32784"))
joy_up_mod      = real(ini_read_string("joystick_modern_bindings","joy_up","32781"))
joy_down_mod    = real(ini_read_string("joystick_modern_bindings","joy_down","32782"))
joy_x_mod       = real(ini_read_string("joystick_modern_bindings","joy_x","32785"))
joy_y_mod       = real(ini_read_string("joystick_modern_bindings","joy_y","32786"))
joy_a_mod       = real(ini_read_string("joystick_modern_bindings","joy_a","32771"))
joy_b_mod       = real(ini_read_string("joystick_modern_bindings","joy_b","32769"))
joy_c_mod       = real(ini_read_string("joystick_modern_bindings","joy_c","32776"))
joy_d_mod       = real(ini_read_string("joystick_modern_bindings","joy_d","32774"))
joy_start_mod   = real(ini_read_string("joystick_modern_bindings","joy_start","32778"))
//Joystick Modern Bindings (Editor Mode)
joy_move_left   = real(ini_read_string("joystick_modern_editor_bindings","move_left","32783"))
joy_move_right  = real(ini_read_string("joystick_modern_editor_bindings","move_right","32784"))
joy_move_up     = real(ini_read_string("joystick_modern_editor_bindings","move_up","32781"))
joy_move_down   = real(ini_read_string("joystick_modern_editor_bindings","move_down","32782"))
joy_move_x      = real(ini_read_string("joystick_modern_editor_bindings","move_x","32785"))
joy_move_y      = real(ini_read_string("joystick_modern_editor_bindings","move_y","32786"))
joy_mode        = real(ini_read_string("joystick_modern_editor_bindings","mode","32777"))
joy_delete      = real(ini_read_string("joystick_modern_editor_bindings","delete","32771"))
joy_put_here    = real(ini_read_string("joystick_modern_editor_bindings","put_here","32769"))
joy_copy        = real(ini_read_string("joystick_modern_editor_bindings","copy","32770"))
joy_layer_up    = real(ini_read_string("joystick_modern_editor_bindings","layer_up","32774"))
joy_layer_down  = real(ini_read_string("joystick_modern_editor_bindings","layer_down","32773"))
joy_snap_up     = real(ini_read_string("joystick_modern_editor_bindings","snap_up","32776"))
joy_zoom        = real(ini_read_string("joystick_modern_editor_bindings","zoom","32775"))
joy_pause       = real(ini_read_string("joystick_modern_editor_bindings","pause","32778"))
joy_new_tile    = real(ini_read_string("joystick_modern_editor_bindings","new_tile","32772"))
joy_pause       = real(ini_read_string("joystick_modern_editor_bindings","pause","32778"))
joy_new_tile    = real(ini_read_string("joystick_modern_editor_bindings","new_tile","32772"))
joy_undo        = real(ini_read_string("joystick_modern_editor_bindings","undo","32779"))
joy_redo        = real(ini_read_string("joystick_modern_editor_bindings","redo","32780"))
//Joystick Alt Code Translations (Player Mode)
joy_left_mod_s    = scr_translate_alt_codes_gamepad(joy_left_mod)
joy_right_mod_s   = scr_translate_alt_codes_gamepad(joy_right_mod)
joy_up_mod_s      = scr_translate_alt_codes_gamepad(joy_up_mod)
joy_down_mod_s    = scr_translate_alt_codes_gamepad(joy_down_mod)
joy_x_mod_s       = scr_translate_alt_codes_gamepad(joy_x_mod)
joy_y_mod_s       = scr_translate_alt_codes_gamepad(joy_y_mod)
joy_a_mod_s       = scr_translate_alt_codes_gamepad(joy_a_mod)
joy_b_mod_s       = scr_translate_alt_codes_gamepad(joy_b_mod)
joy_c_mod_s       = scr_translate_alt_codes_gamepad(joy_c_mod)
joy_d_mod_s       = scr_translate_alt_codes_gamepad(joy_d_mod)
joy_start_mod_s   = scr_translate_alt_codes_gamepad(joy_start_mod)
//Joystick Alt Code Translations (Editor Mode)
joy_move_left_s   = scr_translate_alt_codes_gamepad(joy_move_left)
joy_move_right_s  = scr_translate_alt_codes_gamepad(joy_move_right)
joy_move_up_s     = scr_translate_alt_codes_gamepad(joy_move_up)
joy_move_down_s   = scr_translate_alt_codes_gamepad(joy_move_down)
joy_move_x_s      = scr_translate_alt_codes_gamepad(joy_move_x)
joy_move_y_s      = scr_translate_alt_codes_gamepad(joy_move_y)
joy_mode_s        = scr_translate_alt_codes_gamepad(joy_mode)
joy_delete_s      = scr_translate_alt_codes_gamepad(joy_delete)
joy_put_here_s    = scr_translate_alt_codes_gamepad(joy_put_here)
joy_copy_s        = scr_translate_alt_codes_gamepad(joy_copy)
joy_layer_up_s    = scr_translate_alt_codes_gamepad(joy_layer_up)
joy_layer_down_s  = scr_translate_alt_codes_gamepad(joy_layer_down)
joy_snap_up_s     = scr_translate_alt_codes_gamepad(joy_snap_up)
joy_zoom_s        = scr_translate_alt_codes_gamepad(joy_zoom)
joy_pause_s       = scr_translate_alt_codes_gamepad(joy_pause)
joy_new_tile_s    = scr_translate_alt_codes_gamepad(joy_new_tile)
joy_undo_s        = scr_translate_alt_codes_gamepad(joy_undo)
joy_redo_s        = scr_translate_alt_codes_gamepad(joy_redo)

//Analog Hotkeys (Player Mode)
enable_hotkeys    = real(ini_read_string("joystick_modern_hotkeys","enable_hotkeys","0"))
left_stick_left   = real(ini_read_string("joystick_modern_hotkeys","left_stick_left","5"))
left_stick_right  = real(ini_read_string("joystick_modern_hotkeys","left_stick_right","6"))
left_stick_up     = real(ini_read_string("joystick_modern_hotkeys","left_stick_up","7"))
left_stick_down   = real(ini_read_string("joystick_modern_hotkeys","left_stick_down","8"))
right_stick_left  = real(ini_read_string("joystick_modern_hotkeys","right_stick_left","2"))
right_stick_right = real(ini_read_string("joystick_modern_hotkeys","right_stick_right","3"))
right_stick_up    = real(ini_read_string("joystick_modern_hotkeys","right_stick_up","9"))
right_stick_down  = real(ini_read_string("joystick_modern_hotkeys","right_stick_down","4"))

//Accessibility Parameters
user_camera_shake = 1
    user_camera_shake_intensity = real(ini_read_string("extended_settings","user_camera_shake_intensity","1"))
user_regen_health = real(ini_read_string("extended_settings","user_regen_health","0"))
user_regen_health_timer = 0
user_enemy_level = real(ini_read_string("extended_settings","user_enemy_level","2"))
user_enemy_health_display = real(ini_read_string("extended_settings","user_enemy_health_display","0"))
user_move_list_display = real(ini_read_string("extended_settings","user_move_list_display","0"))
user_disable_zoom_gimmick = real(ini_read_string("extended_settings","user_camera_zoom_toggle","1"))
    user_move_list_control_type = real(ini_read_string("extended_settings","user_move_list_control_type","0"))
    user_joystick_left = scr_set_display_button(joy_left_mod)
    user_joystick_right = scr_set_display_button(joy_right_mod)
    user_joystick_up = scr_set_display_button(joy_up_mod)
    user_joystick_down = scr_set_display_button(joy_down_mod)
    user_joystick_a = scr_set_display_button(joy_a_mod)
    user_joystick_b = scr_set_display_button(joy_b_mod)
    user_joystick_c = scr_set_display_button(joy_c_mod)
    user_joystick_d = scr_set_display_button(joy_d_mod)
    user_joystick_start = scr_set_display_button(joy_start_mod)
user_turbo_mode = real(ini_read_string("extended_settings","user_turbo_mode","0"))
user_language_mode = real(ini_read_string("extended_settings","user_language_mode",0))
user_freeze_frames = real(ini_read_string("extended_settings","user_freeze_frames",0))
user_turbo_mode_used = 0
user_mode_page = 0

//Close INI Configuration File
ini_close_ns();

//Joystick Setup
if gamepad_is_connected(0)
    {
        joy_input_count   = gamepad_get_device_count()       //Get Number of Devices
        joy_input_buttons = gamepad_get_button_threshold(0); //Get Number of Buttons
        joy_input_axises  = gamepad_axis_count(0);           //Get Number of Axises
        joy_input_descrip = gamepad_get_description(0);      //Get Joystick Description
        joy_input_axis    = "stick"                          //Set Default Axis to Use
        gamepad_set_axis_deadzone(0,deadzone_mod)            //Set Default Deadzone For Analog Inputs
        gamepad_set_button_threshold(0,0.25)
    }
//Leave joystick variables blank if no joystick is connected
else
    {
        joy_input_count   = 0       //Set Number of Devices
        joy_input_buttons = 0       //Set Number of Buttons
        joy_input_axises  = 0       //Set Number of Axises
        joy_input_descrip = 0       //Set Joystick Description
        joy_input_axis    = "dpad"  //Set Default Axis to Use
    }
//Keep analog stick hotkeys force-enabled, for now
enable_hotkeys = 1

//Setup screenshots
number_of_screenshots = 0

if vblank = 0 display_reset(0,false);
if vblank = 1 display_reset(0,true);
if vblank = 2 display_set_windows_alternate_sync(true);
      
//Setup the size of our window
switch(view_scale)
    {
        default: {view_scale_x = 426;  view_scale_y = 240; view_scale_iterate = 0; break;}
        case 1: {view_scale_x = 426;  view_scale_y = 240; view_scale_iterate = 0; break;}
        case 2: {view_scale_x = 852;  view_scale_y = 480; view_scale_iterate = 1; break;}
        case 3: {view_scale_x = 1278; view_scale_y = 720; view_scale_iterate = 2; break;}
    }
//Recenter window
window_set_size(view_scale_x,view_scale_y)
window_set_position(display_get_width()/2-view_scale_x/2,display_get_height()/2-view_scale_y/2);

if fullscreen = 0 window_set_fullscreen(false);
if fullscreen = 1 window_set_fullscreen(true);
vblank_notification = 0

current_pal_allowed = 0
pal_swap_script = pal_swap_dummy
globalvar Pal_Shader,Pal_Texel_Size, Pal_UVs, Pal_Index, Pal_Texture;
global.Pal_Shader = -1
if not shaders_are_supported()
    enable_shaders = 0;
if enable_shaders = 1
    {
        pal_swap_init_system(shd_pal_swapper);
        pal_swap_script = pal_swap_set
        current_pal_allowed = 1
    }
//If the user's PC didn't successfully compile the shader, disable it anyway
if !shader_is_compiled(shd_pal_swapper)
    {
        enable_shaders = 0
        current_pal_allowed = 0
        pal_swap_script = pal_swap_dummy
    }
current_pal = 0
current_ui_pal = 0
my_pal_sprite = spr_lilac_palette
ui_pal_sprite = spr_ui_lilac_palette

//Do Not Reverse Mouse Buttons If The Config Has Returned False
if reverse_mouse_buttons = 0
    {
        joy_mouse_button_left = mb_left
        joy_mouse_button_right = mb_right
    }
//Reverse The Mouse Buttons If The Config Has Returned True
else
    {
        joy_mouse_button_left = mb_right
        joy_mouse_button_right = mb_left
    }

scr_set_version_number()

//Shang Mu Architect Loading Definition Table
scr_set_loading_definition_table(self)
scr_set_enemy_slope_table()
scr_multi_map_reset()

//Rotation Height Maps
scr_gem_particle(spr_gem_particle,spr_gem_particle+1000)
scr_gem_particle_19px(spr_gem_particle+2000,spr_gem_particle+3000)

//Initialize Campaign Variables
scr_set_campaign_init()
scr_set_music_playback_init()

//Animation Data Containers
Animations_Lilac()                  //Call Lilac's Animation Data
Animations_Carol()                  //Call Carol's Animation Data
Animations_Carol_Bike()             //Call Carol's Bike Animation Data
Animations_Carol_Reserve()          //Call Carol's Reserve Animation Data
Animations_Milla()                  //Call Milla's Animation Data
Animations_Spade()                  //Call Spade's Animation Data
Animations_Pseudonyms()             //Call Pseudonyms For Animation Index Data
                                    //So we don't lose our minds while writing
                                    //new animation code :^P
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Player Physics

//      Player Physics Variables      //
//====================================//

//Basic Movement
px      = 0             //Player X Position
py      = 0             //Player Y Position
start_x = 0             //Player X Start Position
start_y = 0             //Player Y Start Position
px_speed=0              //Player X Platform Speed
py_speed=0              //Player Y Platform Speed

//Movement Speed Variables
acc      = 0.07375      //Player Acceleration (Ground)
wat      = 0.056875     //Player Acceleration (Water)
air      = 0.09375      //Player Acceleration (Air)
dec      = 0.5          //Player Deceleration
decpoint = 0.0574       //Player Deceleration Point
frc      = 0.3688       //Player Friction (Old Value: 0.76875)
hsp      = 0            //Player Horizontal Speed
vsp      = 0            //Player Vertical   Speed
hcap     = 5            //Player Horizontal Speed Cap (Under Own Power)
wcap     = 4            //Player Horizontal Speed Cap (Underwater)
mcap     = 15           //Player Horizontal Speed Cap (Maximum Speed)
acc_time = 0            //Player Acceleration Timer
coyote_time = 0         //Player Jump Window Buffer
drag[0]  = 0.125        //Player Air Speed Drag
drag[1]  = 0.96875      //Player Air Speed Drag Calculation
drag_rate       = 0.375        //Player Air Speed Drag Rate
drag_reduction  = 0.0117       //Player Air Speed Drag Reduction Rate
drag_timer      = 0            //Player Air Speed Drag Timer
slp[0]   = 0.203125     //Player Slope Factor (Running Up Hill)
slp[1]   = 0.078125     //Player Slope Factor (Rolling Up Hill)
slp[2]   = 0.3125       //Player Slope Factor (Rolling Down Hill)
slp[3]   = 0.40         //Player Slope Factor (Running Down Hill)
slope_result = 0        //Result of Slope Factor Calculations
lfactor  = 0.84         //Landing Conversion Factor
sfactor  = 0            //Water Splash Conversion Factor
jfactor  = 0.0034       //Jump Factor
pyprevious = 0          //Previous Y Position
//Slope Factor Variables (Had to use trig to deduce what some of these values were, that took a whole afternoon :^P )
slope_factor_running            = 0.203125
slope_factor_walking_uphill     = 0.0035
slope_factor_walking_downhill   = 0.151
slope_acceleration_rate_storage = acc
slope_direction                 = 1

//Direction Variables
xdir     = 1            //Player Direction (-1 = Left; 1 = Right)
xcompass = 0            //Input "Compass" (Parameters: 0, 90, 180, 270)

//Sensor Offset Variables (Defaults)
p_off[0,0] = 0          //Sensor Offset Modifier Top X
p_off[0,1] = -27        //Sensor Offset Modifier Top Y
//---
p_off[1,0] = 0          //Sensor Offset Modifier Bottom X
p_off[1,1] = 0          //Sensor Offset Modifier Bottom Y
//---
p_off[2,0] = -16        //Sensor Offset Modifier Left X
p_off[2,1] = -15        //Sensor Offset Modifier Left Y
//---
p_off[3,0] = 16         //Sensor Offset Modifier Right X
p_off[3,1] = -15        //Sensor Offset Modifier Right Y

//Platform Movement
relative_x = -1          //Player X Position (Relative To Floating Platform)

player_hitbox_radius = 64

//Tile Layers
//These are defined in macros. Please refer to the "Default"
//configuration in the Macros resource folder

//         Collision Sensors         //
//-----------------------------------//

//Flat Surface Collision Sensors
tile_surface_id[1] = 0     //Top    Collision Sensor
tile_surface_id[2] = 0     //Bottom Collision Sensor
tile_surface_id[3] = 0     //Left   Collision Sensor
tile_surface_id[4] = 0     //Right  Collision Sensor
hori_offset        = 17    //Horizontal Sensor Offset
ceil_offset        = 10    //Top    Collision Sensor Offset
//Sensor Companions
tile_companion_id[0,0] = -1 //Left Collision Sensor Compansion
tile_companion_id[0,1] = -1 //Right Collision Sensor Compansion
tile_companion_id[2,0] = -1
tile_companion_id[2,1] = -1
//Slope Surface Collision Sensors
tile_ramp_id        = 0    //Slope  Collision Sensor
tile_ramp_id_debug  = 0    //Slope  Background ID
tile_angle          = 0    //Slope  Angle
angle_a             = 0    //Slope  Angle (Rotation)
angle_b             = 0    //Slope  Angle (Rotation Lag)
angle_c             = 0    //Slope  Angle (Rotation Lag)
tile_sensor_dir     = 0    //Slope  Sensor "Compass" (Parameters: 0, 90, 180, 270)
tile_loop_trigger   = 0    //Are we allowed to enter this loop?
angle_lag_extreme   = 0    //Slope  Sensor Rotation Lag
flat_surface_lag    = 0
//(0 = scr_bottom_right_inside_loop; 1 = scr_bottom_left_inside_loop)
//Slope Wall Collision Sensors
tile_wall_left_id   = 0    //Slope  Collision Sensor (Left)
tile_wall_left_bg   = 0    //Slope  Background ID    (Left)
tile_wall_left_trig = 0    //Slope  Trigger          (Left)
//
tile_wall_right_id  = 0    //Slope  Collision Sensor (Right)
tile_wall_right_bg  = 0    //Slope  Background ID    (Right)
tile_wall_right_trig = 0   //Slope  Trigger          (Right)
tile_wall_speed_copy = 0   //Transfer Gravity Speed To Horizontal Speed When Clipping Onto A Ceiling
//Slope Tile-Collision Dataset Switching
tile_switch_left = 0
tile_switch_right = 0
tile_switch_ceiling = 0
tile_switch_floor = 0
//Flat Wall Running Collision Sensors
tile_surface_wall_id          = 0  //Bottom Collision Sensor
tile_surface_wall_id_forward  = 0 //Forward Facing Collision Sensor
tile_surface_wall_xcompass    = 0 //Forward Facing Tile Compass Direction
tile_check_wall_id            = 0 //Check For Slopes Above Us (Center)
tile_check_wall_id_left       = 0 //Check For Slopes Above Us (Left)
tile_check_wall_id_right      = 0 //Check For Slopes Above Us (Right)
tile_check_wall_id_forward    = 0
tile_check_wall_id_hold       = -1
tile_check_wall_id_dir        = 1
tile_check_slope_priority     = 0
tile_surface_hor_speed        = 0
tile_surface_hor_direction    = 0
tile_surface_ceiling_timer    = 0
tile_surface_ceiling_disable  = 0
tile_surface_ceiling_override = 0
//Double-Sided Tile-Collision Sensors
tile_ramp_switch_offset_left    = 122
tile_ramp_switch_offset_right   = 57
tile_ramp_switch_offset_orbit   = 27
tile_ramp_switch_offset_center  = 0
tile_ramp_switch_offset_ceiling = 0
tile_ramp_switch_disable        = 0
tile_ramp_switch_sensor_x       = 0
tile_ramp_switch_sensor_y       = 0
tile_left_switch_sensor_x       = 0
tile_left_switch_sensor_y       = 0
tile_ramp_switch_id             = 0
tile_ramp_switch_bg             = 0
tile_ramp_switch_pos_x          = 0
tile_ramp_switch_pos_y          = 0
tile_ceiling_switch_id          = 0
tile_loop_switch                = 0
tile_loop_id                    = -1
//Generic Wall Collision Sensors
wall_collision_left  = 0 //Wall Collisions (left)
wall_collision_right = 0 //Wall Collisions (Right)
//Slope Ceiling Collision Sensors
tile_collision_ceiling = 0
tile_collision_ceiling_trigger = 0
//FOF Surface Collision Sensors
tile_surface_id[5]  = 0  //FOF    Collision Sensor
tile_surface_asset  = 0  //FOF    Background ID
//Collectable Item Sensors
tile_item_id        = 0  //Item Slope  Collision Sensor
item_asset_id[0]    = 0  //Item Slope  Background ID 1
item_asset_id[1]    = 0  //Item Slope  Background ID 2
item_surface_id[0]  = 0  //Left  Item Collision Sensor
item_surface_id[1]  = 0  //Right Item Collision Sensor
item_surface_id[2]  = 0  //Top   Item Collision Sensor
tile_item_trigger   = 0  //Are Floor Collisions Allowed On This Item?
tile_wall_trigger   = 0  //Are Wall  Collisions Allowed On This Item? (Right)
tile_wall_trigger_l = 0  //Are Wall  Collisions Allowed On This Item? (left)
//Slope Wall Sensors (Left)
slope_wall_left_x = 0
slope_wall_left_y = 0
slope_wall_left_id = -1
slope_wall_left_bg = 0
slope_wall_left_pos_0 = 0
slope_wall_left_pos_1 = 0
slope_wall_left_ang = 0
//Slope Wall Sensors (Right)
slope_wall_right_x = 0
slope_wall_right_y = 0
slope_wall_right_id = -1
slope_wall_right_pos_0 = 0
slope_wall_right_pos_1 = 0
slope_wall_right_bg = 0
slope_wall_right_ang = 0
//Slope Wall Sensors (Ceiling)
slope_ceiling_x = 0
slope_ceiling_y = 0
tile_ceiling_id = -1
tile_ceiling_bg = 0
tile_ceiling_pos_0 = 0
tile_ceiling_pos_1 = 0
slope_ceiling_ang = 0
//Slope Angle Sensors
angle_gen_id_0      = 0  //Left Angle Sensor
angle_gen_id_1      = 0  //Right Angle Sensor
angle_y_0           = 0  //Left Angle Sensor's Y Position
angle_y_1           = 0  //Right Angle Sensor's Y Position
angle_confirm_0     = 0  //Is The Left Sensor On A Slope?
angle_confirm_1     = 0  //Is The Right Sensor On A Slope?
tile_angle_pos_x    = 0  //
tile_angle_pos_y    = 0  //
tile_angle_id_debug = 0  //
tile_angle_confirm  = 0  //
tile_angle_id_debug_1= 0
tile_angle_pos_x_1  = 0
tile_angle_pos_y_1  = 0
tile_angle_confirm_1 = 0
real_angle = 0
fof_disable = 0
//Slope Layer Changers
slope_layer = 0         //0 = Left; 1 = Right

//Collision Map Positions
tile_ramp_pos[0]   = 0    //X Position Along the Slope
tile_ramp_pos[1]   = 0    //Y Position Along the Slope

//Collision Height Map Data
orig_clip[0,1]=0
orig_clip_bound[0,1]=0
//More data points are created as needed. No hard limit has been set.
//Positions in the 1D array are used as the X coordinates for the height map.

//Gravity Variables
gravity_speed    = 0                    //Gravity Speed
gravity_cap      = 15                   //Gravity Speed Cap
gravity_accel    = 0.2499               //Gravity Acceleration
//(Supposed to be 0.25, but the camera system gets mad when it's given 0.25, and I have no idea why :^( )
gravity_slope    = 0                    //Slope Detection
gravity_jump     = 7                    //Jump Speed
gravity_hop      = 3.5                  //Hop  Speed
gravity_hor      = 0                    //FOF Detection (Horizontal)
gravity_fof      = 0                    //FOF Detection (Vertical)
gravity_fofhop   = 0                    //Jump Speed (FOFs)
gravity_horset   = 0                    //FOF Player Drawing Offset (Horizontal)
gravity_fofset   = 0                    //FOF Player Drawing Offset (Vertical)
gravity_fof_validation = 0              //FOF Platform Check
gravity_rail_check = 0                  //Rail Grinding Platform Check
gravity_rail_timer = 0
gravity_rail_xdir = 0
gravity_offset   = 24                   //FOF Additional Drawing Offset
gravity_ladder   = 0                    //Are We On A Ladder?
ground           = 0                    //Are We On Solid Ground?
gravity_hang     = 0                    //Hangbar State
gravity_x        = 0                    //Hangbar X Coordinates
gravity_y        = 0                    //Hangbar Y Coordinates
gravity_hang_id  = 0                    //Hangbar Tile ID
gravity_override = 0                    //Disable Gravity
gravity_wall     = 0                    //Are we allowed to clip onto walls and ceilings?
gravity_ceiling  = 0                    //Are we allowed to clip onto ceilings from mid-air?
gravity_factor   = 0                    //What was our previous gravity_speed? (For landing factor conversion)
gravity_friction = 0                    //Are we allowed to apply air drag to the player?
gravity_launch   = 0                    //Are we allowed to launch the player into the air?
launch_force     = 0                    //How much speed should we apply to the player?
jump_lock        = 0                    //Jump Lock
jump_override    = 0                    //Jump Override
jump_sound       = 0                    //Jump Sound
push_block_frame = 0

//Temp Debug Variables
x_travel  = 0
y_travel  = 0
x_traveling = 0
y_traveling = 0
//travel_length = 0
travel_height  = 0
travel_length  = 0
travel_x_1     = 0
travel_y_1     = 0
//
travel_x_2     = 0
travel_y_2     = 0
use_write_delay_timer = 0
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Particle Variables

//Hurt Particle Variables
petal_hurt_x[0]   = 0
petal_hurt_y[0]   = 0
petal_hurt_x[1]   = 0
petal_hurt_y[1]   = 0
petal_hurt_x[2]   = 0
petal_hurt_y[2]   = 0
petal_hurt_x[3]   = 0
petal_hurt_y[3]   = 0
petal_hurt_x[4]   = 0
petal_hurt_y[4]   = 0
//Starting X/Y Positions
petal_offset_x[0] = 0
petal_offset_y[0] = 0
petal_offset_x[1] = 0
petal_offset_y[1] = 0
petal_offset_x[2] = 0
petal_offset_y[2] = 0
petal_offset_x[3] = 0
petal_offset_y[3] = 0
petal_offset_x[4] = 0
petal_offset_y[4] = 0
//Directional Movement Angle
petal_hurt_dir[0] = random_range(0,359)
petal_hurt_dir[1] = random_range(0,359)
petal_hurt_dir[2] = random_range(0,359)
petal_hurt_dir[3] = random_range(0,359)
petal_hurt_dir[4] = random_range(0,359)
//Petal Rotation Angle
petal_hurt_ang[0] = random_range(0,359)
petal_hurt_ang[1] = random_range(0,359)
petal_hurt_ang[2] = random_range(0,359)
petal_hurt_ang[3] = random_range(0,359)
petal_hurt_ang[4] = random_range(0,359)
//Shield Particle Variables
bubble_x          = 0         //Bubble X
bubble_y          = 0         //Bubble Y
bubble_alpha      = 0         //Bubble Alpha
bubble_x2         = 0         //Bubble X 2
bubble_x3         = 0         //Bubble X3
bubble_y3         = 0         //Bubble Y3
bubble_x4         = 0         //Bubble X4
petal_speed       = 0         //Petal Horizontal Speed
petal_x[0]        = random_range(-12,-4)        //Petal X 1
petal_x[1]        = random_range(-16,-8)        //Petal X 2
petal_x[2]        = random_range(-16,-8)        //Petal X 3
petal_x[3]        = random_range(-24,-8)        //Petal X 4
petal_x[4]        = random_range(-24,-8)        //Petal X 5
petal_x[5]        = random_range(8,16)          //Petal X 6
petal_x[6]        = random_range(8,16)          //Petal X 7
petal_x[7]        = random_range(8,24)          //Petal X 8
petal_x[8]        = random_range(8,24)          //Petal X 9
petal_x[9]        = random_range(4,12)          //Petal X 10
petal_y[0]        = random_range(40,48)         //Petal Y 1
petal_y[1]        = random_range(32,48)         //Petal Y 2
petal_y[2]        = random_range(32,48)         //Petal Y 3
petal_y[3]        = random_range(32,40)         //Petal Y 4
petal_y[4]        = random_range(32,40)         //Petal Y 5
petal_y[5]        = random_range(32,48)         //Petal Y 6
petal_y[6]        = random_range(32,48)         //Petal Y 7
petal_y[7]        = random_range(32,40)         //Petal Y 8
petal_y[8]        = random_range(32,40)         //Petal Y 9
petal_y[9]        = random_range(40,48)         //Petal Y 10
petal_alpha[0]    = 0         //Petal 1 Alpha
petal_alpha[1]    = 0         //Petal 2 Alpha
petal_alpha[2]    = 0         //Petal 3 Alpha
petal_alpha[3]    = 0         //Petal 4 Alpha
petal_alpha[4]    = 0         //Petal 5 Alpha
petal_alpha[5]    = 0         //Petal 6 Alpha
petal_alpha[6]    = 0         //Petal 7 Alpha
petal_alpha[7]    = 0         //Petal 8 Alpha
petal_alpha[8]    = 0         //Petal 9 Alpha
petal_alpha[9]    = 0         //Petal 10 Alpha
petal_angle[0]    = 0         //Petal 1 Angle
petal_angle[1]    = 16        //Petal 2 Angle
petal_angle[2]    = 32        //Petal 3 Angle
petal_angle[3]    = 48        //Petal 4 Angle
petal_angle[4]    = 64        //Petal 5 Angle
petal_angle[5]    = 80        //Petal 6 Angle
petal_angle[6]    = 112       //Petal 7 Angle
petal_angle[7]    = 124       //Petal 8 Angle
petal_angle[8]    = 148       //Petal 9 Angle
petal_angle[9]    = 160       //Petal 10 Angle
petal_timer       = 0         //Petal Sway Timer
//Shield Flash Particles
shield_flash_trigger = 0      //Shield Flash Trigger
shield_flash_frame   = 8      //Shield Flash Animation Frames
shield_flash_x       = 0      //Shield Flash X Position
shield_flash_y       = 0      //Shield Flash Y Position
scr_reset_gem_particles()

particle_frame_1  = -128    //Animation Frame for Particle 1
particle_frame_2  = -128    //Animation Frame for Particle 2
particle_frame_3  = -128    //Animation Frame for Particle 3
particle_frame_4  = -128    //Animation Frame for Particle 4
particle_frame_5  = -128    //Animation Frame for Particle 5
particle_trans_1  = 1       //Transparency for Particle 1
particle_trans_2  = 1       //Transparency for Particle 2
particle_trans_3  = 1       //Transparency for Particle 3
particle_trans_4  = 1       //Transparency for Particle 4
particle_trans_5  = 1       //Transparency for Particle 5
//Particle X/Y Positions
particle_x_1  = px particle_y_1  = py
particle_x_2  = px particle_y_2  = py
particle_x_3  = px particle_y_3  = py
particle_x_4  = px particle_y_4  = py
particle_x_5  = px particle_y_5  = py
//Spring Particles
spring_frames     = 0
spring_offset_x   = 0
spring_offset_y   = 0
spring_rotate     = 0
spring_tile_frame = 0
spring_surface_id = -1
spring_trigger    = 0
tile_spring_id    = 0
spring_draw_x     = 0
spring_draw_y     = 0
spring_tile_angle = 0
//Rail-grinding Particles
rail_grinding_iterations = 0
rail_grinding_particle_x[0] = 0
rail_grinding_particle_x[1] = 0
rail_grinding_particle_x[2] = 0
rail_grinding_particle_x[3] = 0
rail_grinding_particle_x[4] = 0
rail_grinding_particle_x[5] = 0
rail_grinding_particle_y[0] = 0
rail_grinding_particle_y[1] = 0
rail_grinding_particle_y[2] = 0
rail_grinding_particle_y[3] = 0
rail_grinding_particle_y[4] = 0
rail_grinding_particle_y[5] = 0
rail_grinding_particle_ang[0] = 0
rail_grinding_particle_ang[1] = 0
rail_grinding_particle_ang[2] = 0
rail_grinding_particle_ang[3] = 0
rail_grinding_particle_ang[4] = 0
rail_grinding_particle_ang[5] = 0

//Starting X/Y Positions
skid_offset_x[0] = 0
skid_offset_y[0] = 0
skid_offset_x[1] = 0
skid_offset_y[1] = 0
skid_offset_x[2] = 0
skid_offset_y[2] = 0
skid_offset_x[3] = 0
skid_offset_y[3] = 0
skid_offset_x[4] = 0
skid_offset_y[4] = 0
skid_offset_x[5] = 0
skid_offset_y[5] = 0
skid_offset_x[6] = 0
skid_offset_y[6] = 0
skid_offset_x[7] = 0
skid_offset_y[7] = 0
skid_offset_x[8] = 0
skid_offset_y[8] = 0
skid_offset_x[9] = 0
skid_offset_y[9] = 0
//Animation Frame Positions
skid_animation_frame[0] = -128
skid_animation_frame[1] = -128
skid_animation_frame[2] = -128
skid_animation_frame[3] = -128
skid_animation_frame[4] = -128
skid_animation_frame[5] = -128
skid_animation_frame[6] = -128
skid_animation_frame[7] = -128
skid_animation_frame[8] = -128
skid_animation_frame[9] = -128
//Animation Frame Offsets
skid_animation_offset_x = 0
skid_animation_offset_y = 0
//Spawning X/Y Positions
skid_spawn_x = 0
skid_spawn_y = 0

//Bubble Particles
bubble_offset_x[0] = 0
bubble_offset_y[0] = 0
bubble_visibility[0] = 0
bubble_offset_x[1] = 0
bubble_offset_y[1] = 0
bubble_visibility[1] = 0
bubble_offset_x[2] = 0
bubble_offset_y[2] = 0
bubble_visibility[2] = 0

//Invincibility Particles
//Particle 1 Variables
frame_speed[0] = 0         //Vertical Speed of Particle
part_frame[0]  = 7         //Animation Frame of Particle
position[0]    = 16        //Horizontal Offset
position_offset[0] = -23   //Randomized Horizontal Offset
sparkle_offset[0] = 0      //Randomized Horizontal Offset
//Particle 2 Variables
frame_speed[1] = 0         //Vertical Speed of Particle
part_frame[1]  = 7         //Animation Frame of Particle
position[1]    = 16        //Horizontal Offset
position_offset[1] = -15   //Randomized Horizontal Offset
sparkle_offset[1] = 0      //Randomized Horizontal Offset
//Particle 3 Variables
frame_speed[2] = 0         //Vertical Speed of Particle
part_frame[2]  = 7         //Animation Frame of Particle
position[2]    = 16        //Horizontal Offset
position_offset[2] = 1     //Randomized Horizontal Offset
sparkle_offset[2] = 0      //Randomized Horizontal Offset
//Particle 4 Variables
frame_speed[3] = 0         //Vertical Speed of Particle
part_frame[3]  = 7         //Animation Frame of Particle
position[3]    = 16        //Horizontal Offset
position_offset[3] = -7    //Randomized Horizontal Offset
sparkle_offset[3] = 0      //Randomized Horizontal Offset
//Particle 5 Variables
frame_speed[4] = 0         //Vertical Speed of Particle
part_frame[4]  = 7         //Animation Frame of Particle
position[4]    = 16        //Horizontal Offset
position_offset[4] = +9    //Randomized Horizontal Offset
sparkle_offset[4] = 0      //Randomized Horizontal Offset
//Particle 6 Variables
frame_speed[5] = 0         //Vertical Speed of Particle
part_frame[5]  = 7         //Animation Frame of Particle
position[5]    = 16        //Horizontal Offset
position_offset[5] = -30   //Randomized Horizontal Offset
sparkle_offset[5] = 0      //Randomized Horizontal Offset
//Particle 7 Variables
frame_speed[6] = 0         //Vertical Speed of Particle
part_frame[6]  = 7         //Animation Frame of Particle
position[6]    = 16        //Horizontal Offset
position_offset[6] = 0     //Randomized Horizontal Offset
sparkle_offset[6] = 0      //Randomized Horizontal Offset
//Particle 8 Variables
frame_speed[7] = 0         //Vertical Speed of Particle
part_frame[7]  = 7         //Animation Frame of Particle
position[7]    = 16        //Horizontal Offset
position_offset[7] = -4   //Randomized Horizontal Offset
sparkle_offset[7] = 0      //Randomized Horizontal Offset
//Particle 9 Variables
frame_speed[8] = 0         //Vertical Speed of Particle
part_frame[8]  = 7         //Animation Frame of Particle
position[8]    = 16        //Horizontal Offset
position_offset[8] = +4    //Randomized Horizontal Offset
sparkle_offset[8] = 0      //Randomized Horizontal Offset
//Particle 10 Variables
frame_speed[9] = 0         //Vertical Speed of Particle
part_frame[9]  = 7         //Animation Frame of Particle
position[9]    = 16        //Horizontal Offset
position_offset[9] = -18   //Randomized Horizontal Offset
sparkle_offset[9] = 0      //Randomized Horizontal Offset

//Particle Frames
lilac_particle_frame[0]   = -128
lilac_particle_frame[1]   = -128
lilac_particle_frame[2]   = -128
lilac_particle_frame[3]   = -128
lilac_particle_frame[4]   = -128
lilac_particle_frame[5]   = -128
lilac_particle_frame[6]   = -128
lilac_particle_frame[7]   = -128
lilac_particle_frame[8]   = -128
lilac_particle_frame[9]   = -128
lilac_particle_frame[10]  = -128
lilac_particle_frame[11]  = -128
lilac_particle_frame[12]  = -128
lilac_particle_frame[13]  = -128
lilac_particle_frame[14]  = -128
lilac_particle_frame[15]  = -128
lilac_particle_frame[16]  = -128
lilac_particle_frame[17]  = -128
lilac_particle_frame[18]  = -128
lilac_particle_frame[19]  = -128
lilac_particle_frame[20]  = -128
lilac_particle_frame[21]  = -128
lilac_particle_frame[22]  = -128
lilac_particle_frame[23]  = -128
lilac_particle_frame[24]  = -128
lilac_particle_frame[25]  = -128
lilac_particle_frame[26]  = -128
lilac_particle_frame[27]  = -128
lilac_particle_frame[28]  = -128
lilac_particle_frame[29]  = -128
lilac_particle_frame[30]  = -128
//Particle X Positions
lilac_particle_x[0]   = px+random_range(-18,18)
lilac_particle_x[1]   = px+random_range(-18,18)
lilac_particle_x[2]   = px+random_range(-18,18)
lilac_particle_x[3]   = px+random_range(-18,18)
lilac_particle_x[4]   = px+random_range(-18,18)
lilac_particle_x[5]   = px+random_range(-18,18)
lilac_particle_x[6]   = px+random_range(-18,18)
lilac_particle_x[7]   = px+random_range(-18,18)
lilac_particle_x[8]   = px+random_range(-18,18)
lilac_particle_x[9]   = px+random_range(-18,18)
lilac_particle_x[10]  = px+random_range(-18,18)
lilac_particle_x[11]  = px+random_range(-18,18)
lilac_particle_x[12]  = px+random_range(-18,18)
lilac_particle_x[13]  = px+random_range(-18,18)
lilac_particle_x[14]  = px+random_range(-18,18)
lilac_particle_x[15]  = px+random_range(-18,18)
lilac_particle_x[16]  = px+random_range(-18,18)
lilac_particle_x[17]  = px+random_range(-18,18)
lilac_particle_x[18]  = px+random_range(-18,18)
lilac_particle_x[19]  = px+random_range(-18,18)
lilac_particle_x[20]  = px+random_range(-18,18)
lilac_particle_x[21]  = px+random_range(-18,18)
lilac_particle_x[22]  = px+random_range(-18,18)
lilac_particle_x[23]  = px+random_range(-18,18)
lilac_particle_x[24]  = px+random_range(-18,18)
lilac_particle_x[25]  = px+random_range(-18,18)
lilac_particle_x[26]  = px+random_range(-18,18)
lilac_particle_x[27]  = px+random_range(-18,18)
lilac_particle_x[28]  = px+random_range(-18,18)
lilac_particle_x[29]  = px+random_range(-18,18)
lilac_particle_x[30]  = px+random_range(-18,18)
//Particle Y Positions
lilac_particle_y[0]   = py+random_range(-12,24)
lilac_particle_y[1]   = py+random_range(-12,24)
lilac_particle_y[2]   = py+random_range(-12,24)
lilac_particle_y[3]   = py+random_range(-12,24)
lilac_particle_y[4]   = py+random_range(-12,24)
lilac_particle_y[5]   = py+random_range(-12,24)
lilac_particle_y[6]   = py+random_range(-12,24)
lilac_particle_y[7]   = py+random_range(-12,24)
lilac_particle_y[8]   = py+random_range(-12,24)
lilac_particle_y[9]   = py+random_range(-12,24)
lilac_particle_y[10]  = py+random_range(-12,24)
lilac_particle_y[11]  = py+random_range(-12,24)
lilac_particle_y[12]  = py+random_range(-12,24)
lilac_particle_y[13]  = py+random_range(-12,24)
lilac_particle_y[14]  = py+random_range(-12,24)
lilac_particle_y[15]  = py+random_range(-12,24)
lilac_particle_y[16]  = py+random_range(-12,24)
lilac_particle_y[17]  = py+random_range(-12,24)
lilac_particle_y[18]  = py+random_range(-12,24)
lilac_particle_y[19]  = py+random_range(-12,24)
lilac_particle_y[20]  = py+random_range(-12,24)
lilac_particle_y[21]  = py+random_range(-12,24)
lilac_particle_y[22]  = py+random_range(-12,24)
lilac_particle_y[23]  = py+random_range(-12,24)
lilac_particle_y[24]  = py+random_range(-12,24)
lilac_particle_y[25]  = py+random_range(-12,24)
lilac_particle_y[26]  = py+random_range(-12,24)
lilac_particle_y[27]  = py+random_range(-12,24)
lilac_particle_y[28]  = py+random_range(-12,24)
lilac_particle_y[29]  = py+random_range(-12,24)
lilac_particle_y[30]  = py+random_range(-12,24)

//Carol's Bike Particles
carol_particle_frame[0]   = -128
carol_particle_frame[1]   = -128
carol_particle_frame[2]   = -128
carol_particle_frame[3]   = -128
carol_particle_frame[4]   = -128
carol_particle_frame[5]   = -128
carol_particle_frame[6]   = -128
carol_particle_frame[7]   = -128
carol_particle_frame[8]   = -128
carol_particle_frame[9]   = -128
carol_particle_frame[10]  = -128

//Particle X Positions
carol_particle_x[0]   = px
carol_particle_x[1]   = px
carol_particle_x[2]   = px
carol_particle_x[3]   = px
carol_particle_x[4]   = px
carol_particle_x[5]   = px
carol_particle_x[6]   = px
carol_particle_x[7]   = px
carol_particle_x[8]   = px
carol_particle_x[9]   = px
carol_particle_x[10]  = px
//Particle Y Positions
carol_particle_y[0]   = py
carol_particle_y[1]   = py
carol_particle_y[2]   = py
carol_particle_y[3]   = py
carol_particle_y[4]   = py
carol_particle_y[5]   = py
carol_particle_y[6]   = py
carol_particle_y[7]   = py
carol_particle_y[8]   = py
carol_particle_y[9]   = py
carol_particle_y[10]  = py

carol_particle_angle  = 0
carol_boost_visible=0

//Milla Phantom Cube Particles
milla_particle_frame_1  = -128    //Animation Frame for Particle 1
milla_particle_frame_2  = -128    //Animation Frame for Particle 2
milla_particle_frame_3  = -128    //Animation Frame for Particle 3
milla_particle_frame_4  = -128    //Animation Frame for Particle 4
milla_particle_frame_5  = -128    //Animation Frame for Particle 5
milla_particle_frame_6  = -128    //Animation Frame for Particle 5
//Particle X/Y Positions
milla_particle_x_1  = px; milla_particle_y_1  = py;
milla_particle_x_2  = px; milla_particle_y_2  = py;
milla_particle_x_3  = px; milla_particle_y_3  = py;
milla_particle_x_4  = px; milla_particle_y_4  = py;
milla_particle_x_5  = px; milla_particle_y_5  = py;
milla_particle_x_6  = px; milla_particle_y_6  = py;
milla_particle_x_6_ang = 0;

weather_rain_particles_frame = 0

//Rotating Spikes Animations
rotating_spikes_frame = 0
//Global Crystal Gem Animations
crystal_gem_frame = 0
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///HUD Variables

//Initialize Player Variables
scr_set_init_player_stats()
scr_set_water_height_init()
scr_set_timers_and_fonts_init()
scr_set_camera_resolutions_init()
scr_set_screen_transitions_init()

//Player Health and Stats
petals          = 14                //Current number of health petals
petalsmax       = 14                //Maximum health petals
stamina         = 0                 //Stamina bar
stamina_confirm = 0                 //Stamina flash (bar is filled)
stamina_gem_con = 0                 //Stamina flash (collecting gem confirmation)
stamina_gem     = 0                 //Stamina flash (collecting gem)
stamina_pause   = 0                 //Stamina generic pause trigger
stamina_boosted = 0                 //Stamina boosted status
stamina_target  = 0                 //Stamina boosted status
lives           = 5                 //Lives counter
lives_spr       = 0                 //Lives sprite icon
gems            = 250               //Real value for gems
gems_value      = gems              //Incremental adjuster for the gems
petals_value    = petals            //How many petals do we currently have?
petals_count    = 0                 //How many petals since the wood shield was active?
one_up          = 0                 //1up Particle Trigger
one_up_offset   = 0                 //1up Particle Offset
invuln_hud_time = 0                 //How Long Will We Be Invincible?
invuln_hud_draw = 0                 //Is The Invincibility Alarm Clock Icon Flickering Right Now?
invuln_hud_modi = 0                 //How Fast Is The Invincibility Icon Flickering?
invuln_hud_acti = 0                 //Is Invincibility Active At This Time?
invuln_hud_fram = 0                 //Which Alarm Clock Frame Are We Displaying?
hud_graphics    = spr_hud_main      //Which HUD Are We Using?
hud_petals      = spr_hud_petal     //Which Petal Graphics Are We Displaying?
hud_flash       = 0                 //When Our HP Is Low, Flash HUD
milla_hud       = 0                 //Animation Frame For Milla's HUD
milla_hud_flash = 0                 //Flash Frame When Charging An Attack
gem_plus_pos    = 0                 //How Many Positions Down Should We Start?
//Variables for the debug menu toggles
debug_hud = 0                       //Should we draw the debug HUD?
debug_character_position = 1        //Which character should we switch to?
debug_profiler = 0                  //Should we enable the debug profiler?
debug_hud_sensors = 0               //Should we enable the drawing of collision sensors?
debug_hud_mode = 1                  //Should we enable the currently selected debug mode?
debug_characters_x = 337            //What is our drawing X position for the characters HUD display?
debug_characters_y = 55             //What is our drawing Y position for the characters HUD display?
debug_highlight_x1 = 338
debug_highlight_x2 = 358
debug_highlight_x3 = 378
debug_highlight_x4 = 398
debug_highlight_y1 = 71
accident_forgiveness = 1
now_loading = 0
player_mode = 0
//Animation Timers for the HUD
shine_frame = 0               //Stamina Bar Shimmer
HUD_offset  = -56             //Y Offset For HUD
input_mode  = 0               //Animation Frame For The Input Mode Notification
input_timer = 0               //Timer For The Input Mode Notification
//Underwater Health and Stats
breath          = 11.5              //How much breath do we have while diving underwater?
breath_max      = 11.5              //How much breath do we restore upon touching an air bubble?
breath_offset   = -14               //Air Bar Offset
breath_modifier = 0.005             //How much breath will we lose per frame?
splash_frame    = -1                //Animation frames for splashing into water
splash_x        = 0                 //Offset value for X
splash_confirm  = 0                 //Confirmation of the splash effect
alarm_frame     = 0                 //Current animation frame for breath alarm
alarm_timer     = 660               //Timer for breath alarm
alarm_shake_x   = 0                 //Alarm Sprite Shake X
alarm_shake_y   = 0                 //Alarm Sprite Shake Y
//Shang Mu Academy Targets
targets         = 1                 //How many targets do we have left to hit?
targets_mode    = spr_hud_target    //Which game mode are we actively playing?
targets_ready   = 0                 //Are we preparing to play hit the targets?
hud_ready_bar_length = 0            //What is the current length of the ready bar?
hud_go_shake    = 0                 //What is our sprite offset while shaking?
hud_go_shake_timer = 0              //How long have we been shaking?
hud_go_shake_loops = 0              //How many times have we been shaking?
hud_go_trans_timer = 0              //How long until we activate the skewed slice transition?
hud_new_record = 0
//Camera Zoom
use_zoom_x_view = view_wview[view_port]
use_zoom_y_view = view_hview[view_port]
use_zoom_scale_factor = 1
use_zoom_iterate = 0
use_zoom_counter = 0
//Weather Conditions
use_weather_conditions = 0
use_weather_x_0 = 0
use_weather_y_0 = 0
use_weather_direction = 0
use_weather_fade_effect = 0
use_weather_fade_target = 0
use_weather_timer = 5
use_thunder_timer = 0
use_flood_timer = 0
use_thunder_fade_effect = 0
use_thunder_fade_target = 0
//Win Conditions
use_win_conditions = 0
use_win_conditions_string = "Break the Targets!"
//Flood Fill Parameters
use_flood_fill_speed = 1

//General Notifications
general_notifications[0] = 0
general_notifications[1] = 0
general_notifications[2] = 0
general_notifications[3] = 0
general_notifications[4] = 0
general_notifications[5] = 0
general_notifications_string[0] = ""
general_notifications_string[1] = ""
general_notifications_string[2] = ""
general_notifications_string[3] = ""
general_notifications_string[4] = ""
general_notifications_string[5] = ""
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Tile Collision Height Maps

        //Create 32-Bit Array
        var temp_clip = 0;
        orig_clip[0,0]= 0;
        while(temp_clip &lt; 28000)
            {
                orig_clip[temp_clip,0] = -8
                temp_clip += 1
            }
        //Call Slope Tile Pseudonyms, Before Other Scripts Are Called That Need Their Values
        scr_slope_tile_pseudonyms()

        //Test Room Ramp Pieces
        scr_tile_ramp_1(tile_ramp_1,tile_ramp_1+scr_local_angles,tile_ramp_1+scr_local_height,tile_ramp_1+scr_local_s_type,tile_ramp_1+scr_local_launch)
        scr_tile_ramp_2(tile_ramp_2,tile_ramp_2+scr_local_angles,tile_ramp_2+scr_local_height,tile_ramp_2+scr_local_s_type,tile_ramp_2+scr_local_launch)
        scr_tile_ramp_3(tile_ramp_3,tile_ramp_3+scr_local_angles,tile_ramp_3+scr_local_height,tile_ramp_3+scr_local_s_type,tile_ramp_3+scr_local_launch)
        scr_tile_ramp_4(tile_ramp_4,tile_ramp_4+scr_local_angles,tile_ramp_4+scr_local_height,tile_ramp_4+scr_local_s_type,tile_ramp_4+scr_local_launch)
        scr_tile_ramp_auto(tile_ramp_auto,tile_ramp_auto+scr_local_angles,tile_ramp_auto+scr_local_height,tile_ramp_auto+scr_local_s_type,tile_ramp_auto+scr_local_launch)
        scr_tile_ramp_entry(tile_ramp_entry,tile_ramp_entry+scr_local_angles,tile_ramp_entry+scr_local_height,tile_ramp_entry+scr_local_s_type,tile_ramp_entry+scr_local_launch)
        scr_tile_bridge_mask(tile_bridge_mask,tile_bridge_mask+scr_local_angles,tile_bridge_mask+scr_local_height,tile_bridge_mask+scr_local_s_type,tile_bridge_mask+scr_local_launch)
        scr_tile_fof_0(tile_fof_0,tile_fof_0+scr_local_angles,tile_fof_0+scr_local_height,tile_fof_0+scr_local_s_type,tile_fof_0+scr_local_launch)
        scr_tile_fof_1(tile_fof_1,tile_fof_1+scr_local_angles,tile_fof_1+scr_local_height,tile_fof_1+scr_local_s_type,tile_fof_1+scr_local_launch)
        scr_tile_fof_1(tile_fof_2,tile_fof_2+scr_local_angles,tile_fof_2+scr_local_height,tile_fof_2+scr_local_s_type,tile_fof_2+scr_local_launch)
        //Shang Mu Academy
        scr_mu_ramp_0(mu_ramp_0,mu_ramp_0+scr_local_angles,mu_ramp_0+scr_local_height,mu_ramp_0+scr_local_s_type,mu_ramp_0+scr_local_launch)
        scr_mu_ramp_1(mu_ramp_1,mu_ramp_1+scr_local_angles,mu_ramp_1+scr_local_height,mu_ramp_1+scr_local_s_type,mu_ramp_1+scr_local_launch)
        scr_mu_ramp_2(mu_ramp_2,mu_ramp_2+scr_local_angles,mu_ramp_2+scr_local_height,mu_ramp_2+scr_local_s_type,mu_ramp_2+scr_local_launch)
        scr_mu_ramp_3(mu_ramp_3,mu_ramp_3+scr_local_angles,mu_ramp_3+scr_local_height,mu_ramp_3+scr_local_s_type,mu_ramp_3+scr_local_launch)
        scr_mu_ramp_4(mu_ramp_4,mu_ramp_4+scr_local_angles,mu_ramp_4+scr_local_height,mu_ramp_4+scr_local_s_type,mu_ramp_4+scr_local_launch)
        scr_mu_ramp_5(mu_ramp_5,mu_ramp_5+scr_local_angles,mu_ramp_5+scr_local_height,mu_ramp_5+scr_local_s_type,mu_ramp_5+scr_local_launch)
        scr_mu_ramp_6(mu_ramp_6,mu_ramp_6+scr_local_angles,mu_ramp_6+scr_local_height,mu_ramp_6+scr_local_s_type,mu_ramp_6+scr_local_launch)
        scr_mu_ramp_7(mu_ramp_7,mu_ramp_7+scr_local_angles,mu_ramp_7+scr_local_height,mu_ramp_7+scr_local_s_type,mu_ramp_7+scr_local_launch)
        scr_mu_ramp_8(mu_ramp_8,mu_ramp_8+scr_local_angles,mu_ramp_8+scr_local_height,mu_ramp_8+scr_local_s_type,mu_ramp_8+scr_local_launch)
        scr_mu_ramp_9(mu_ramp_9,mu_ramp_9+scr_local_angles,mu_ramp_9+scr_local_height,mu_ramp_9+scr_local_s_type,mu_ramp_9+scr_local_launch)
        scr_mu_ramp_16(mu_ramp_16,mu_ramp_16+scr_local_angles,mu_ramp_16+scr_local_height,mu_ramp_16+scr_local_s_type,mu_ramp_16+scr_local_launch)
        scr_mu_ramp_17(mu_ramp_17,mu_ramp_17+scr_local_angles,mu_ramp_17+scr_local_height,mu_ramp_17+scr_local_s_type,mu_ramp_17+scr_local_launch)
        scr_mu_ramp_18(mu_ramp_18,mu_ramp_18+scr_local_angles,mu_ramp_18+scr_local_height,mu_ramp_18+scr_local_s_type,mu_ramp_18+scr_local_launch)
        scr_mu_ramp_19(mu_ramp_19,mu_ramp_19+scr_local_angles,mu_ramp_19+scr_local_height,mu_ramp_19+scr_local_s_type,mu_ramp_19+scr_local_launch)
        scr_mu_ramp_20(mu_ramp_20,mu_ramp_20+scr_local_angles,mu_ramp_20+scr_local_height,mu_ramp_20+scr_local_s_type,mu_ramp_20+scr_local_launch)
        scr_mu_ramp_21(mu_ramp_21,mu_ramp_21+scr_local_angles,mu_ramp_21+scr_local_height,mu_ramp_21+scr_local_s_type,mu_ramp_21+scr_local_launch)
        scr_mu_ramp_22(mu_ramp_22,mu_ramp_22+scr_local_angles,mu_ramp_22+scr_local_height,mu_ramp_22+scr_local_s_type,mu_ramp_22+scr_local_launch)
        scr_mu_ramp_23(mu_ramp_23,mu_ramp_23+scr_local_angles,mu_ramp_23+scr_local_height,mu_ramp_23+scr_local_s_type,mu_ramp_23+scr_local_launch)
        scr_mu_ramp_24(mu_ramp_24,mu_ramp_24+scr_local_angles,mu_ramp_24+scr_local_height,mu_ramp_24+scr_local_s_type,mu_ramp_24+scr_local_launch)
        scr_mu_ramp_25(mu_ramp_25,mu_ramp_25+scr_local_angles,mu_ramp_25+scr_local_height,mu_ramp_25+scr_local_s_type,mu_ramp_25+scr_local_launch)
        scr_mu_slope_0(mu_slope_0,mu_slope_0+scr_local_angles,mu_slope_0+scr_local_height,mu_slope_0+scr_local_s_type,mu_slope_0+scr_local_launch)
        scr_mu_slope_1(mu_slope_1,mu_slope_1+scr_local_angles,mu_slope_1+scr_local_height,mu_slope_1+scr_local_s_type,mu_slope_1+scr_local_launch)
        scr_mu_slope_2(mu_slope_2,mu_slope_2+scr_local_angles,mu_slope_2+scr_local_height,mu_slope_2+scr_local_s_type,mu_slope_2+scr_local_launch)
        scr_mu_slope_3(mu_slope_3,mu_slope_3+scr_local_angles,mu_slope_3+scr_local_height,mu_slope_3+scr_local_s_type,mu_slope_3+scr_local_launch)
        scr_mu_slope_4(mu_slope_4,mu_slope_4+scr_local_angles,mu_slope_4+scr_local_height,mu_slope_4+scr_local_s_type,mu_slope_4+scr_local_launch)
        scr_mu_slope_5(mu_slope_5,mu_slope_5+scr_local_angles,mu_slope_5+scr_local_height,mu_slope_5+scr_local_s_type,mu_slope_5+scr_local_launch)
        scr_mu_slope_6(mu_slope_6,mu_slope_6+scr_local_angles,mu_slope_6+scr_local_height,mu_slope_6+scr_local_s_type,mu_slope_6+scr_local_launch)
        scr_mu_slope_7(mu_slope_7,mu_slope_7+scr_local_angles,mu_slope_7+scr_local_height,mu_slope_7+scr_local_s_type,mu_slope_7+scr_local_launch)
        scr_mu_slope_8(mu_slope_8,mu_slope_8+scr_local_angles,mu_slope_8+scr_local_height,mu_slope_8+scr_local_s_type,mu_slope_8+scr_local_launch)
        scr_mu_slope_9(mu_slope_9,mu_slope_9+scr_local_angles,mu_slope_9+scr_local_height,mu_slope_9+scr_local_s_type,mu_slope_9+scr_local_launch)
        scr_mu_slope_10(mu_slope_10,mu_slope_10+scr_local_angles,mu_slope_10+scr_local_height,mu_slope_10+scr_local_s_type,mu_slope_10+scr_local_launch)
        scr_mu_slope_11(mu_slope_11,mu_slope_11+scr_local_angles,mu_slope_11+scr_local_height,mu_slope_11+scr_local_s_type,mu_slope_11+scr_local_launch)
        scr_mu_slope_12(mu_slope_12,mu_slope_12+scr_local_angles,mu_slope_12+scr_local_height,mu_slope_12+scr_local_s_type,mu_slope_12+scr_local_launch)
        scr_mu_slope_13(mu_slope_13,mu_slope_13+scr_local_angles,mu_slope_13+scr_local_height,mu_slope_13+scr_local_s_type,mu_slope_13+scr_local_launch)
        scr_mu_slope_14(mu_slope_14,mu_slope_14+scr_local_angles,mu_slope_14+scr_local_height,mu_slope_14+scr_local_s_type,mu_slope_14+scr_local_launch)
        scr_mu_slope_15(mu_slope_15,mu_slope_15+scr_local_angles,mu_slope_15+scr_local_height,mu_slope_15+scr_local_s_type,mu_slope_15+scr_local_launch)
        scr_mu_slope_16(mu_slope_16,mu_slope_16+scr_local_angles,mu_slope_16+scr_local_height,mu_slope_16+scr_local_s_type,mu_slope_16+scr_local_launch)
        scr_mu_slope_17(mu_slope_17,mu_slope_17+scr_local_angles,mu_slope_17+scr_local_height,mu_slope_17+scr_local_s_type,mu_slope_17+scr_local_launch)
        scr_mu_slope_18(mu_slope_18,mu_slope_18+scr_local_angles,mu_slope_18+scr_local_height,mu_slope_18+scr_local_s_type,mu_slope_18+scr_local_launch)
        scr_mu_slope_19(mu_slope_19,mu_slope_19+scr_local_angles,mu_slope_19+scr_local_height,mu_slope_19+scr_local_s_type,mu_slope_19+scr_local_launch)
        scr_mu_slope_2(mu_slope_26,mu_slope_26+scr_local_angles,mu_slope_26+scr_local_height,mu_slope_26+scr_local_s_type,mu_slope_26+scr_local_launch)
        scr_mu_slope_3(mu_slope_27,mu_slope_27+scr_local_angles,mu_slope_27+scr_local_height,mu_slope_27+scr_local_s_type,mu_slope_27+scr_local_launch)
        scr_mu_slope_4(mu_slope_24,mu_slope_24+scr_local_angles,mu_slope_24+scr_local_height,mu_slope_24+scr_local_s_type,mu_slope_24+scr_local_launch)
        scr_mu_slope_5(mu_slope_25,mu_slope_25+scr_local_angles,mu_slope_25+scr_local_height,mu_slope_25+scr_local_s_type,mu_slope_25+scr_local_launch)
        scr_mu_slope_6(mu_slope_22,mu_slope_22+scr_local_angles,mu_slope_22+scr_local_height,mu_slope_22+scr_local_s_type,mu_slope_22+scr_local_launch)
        scr_mu_slope_7(mu_slope_23,mu_slope_23+scr_local_angles,mu_slope_23+scr_local_height,mu_slope_23+scr_local_s_type,mu_slope_23+scr_local_launch)
        scr_mu_slope_8(mu_slope_20,mu_slope_20+scr_local_angles,mu_slope_20+scr_local_height,mu_slope_20+scr_local_s_type,mu_slope_20+scr_local_launch)
        scr_mu_slope_9(mu_slope_21,mu_slope_21+scr_local_angles,mu_slope_21+scr_local_height,mu_slope_21+scr_local_s_type,mu_slope_21+scr_local_launch)
        scr_mu_slope_ceiling_48(mu_slope_ceiling_48,mu_slope_ceiling_48+scr_local_angles,mu_slope_ceiling_48+scr_local_height,mu_slope_ceiling_48+scr_local_s_type,mu_slope_ceiling_48+scr_local_launch)
        scr_mu_slope_ceiling_64(mu_slope_ceiling_64,mu_slope_ceiling_64+scr_local_angles,mu_slope_ceiling_64+scr_local_height,mu_slope_ceiling_64+scr_local_s_type,mu_slope_ceiling_64+scr_local_launch)
        scr_mu_slope_ceiling_16(mu_slope_ceiling_16,mu_slope_ceiling_16+scr_local_angles,mu_slope_ceiling_16+scr_local_height,mu_slope_ceiling_16+scr_local_s_type,mu_slope_ceiling_16+scr_local_launch)
        scr_mu_fof_0    (mu_fof_0,mu_fof_0+scr_local_angles,mu_fof_0+scr_local_height,mu_fof_0+scr_local_s_type,mu_fof_0+scr_local_launch)
        scr_mu_fof_1    (mu_fof_1,mu_fof_1+scr_local_angles,mu_fof_1+scr_local_height,mu_fof_1+scr_local_s_type,mu_fof_1+scr_local_launch)
        scr_mu_fof_2    (mu_fof_2,mu_fof_2+scr_local_angles,mu_fof_2+scr_local_height,mu_fof_2+scr_local_s_type,mu_fof_2+scr_local_launch)
        scr_mu_fof_3    (mu_fof_3,mu_fof_3+scr_local_angles,mu_fof_3+scr_local_height,mu_fof_3+scr_local_s_type,mu_fof_3+scr_local_launch)
        scr_mu_fof_1    (mu_fof_10,mu_fof_10+scr_local_angles,mu_fof_10+scr_local_height,mu_fof_10+scr_local_s_type,mu_fof_10+scr_local_launch)
        scr_mu_fof_3    (mu_fof_11,mu_fof_11+scr_local_angles,mu_fof_11+scr_local_height,mu_fof_11+scr_local_s_type,mu_fof_11+scr_local_launch)
        scr_mu_fof_0    (mu_fof_12,mu_fof_12+scr_local_angles,mu_fof_12+scr_local_height,mu_fof_12+scr_local_s_type,mu_fof_12+scr_local_launch)
        scr_mu_fof_3    (mu_fof_13,mu_fof_13+scr_local_angles,mu_fof_13+scr_local_height,mu_fof_13+scr_local_s_type,mu_fof_13+scr_local_launch)
        scr_dirt_0      (spr_dirt_0,spr_dirt_0+scr_local_angles,spr_dirt_0+scr_local_height,spr_dirt_0+scr_local_s_type,spr_dirt_0+scr_local_launch)

        //Beihai Bay
        scr_mu_slope_10(bb_slope_10,bb_slope_10+scr_local_angles,bb_slope_10+scr_local_height,bb_slope_10+scr_local_s_type,bb_slope_10+scr_local_launch)
        scr_mu_slope_11(bb_slope_11,bb_slope_11+scr_local_angles,bb_slope_11+scr_local_height,bb_slope_11+scr_local_s_type,bb_slope_11+scr_local_launch)
        scr_mu_slope_12(bb_slope_12,bb_slope_12+scr_local_angles,bb_slope_12+scr_local_height,bb_slope_12+scr_local_s_type,bb_slope_12+scr_local_launch)
        scr_mu_slope_13(bb_slope_13,bb_slope_13+scr_local_angles,bb_slope_13+scr_local_height,bb_slope_13+scr_local_s_type,bb_slope_13+scr_local_launch)
        scr_mu_slope_14(bb_slope_14,bb_slope_14+scr_local_angles,bb_slope_14+scr_local_height,bb_slope_14+scr_local_s_type,bb_slope_14+scr_local_launch)
        scr_mu_slope_15(bb_slope_15,bb_slope_15+scr_local_angles,bb_slope_15+scr_local_height,bb_slope_15+scr_local_s_type,bb_slope_15+scr_local_launch)
        scr_mu_slope_16(bb_slope_16,bb_slope_16+scr_local_angles,bb_slope_16+scr_local_height,bb_slope_16+scr_local_s_type,bb_slope_16+scr_local_launch)
        scr_mu_slope_17(bb_slope_17,bb_slope_17+scr_local_angles,bb_slope_17+scr_local_height,bb_slope_17+scr_local_s_type,bb_slope_17+scr_local_launch)
        scr_ll_slope_1_alt(bb_slope_0,bb_slope_0+scr_local_angles,bb_slope_0+scr_local_height,bb_slope_0+scr_local_s_type,bb_slope_0+scr_local_launch)
        scr_ll_slope_2_alt(bb_slope_1,bb_slope_1+scr_local_angles,bb_slope_1+scr_local_height,bb_slope_1+scr_local_s_type,bb_slope_1+scr_local_launch)
        scr_ll_slope_1_alt(bb_slope_2,bb_slope_2+scr_local_angles,bb_slope_2+scr_local_height,bb_slope_2+scr_local_s_type,bb_slope_2+scr_local_launch)
        scr_ll_slope_2_alt(bb_slope_3,bb_slope_3+scr_local_angles,bb_slope_3+scr_local_height,bb_slope_3+scr_local_s_type,bb_slope_3+scr_local_launch)
        scr_mu_fof_0   (bb_fof_0,bb_fof_0+scr_local_angles,bb_fof_0+scr_local_height,bb_fof_0+scr_local_s_type,bb_fof_0+scr_local_launch)
        scr_mnt_fof_3  (bb_fof_3,bb_fof_3+scr_local_angles,bb_fof_3+scr_local_height,bb_fof_3+scr_local_s_type,bb_fof_3+scr_local_launch)
        scr_mnt_fof_3  (bb_fof_3_ignore,bb_fof_3_ignore+scr_local_angles,bb_fof_3_ignore+scr_local_height,bb_fof_3_ignore+scr_local_s_type,bb_fof_3_ignore+scr_local_launch)

        //West District
        scr_wd_ramp_0(wd_ramp_0,wd_ramp_0+scr_local_angles,wd_ramp_0+scr_local_height,wd_ramp_0+scr_local_s_type,wd_ramp_0+scr_local_launch)
        scr_wd_ramp_1(wd_ramp_1,wd_ramp_1+scr_local_angles,wd_ramp_1+scr_local_height,wd_ramp_1+scr_local_s_type,wd_ramp_1+scr_local_launch)
        scr_wd_ramp_2(wd_ramp_2,wd_ramp_2+scr_local_angles,wd_ramp_2+scr_local_height,wd_ramp_2+scr_local_s_type,wd_ramp_2+scr_local_launch)
        scr_wd_ramp_3(wd_ramp_3,wd_ramp_3+scr_local_angles,wd_ramp_3+scr_local_height,wd_ramp_3+scr_local_s_type,wd_ramp_3+scr_local_launch)
        scr_wd_ramp_4(wd_ramp_4,wd_ramp_4+scr_local_angles,wd_ramp_4+scr_local_height,wd_ramp_4+scr_local_s_type,wd_ramp_4+scr_local_launch)
        scr_wd_ramp_5(wd_ramp_5,wd_ramp_5+scr_local_angles,wd_ramp_5+scr_local_height,wd_ramp_5+scr_local_s_type,wd_ramp_5+scr_local_launch)
        scr_wd_ramp_6(wd_ramp_6,wd_ramp_6+scr_local_angles,wd_ramp_6+scr_local_height,wd_ramp_6+scr_local_s_type,wd_ramp_6+scr_local_launch)
        scr_wd_ramp_7(wd_ramp_7,wd_ramp_7+scr_local_angles,wd_ramp_7+scr_local_height,wd_ramp_7+scr_local_s_type,wd_ramp_7+scr_local_launch)
        scr_wd_ramp_8(wd_ramp_8,wd_ramp_8+scr_local_angles,wd_ramp_8+scr_local_height,wd_ramp_8+scr_local_s_type,wd_ramp_8+scr_local_launch)
        scr_wd_ramp_9(wd_ramp_9,wd_ramp_9+scr_local_angles,wd_ramp_9+scr_local_height,wd_ramp_9+scr_local_s_type,wd_ramp_9+scr_local_launch)
        scr_wd_ramp_10(wd_ramp_10,wd_ramp_10+scr_local_angles,wd_ramp_10+scr_local_height,wd_ramp_10+scr_local_s_type,wd_ramp_10+scr_local_launch)
        scr_wd_ramp_11(wd_ramp_11,wd_ramp_11+scr_local_angles,wd_ramp_11+scr_local_height,wd_ramp_11+scr_local_s_type,wd_ramp_11+scr_local_launch)
        scr_wd_ramp_12(wd_ramp_12,wd_ramp_12+scr_local_angles,wd_ramp_12+scr_local_height,wd_ramp_12+scr_local_s_type,wd_ramp_12+scr_local_launch)
        scr_wd_ramp_13(wd_ramp_13,wd_ramp_13+scr_local_angles,wd_ramp_13+scr_local_height,wd_ramp_13+scr_local_s_type,wd_ramp_13+scr_local_launch)
        scr_wd_ramp_14(wd_ramp_14,wd_ramp_14+scr_local_angles,wd_ramp_14+scr_local_height,wd_ramp_14+scr_local_s_type,wd_ramp_14+scr_local_launch)
        scr_wd_ramp_15(wd_ramp_15,wd_ramp_15+scr_local_angles,wd_ramp_15+scr_local_height,wd_ramp_15+scr_local_s_type,wd_ramp_15+scr_local_launch)
        scr_wd_ramp_16(wd_ramp_16,wd_ramp_16+scr_local_angles,wd_ramp_16+scr_local_height,wd_ramp_16+scr_local_s_type,wd_ramp_16+scr_local_launch)
        scr_wd_ramp_17(wd_ramp_17,wd_ramp_17+scr_local_angles,wd_ramp_17+scr_local_height,wd_ramp_17+scr_local_s_type,wd_ramp_17+scr_local_launch)
        scr_wd_ramp_18(wd_ramp_18,wd_ramp_18+scr_local_angles,wd_ramp_18+scr_local_height,wd_ramp_18+scr_local_s_type,wd_ramp_18+scr_local_launch)
        scr_wd_ramp_19(wd_ramp_19,wd_ramp_19+scr_local_angles,wd_ramp_19+scr_local_height,wd_ramp_19+scr_local_s_type,wd_ramp_19+scr_local_launch)
        scr_wd_ramp_16(wd_ramp_20,wd_ramp_20+scr_local_angles,wd_ramp_20+scr_local_height,wd_ramp_20+scr_local_s_type,wd_ramp_20+scr_local_launch)
        scr_wd_ramp_17(wd_ramp_21,wd_ramp_21+scr_local_angles,wd_ramp_21+scr_local_height,wd_ramp_21+scr_local_s_type,wd_ramp_21+scr_local_launch)
        scr_wd_ramp_18(wd_ramp_22,wd_ramp_22+scr_local_angles,wd_ramp_22+scr_local_height,wd_ramp_22+scr_local_s_type,wd_ramp_22+scr_local_launch)
        scr_wd_ramp_19(wd_ramp_23,wd_ramp_23+scr_local_angles,wd_ramp_23+scr_local_height,wd_ramp_23+scr_local_s_type,wd_ramp_23+scr_local_launch)
        scr_wd_ramp_24(wd_ramp_24,wd_ramp_24+scr_local_angles,wd_ramp_24+scr_local_height,wd_ramp_24+scr_local_s_type,wd_ramp_24+scr_local_launch)
        scr_wd_ramp_25(wd_ramp_25,wd_ramp_25+scr_local_angles,wd_ramp_25+scr_local_height,wd_ramp_25+scr_local_s_type,wd_ramp_25+scr_local_launch)
        scr_wd_ramp_24(wd_ramp_26,wd_ramp_26+scr_local_angles,wd_ramp_26+scr_local_height,wd_ramp_26+scr_local_s_type,wd_ramp_26+scr_local_launch)
        scr_wd_ramp_25(wd_ramp_27,wd_ramp_27+scr_local_angles,wd_ramp_27+scr_local_height,wd_ramp_27+scr_local_s_type,wd_ramp_27+scr_local_launch)

        scr_wd_slope_0(wd_slope_0,wd_slope_0+scr_local_angles,wd_slope_0+scr_local_height,wd_slope_0+scr_local_s_type,wd_slope_0+scr_local_launch)
        scr_wd_slope_1(wd_slope_1,wd_slope_1+scr_local_angles,wd_slope_1+scr_local_height,wd_slope_1+scr_local_s_type,wd_slope_1+scr_local_launch)
        scr_wd_slope_2(wd_slope_2,wd_slope_2+scr_local_angles,wd_slope_2+scr_local_height,wd_slope_2+scr_local_s_type,wd_slope_2+scr_local_launch)
        scr_wd_slope_3(wd_slope_3,wd_slope_3+scr_local_angles,wd_slope_3+scr_local_height,wd_slope_3+scr_local_s_type,wd_slope_3+scr_local_launch)
        //Inside variants
        scr_wd_slope_0(wd_slope_27,wd_slope_27+scr_local_angles,wd_slope_27+scr_local_height,wd_slope_27+scr_local_s_type,wd_slope_27+scr_local_launch)
        scr_wd_slope_1(wd_slope_25,wd_slope_25+scr_local_angles,wd_slope_25+scr_local_height,wd_slope_25+scr_local_s_type,wd_slope_25+scr_local_launch)
        scr_wd_slope_2(wd_slope_24,wd_slope_24+scr_local_angles,wd_slope_24+scr_local_height,wd_slope_24+scr_local_s_type,wd_slope_24+scr_local_launch)
        scr_wd_slope_3(wd_slope_26,wd_slope_26+scr_local_angles,wd_slope_26+scr_local_height,wd_slope_26+scr_local_s_type,wd_slope_26+scr_local_launch)

        scr_wd_slope_4(wd_slope_4,wd_slope_4+scr_local_angles,wd_slope_4+scr_local_height,wd_slope_4+scr_local_s_type,wd_slope_4+scr_local_launch)
        scr_wd_slope_5(wd_slope_5,wd_slope_5+scr_local_angles,wd_slope_5+scr_local_height,wd_slope_5+scr_local_s_type,wd_slope_5+scr_local_launch)
        scr_wd_slope_6(wd_slope_6,wd_slope_6+scr_local_angles,wd_slope_6+scr_local_height,wd_slope_6+scr_local_s_type,wd_slope_6+scr_local_launch)
        scr_wd_slope_7(wd_slope_7,wd_slope_7+scr_local_angles,wd_slope_7+scr_local_height,wd_slope_7+scr_local_s_type,wd_slope_7+scr_local_launch)

        scr_wd_slope_8(wd_slope_8,wd_slope_8+scr_local_angles,wd_slope_8+scr_local_height,wd_slope_8+scr_local_s_type,wd_slope_8+scr_local_launch)
        scr_wd_slope_9(wd_slope_9,wd_slope_9+scr_local_angles,wd_slope_9+scr_local_height,wd_slope_9+scr_local_s_type,wd_slope_9+scr_local_launch)
        scr_wd_slope_10(wd_slope_10,wd_slope_10+scr_local_angles,wd_slope_10+scr_local_height,wd_slope_10+scr_local_s_type,wd_slope_10+scr_local_launch)
        scr_wd_slope_11(wd_slope_11,wd_slope_11+scr_local_angles,wd_slope_11+scr_local_height,wd_slope_11+scr_local_s_type,wd_slope_11+scr_local_launch)
        //Inside Variants
        scr_wd_slope_8(wd_slope_31,wd_slope_31+scr_local_angles,wd_slope_31+scr_local_height,wd_slope_31+scr_local_s_type,wd_slope_31+scr_local_launch)
        scr_wd_slope_9(wd_slope_29,wd_slope_29+scr_local_angles,wd_slope_29+scr_local_height,wd_slope_29+scr_local_s_type,wd_slope_29+scr_local_launch)
        scr_wd_slope_10(wd_slope_28,wd_slope_28+scr_local_angles,wd_slope_28+scr_local_height,wd_slope_28+scr_local_s_type,wd_slope_28+scr_local_launch)
        scr_wd_slope_11(wd_slope_30,wd_slope_30+scr_local_angles,wd_slope_30+scr_local_height,wd_slope_30+scr_local_s_type,wd_slope_30+scr_local_launch)

        scr_wd_slope_12(wd_slope_12,wd_slope_12+scr_local_angles,wd_slope_12+scr_local_height,wd_slope_12+scr_local_s_type,wd_slope_12+scr_local_launch)
        scr_wd_slope_13(wd_slope_13,wd_slope_13+scr_local_angles,wd_slope_13+scr_local_height,wd_slope_13+scr_local_s_type,wd_slope_13+scr_local_launch)
        scr_wd_slope_14(wd_slope_14,wd_slope_14+scr_local_angles,wd_slope_14+scr_local_height,wd_slope_14+scr_local_s_type,wd_slope_14+scr_local_launch)
        scr_wd_slope_15(wd_slope_15,wd_slope_15+scr_local_angles,wd_slope_15+scr_local_height,wd_slope_15+scr_local_s_type,wd_slope_15+scr_local_launch)
        //City
        scr_wd_slope_16(wd_slope_16,wd_slope_16+scr_local_angles,wd_slope_16+scr_local_height,wd_slope_16+scr_local_s_type,wd_slope_16+scr_local_launch)
        scr_wd_slope_17(wd_slope_17,wd_slope_17+scr_local_angles,wd_slope_17+scr_local_height,wd_slope_17+scr_local_s_type,wd_slope_17+scr_local_launch)
        scr_wd_slope_18(wd_slope_18,wd_slope_18+scr_local_angles,wd_slope_18+scr_local_height,wd_slope_18+scr_local_s_type,wd_slope_18+scr_local_launch)
        scr_wd_slope_19(wd_slope_19,wd_slope_19+scr_local_angles,wd_slope_19+scr_local_height,wd_slope_19+scr_local_s_type,wd_slope_19+scr_local_launch)
        //Lagoon Variants
        scr_wd_slope_16(ll_slope_4,ll_slope_4+scr_local_angles,ll_slope_4+scr_local_height,ll_slope_4+scr_local_s_type,ll_slope_4+scr_local_launch)
        scr_wd_slope_17(ll_slope_5,ll_slope_5+scr_local_angles,ll_slope_5+scr_local_height,ll_slope_5+scr_local_s_type,ll_slope_5+scr_local_launch)
        scr_wd_slope_18(ll_slope_6,ll_slope_6+scr_local_angles,ll_slope_6+scr_local_height,ll_slope_6+scr_local_s_type,ll_slope_6+scr_local_launch)
        scr_wd_slope_19(ll_slope_7,ll_slope_7+scr_local_angles,ll_slope_7+scr_local_height,ll_slope_7+scr_local_s_type,ll_slope_7+scr_local_launch)
        scr_wd_slope_19(ll_slope_8,ll_slope_8+scr_local_angles,ll_slope_8+scr_local_height,ll_slope_8+scr_local_s_type,ll_slope_8+scr_local_launch)
        scr_wd_slope_17(ll_slope_9,ll_slope_9+scr_local_angles,ll_slope_9+scr_local_height,ll_slope_9+scr_local_s_type,ll_slope_9+scr_local_launch)

        scr_wd_slope_0(ll_slope_19,ll_slope_19+scr_local_angles,ll_slope_19+scr_local_height,ll_slope_19+scr_local_s_type,ll_slope_19+scr_local_launch)
        scr_wd_slope_1(ll_slope_17,ll_slope_17+scr_local_angles,ll_slope_17+scr_local_height,ll_slope_17+scr_local_s_type,ll_slope_17+scr_local_launch)
        scr_wd_slope_2(ll_slope_16,ll_slope_16+scr_local_angles,ll_slope_16+scr_local_height,ll_slope_16+scr_local_s_type,ll_slope_16+scr_local_launch)
        scr_wd_slope_3(ll_slope_18,ll_slope_18+scr_local_angles,ll_slope_18+scr_local_height,ll_slope_18+scr_local_s_type,ll_slope_18+scr_local_launch)

        scr_wd_slope_8(ll_slope_23,ll_slope_23+scr_local_angles,ll_slope_23+scr_local_height,ll_slope_23+scr_local_s_type,ll_slope_23+scr_local_launch)
        scr_wd_slope_9(ll_slope_21,ll_slope_21+scr_local_angles,ll_slope_21+scr_local_height,ll_slope_21+scr_local_s_type,ll_slope_21+scr_local_launch)
        scr_wd_slope_10(ll_slope_20,ll_slope_20+scr_local_angles,ll_slope_20+scr_local_height,ll_slope_20+scr_local_s_type,ll_slope_20+scr_local_launch)
        scr_wd_slope_11(ll_slope_22,ll_slope_22+scr_local_angles,ll_slope_22+scr_local_height,ll_slope_22+scr_local_s_type,ll_slope_22+scr_local_launch)

        //City
        scr_wd_slope_20(wd_slope_20,wd_slope_20+scr_local_angles,wd_slope_20+scr_local_height,wd_slope_20+scr_local_s_type,wd_slope_20+scr_local_launch)
        scr_wd_slope_21(wd_slope_21,wd_slope_21+scr_local_angles,wd_slope_21+scr_local_height,wd_slope_21+scr_local_s_type,wd_slope_21+scr_local_launch)
        scr_wd_slope_22(wd_slope_22,wd_slope_22+scr_local_angles,wd_slope_22+scr_local_height,wd_slope_22+scr_local_s_type,wd_slope_22+scr_local_launch)
        scr_wd_slope_23(wd_slope_23,wd_slope_23+scr_local_angles,wd_slope_23+scr_local_height,wd_slope_23+scr_local_s_type,wd_slope_23+scr_local_launch)

        //Sewers Slopes
        scr_ll_slope_0(cs_slope_0,cs_slope_0+scr_local_angles,cs_slope_0+scr_local_height,cs_slope_0+scr_local_s_type,cs_slope_0+scr_local_launch)
        scr_ll_slope_1(cs_slope_1,cs_slope_1+scr_local_angles,cs_slope_1+scr_local_height,cs_slope_1+scr_local_s_type,cs_slope_1+scr_local_launch)
        scr_ll_slope_2(cs_slope_2,cs_slope_2+scr_local_angles,cs_slope_2+scr_local_height,cs_slope_2+scr_local_s_type,cs_slope_2+scr_local_launch)
        scr_ll_slope_3(cs_slope_3,cs_slope_3+scr_local_angles,cs_slope_3+scr_local_height,cs_slope_3+scr_local_s_type,cs_slope_3+scr_local_launch)
        scr_ll_slope_0(cs_slope_alt_0,cs_slope_alt_0+scr_local_angles,cs_slope_alt_0+scr_local_height,cs_slope_alt_0+scr_local_s_type,cs_slope_alt_0+scr_local_launch)
        scr_ll_slope_1(cs_slope_alt_1,cs_slope_alt_1+scr_local_angles,cs_slope_alt_1+scr_local_height,cs_slope_alt_1+scr_local_s_type,cs_slope_alt_1+scr_local_launch)
        scr_ll_slope_2(cs_slope_alt_2,cs_slope_alt_2+scr_local_angles,cs_slope_alt_2+scr_local_height,cs_slope_alt_2+scr_local_s_type,cs_slope_alt_2+scr_local_launch)
        scr_ll_slope_1(mnt_slope_snow_1,mnt_slope_snow_1+scr_local_angles,mnt_slope_snow_1+scr_local_height,mnt_slope_snow_1+scr_local_s_type,mnt_slope_snow_1+scr_local_launch)
        scr_ll_slope_2(mnt_slope_snow_2,mnt_slope_snow_2+scr_local_angles,mnt_slope_snow_2+scr_local_height,mnt_slope_snow_2+scr_local_s_type,mnt_slope_snow_2+scr_local_launch)
        scr_ll_slope_3(mnt_slope_snow_0,mnt_slope_snow_0+scr_local_angles,mnt_slope_snow_0+scr_local_height,mnt_slope_snow_0+scr_local_s_type,mnt_slope_snow_0+scr_local_launch)
        scr_ll_slope_1(mnt_slope_grass_1,mnt_slope_grass_1+scr_local_angles,mnt_slope_grass_1+scr_local_height,mnt_slope_grass_1+scr_local_s_type,mnt_slope_grass_1+scr_local_launch)
        scr_ll_slope_2(mnt_slope_grass_2,mnt_slope_grass_2+scr_local_angles,mnt_slope_grass_2+scr_local_height,mnt_slope_grass_2+scr_local_s_type,mnt_slope_grass_2+scr_local_launch)
        scr_ll_slope_3(mnt_slope_grass_0,mnt_slope_grass_0+scr_local_angles,mnt_slope_grass_0+scr_local_height,mnt_slope_grass_0+scr_local_s_type,mnt_slope_grass_0+scr_local_launch)

        //Sewers Ramps
        scr_mu_ramp_6(cs_ramp_6,cs_ramp_6+scr_local_angles,cs_ramp_6+scr_local_height,cs_ramp_6+scr_local_s_type,cs_ramp_6+scr_local_launch)
        scr_mu_ramp_7(cs_ramp_7,cs_ramp_7+scr_local_angles,cs_ramp_7+scr_local_height,cs_ramp_7+scr_local_s_type,cs_ramp_7+scr_local_launch)
        scr_mu_ramp_8(cs_ramp_8,cs_ramp_8+scr_local_angles,cs_ramp_8+scr_local_height,cs_ramp_8+scr_local_s_type,cs_ramp_8+scr_local_launch)
        scr_mu_ramp_9(cs_ramp_9,cs_ramp_9+scr_local_angles,cs_ramp_9+scr_local_height,cs_ramp_9+scr_local_s_type,cs_ramp_9+scr_local_launch)
        scr_mu_ramp_18(cs_ramp_18,cs_ramp_18+scr_local_angles,cs_ramp_18+scr_local_height,cs_ramp_18+scr_local_s_type,cs_ramp_18+scr_local_launch)
        scr_mu_ramp_19(cs_ramp_19,cs_ramp_19+scr_local_angles,cs_ramp_19+scr_local_height,cs_ramp_19+scr_local_s_type,cs_ramp_19+scr_local_launch)
        scr_mu_ramp_20(cs_ramp_20,cs_ramp_20+scr_local_angles,cs_ramp_20+scr_local_height,cs_ramp_20+scr_local_s_type,cs_ramp_20+scr_local_launch)
        scr_mu_ramp_21(cs_ramp_21,cs_ramp_21+scr_local_angles,cs_ramp_21+scr_local_height,cs_ramp_21+scr_local_s_type,cs_ramp_21+scr_local_launch)

        scr_ll_slope_1(rg_rail_sloped_1,rg_rail_sloped_1+scr_local_angles,rg_rail_sloped_1+scr_local_height,rg_rail_sloped_1+scr_local_s_type,rg_rail_sloped_1+scr_local_launch)
        scr_ll_slope_2(rg_rail_sloped_2,rg_rail_sloped_2+scr_local_angles,rg_rail_sloped_2+scr_local_height,rg_rail_sloped_2+scr_local_s_type,rg_rail_sloped_2+scr_local_launch)

        scr_mu_slope_2(rg_rail_slope_2,rg_rail_slope_2+scr_local_angles,rg_rail_slope_2+scr_local_height,rg_rail_slope_2+scr_local_s_type,rg_rail_slope_2+scr_local_launch)
        scr_mu_slope_3(rg_rail_slope_3,rg_rail_slope_3+scr_local_angles,rg_rail_slope_3+scr_local_height,rg_rail_slope_3+scr_local_s_type,rg_rail_slope_3+scr_local_launch)
        scr_mu_slope_4(rg_rail_slope_4,rg_rail_slope_4+scr_local_angles,rg_rail_slope_4+scr_local_height,rg_rail_slope_4+scr_local_s_type,rg_rail_slope_4+scr_local_launch)
        scr_mu_slope_5(rg_rail_slope_5,rg_rail_slope_5+scr_local_angles,rg_rail_slope_5+scr_local_height,rg_rail_slope_5+scr_local_s_type,rg_rail_slope_5+scr_local_launch)
        scr_mu_slope_6(rg_rail_slope_6,rg_rail_slope_6+scr_local_angles,rg_rail_slope_6+scr_local_height,rg_rail_slope_6+scr_local_s_type,rg_rail_slope_6+scr_local_launch)
        scr_mu_slope_7(rg_rail_slope_7,rg_rail_slope_7+scr_local_angles,rg_rail_slope_7+scr_local_height,rg_rail_slope_7+scr_local_s_type,rg_rail_slope_7+scr_local_launch)
        scr_mu_slope_8(rg_rail_slope_8,rg_rail_slope_8+scr_local_angles,rg_rail_slope_8+scr_local_height,rg_rail_slope_8+scr_local_s_type,rg_rail_slope_8+scr_local_launch)
        scr_mu_slope_9(rg_rail_slope_9,rg_rail_slope_9+scr_local_angles,rg_rail_slope_9+scr_local_height,rg_rail_slope_9+scr_local_s_type,rg_rail_slope_9+scr_local_launch)
        scr_mu_ramp_4(rg_rail_ramp_4,rg_rail_ramp_4+scr_local_angles,rg_rail_ramp_4+scr_local_height,rg_rail_ramp_4+scr_local_s_type,rg_rail_ramp_4+scr_local_launch)
        scr_mu_ramp_5(rg_rail_ramp_5,rg_rail_ramp_5+scr_local_angles,rg_rail_ramp_5+scr_local_height,rg_rail_ramp_5+scr_local_s_type,rg_rail_ramp_5+scr_local_launch)
        scr_mu_ramp_16(rg_rail_ramp_16,rg_rail_ramp_16+scr_local_angles,rg_rail_ramp_16+scr_local_height,rg_rail_ramp_16+scr_local_s_type,rg_rail_ramp_16+scr_local_launch)
        scr_mu_ramp_17(rg_rail_ramp_17,rg_rail_ramp_17+scr_local_angles,rg_rail_ramp_17+scr_local_height,rg_rail_ramp_17+scr_local_s_type,rg_rail_ramp_17+scr_local_launch)

        scr_mu_slope_2(cs_donut_2,cs_donut_2+scr_local_angles,cs_donut_2+scr_local_height,cs_donut_2+scr_local_s_type,cs_donut_2+scr_local_launch)
        scr_mu_slope_3(cs_donut_3,cs_donut_3+scr_local_angles,cs_donut_3+scr_local_height,cs_donut_3+scr_local_s_type,cs_donut_3+scr_local_launch)
        scr_mu_slope_4(cs_donut_4,cs_donut_4+scr_local_angles,cs_donut_4+scr_local_height,cs_donut_4+scr_local_s_type,cs_donut_4+scr_local_launch)
        scr_mu_slope_5(cs_donut_5,cs_donut_5+scr_local_angles,cs_donut_5+scr_local_height,cs_donut_5+scr_local_s_type,cs_donut_5+scr_local_launch)
        scr_cs_donut_6(cs_donut_6,cs_donut_6+scr_local_angles,cs_donut_6+scr_local_height,cs_donut_6+scr_local_s_type,cs_donut_6+scr_local_launch)
        scr_cs_donut_7(cs_donut_7,cs_donut_7+scr_local_angles,cs_donut_7+scr_local_height,cs_donut_7+scr_local_s_type,cs_donut_7+scr_local_launch)
        scr_cs_donut_8(cs_donut_8,cs_donut_8+scr_local_angles,cs_donut_8+scr_local_height,cs_donut_8+scr_local_s_type,cs_donut_8+scr_local_launch)
        scr_cs_donut_9(cs_donut_9,cs_donut_9+scr_local_angles,cs_donut_9+scr_local_height,cs_donut_9+scr_local_s_type,cs_donut_9+scr_local_launch)

        scr_mu_slope_2(wd_donut_2,wd_donut_2+scr_local_angles,wd_donut_2+scr_local_height,wd_donut_2+scr_local_s_type,wd_donut_2+scr_local_launch)
        scr_mu_slope_3(wd_donut_3,wd_donut_3+scr_local_angles,wd_donut_3+scr_local_height,wd_donut_3+scr_local_s_type,wd_donut_3+scr_local_launch)
        scr_mu_slope_4(wd_donut_4,wd_donut_4+scr_local_angles,wd_donut_4+scr_local_height,wd_donut_4+scr_local_s_type,wd_donut_4+scr_local_launch)
        scr_mu_slope_5(wd_donut_5,wd_donut_5+scr_local_angles,wd_donut_5+scr_local_height,wd_donut_5+scr_local_s_type,wd_donut_5+scr_local_launch)
        scr_cs_donut_6(wd_donut_6,wd_donut_6+scr_local_angles,wd_donut_6+scr_local_height,wd_donut_6+scr_local_s_type,wd_donut_6+scr_local_launch)
        scr_cs_donut_7(wd_donut_7,wd_donut_7+scr_local_angles,wd_donut_7+scr_local_height,wd_donut_7+scr_local_s_type,wd_donut_7+scr_local_launch)
        scr_cs_donut_8(wd_donut_8,wd_donut_8+scr_local_angles,wd_donut_8+scr_local_height,wd_donut_8+scr_local_s_type,wd_donut_8+scr_local_launch)
        scr_cs_donut_9(wd_donut_9,wd_donut_9+scr_local_angles,wd_donut_9+scr_local_height,wd_donut_9+scr_local_s_type,wd_donut_9+scr_local_launch)

        scr_mu_slope_2(bb_donut_2,bb_donut_2+scr_local_angles,bb_donut_2+scr_local_height,bb_donut_2+scr_local_s_type,bb_donut_2+scr_local_launch)
        scr_mu_slope_3(bb_donut_3,bb_donut_3+scr_local_angles,bb_donut_3+scr_local_height,bb_donut_3+scr_local_s_type,bb_donut_3+scr_local_launch)
        scr_mu_slope_4(bb_donut_4,bb_donut_4+scr_local_angles,bb_donut_4+scr_local_height,bb_donut_4+scr_local_s_type,bb_donut_4+scr_local_launch)
        scr_mu_slope_5(bb_donut_5,bb_donut_5+scr_local_angles,bb_donut_5+scr_local_height,bb_donut_5+scr_local_s_type,bb_donut_5+scr_local_launch)
        scr_bb_donut_6(bb_donut_6,bb_donut_6+scr_local_angles,bb_donut_6+scr_local_height,bb_donut_6+scr_local_s_type,bb_donut_6+scr_local_launch)
        scr_bb_donut_7(bb_donut_7,bb_donut_7+scr_local_angles,bb_donut_7+scr_local_height,bb_donut_7+scr_local_s_type,bb_donut_7+scr_local_launch)
        scr_bb_donut_8(bb_donut_8,bb_donut_8+scr_local_angles,bb_donut_8+scr_local_height,bb_donut_8+scr_local_s_type,bb_donut_8+scr_local_launch)
        scr_bb_donut_9(bb_donut_9,bb_donut_9+scr_local_angles,bb_donut_9+scr_local_height,bb_donut_9+scr_local_s_type,bb_donut_9+scr_local_launch)

        scr_mu_slope_2(bb_donut_2_alt,bb_donut_2_alt+scr_local_angles,bb_donut_2_alt+scr_local_height,bb_donut_2_alt+scr_local_s_type,bb_donut_2_alt+scr_local_launch)
        scr_mu_slope_3(bb_donut_3_alt,bb_donut_3_alt+scr_local_angles,bb_donut_3_alt+scr_local_height,bb_donut_3_alt+scr_local_s_type,bb_donut_3_alt+scr_local_launch)
        scr_mu_slope_4(bb_donut_4_alt,bb_donut_4_alt+scr_local_angles,bb_donut_4_alt+scr_local_height,bb_donut_4_alt+scr_local_s_type,bb_donut_4_alt+scr_local_launch)
        scr_mu_slope_5(bb_donut_5_alt,bb_donut_5_alt+scr_local_angles,bb_donut_5_alt+scr_local_height,bb_donut_5_alt+scr_local_s_type,bb_donut_5_alt+scr_local_launch)
        scr_bb_donut_6(bb_donut_6_alt,bb_donut_6_alt+scr_local_angles,bb_donut_6_alt+scr_local_height,bb_donut_6_alt+scr_local_s_type,bb_donut_6_alt+scr_local_launch)
        scr_bb_donut_7(bb_donut_7_alt,bb_donut_7_alt+scr_local_angles,bb_donut_7_alt+scr_local_height,bb_donut_7_alt+scr_local_s_type,bb_donut_7_alt+scr_local_launch)
        scr_bb_donut_8(bb_donut_8_alt,bb_donut_8_alt+scr_local_angles,bb_donut_8_alt+scr_local_height,bb_donut_8_alt+scr_local_s_type,bb_donut_8_alt+scr_local_launch)
        scr_bb_donut_9(bb_donut_9_alt,bb_donut_9_alt+scr_local_angles,bb_donut_9_alt+scr_local_height,bb_donut_9_alt+scr_local_s_type,bb_donut_9_alt+scr_local_launch)

        scr_bb_fof_1(bb_fof_1,bb_fof_1+scr_local_angles,bb_fof_1+scr_local_height,bb_fof_1+scr_local_s_type,bb_fof_1+scr_local_launch)
        scr_bb_fof_1(bb_fof_2,bb_fof_2+scr_local_angles,bb_fof_2+scr_local_height,bb_fof_2+scr_local_s_type,bb_fof_2+scr_local_launch)

        scr_cs_loop_0(cs_loop_0,cs_loop_0+scr_local_angles,cs_loop_0+scr_local_height,cs_loop_0+scr_local_s_type,cs_loop_0+scr_local_launch)
        scr_cs_loop_1(cs_loop_1,cs_loop_1+scr_local_angles,cs_loop_1+scr_local_height,cs_loop_1+scr_local_s_type,cs_loop_1+scr_local_launch)
        scr_cs_loop_2(cs_loop_2,cs_loop_2+scr_local_angles,cs_loop_2+scr_local_height,cs_loop_2+scr_local_s_type,cs_loop_2+scr_local_launch)
        scr_cs_loop_3(cs_loop_3,cs_loop_3+scr_local_angles,cs_loop_3+scr_local_height,cs_loop_3+scr_local_s_type,cs_loop_3+scr_local_launch)
        scr_wd_slope_8(cs_loop_8,cs_loop_8+scr_local_angles,cs_loop_8+scr_local_height,cs_loop_8+scr_local_s_type,cs_loop_8+scr_local_launch)
        scr_wd_slope_9(cs_loop_9,cs_loop_9+scr_local_angles,cs_loop_9+scr_local_height,cs_loop_9+scr_local_s_type,cs_loop_9+scr_local_launch)
        scr_wd_slope_10(cs_loop_10,cs_loop_10+scr_local_angles,cs_loop_10+scr_local_height,cs_loop_10+scr_local_s_type,cs_loop_10+scr_local_launch)
        scr_wd_slope_11(cs_loop_11,cs_loop_11+scr_local_angles,cs_loop_11+scr_local_height,cs_loop_11+scr_local_s_type,cs_loop_11+scr_local_launch)

        //Lagoon Variants
        scr_wd_slope_20(ll_slope_10,ll_slope_10+scr_local_angles,ll_slope_10+scr_local_height,ll_slope_10+scr_local_s_type,ll_slope_10+scr_local_launch)
        scr_wd_slope_21(ll_slope_11,ll_slope_11+scr_local_angles,ll_slope_11+scr_local_height,ll_slope_11+scr_local_s_type,ll_slope_11+scr_local_launch)
        scr_wd_slope_22(ll_slope_12,ll_slope_12+scr_local_angles,ll_slope_12+scr_local_height,ll_slope_12+scr_local_s_type,ll_slope_12+scr_local_launch)
        scr_wd_slope_23(ll_slope_13,ll_slope_13+scr_local_angles,ll_slope_13+scr_local_height,ll_slope_13+scr_local_s_type,ll_slope_13+scr_local_launch)
        scr_wd_slope_23(ll_slope_14,ll_slope_14+scr_local_angles,ll_slope_14+scr_local_height,ll_slope_14+scr_local_s_type,ll_slope_14+scr_local_launch)
        scr_wd_slope_21(ll_slope_15,ll_slope_15+scr_local_angles,ll_slope_15+scr_local_height,ll_slope_15+scr_local_s_type,ll_slope_15+scr_local_launch)
        scr_ll_slope_30(ll_slope_30,ll_slope_30+scr_local_angles,ll_slope_30+scr_local_height,ll_slope_30+scr_local_s_type,ll_slope_30+scr_local_launch)
        scr_ll_slope_31(ll_slope_31,ll_slope_31+scr_local_angles,ll_slope_31+scr_local_height,ll_slope_31+scr_local_s_type,ll_slope_31+scr_local_launch)
        scr_ll_slope_30(ll_slope_32,ll_slope_32+scr_local_angles,ll_slope_32+scr_local_height,ll_slope_32+scr_local_s_type,ll_slope_32+scr_local_launch)
        scr_ll_slope_33(ll_slope_33,ll_slope_33+scr_local_angles,ll_slope_33+scr_local_height,ll_slope_33+scr_local_s_type,ll_slope_33+scr_local_launch)
        scr_ll_slope_34(ll_slope_34,ll_slope_34+scr_local_angles,ll_slope_34+scr_local_height,ll_slope_34+scr_local_s_type,ll_slope_34+scr_local_launch)
        scr_ll_slope_35(ll_slope_35,ll_slope_35+scr_local_angles,ll_slope_35+scr_local_height,ll_slope_35+scr_local_s_type,ll_slope_35+scr_local_launch)
        scr_ll_slope_36(ll_slope_36,ll_slope_36+scr_local_angles,ll_slope_36+scr_local_height,ll_slope_36+scr_local_s_type,ll_slope_36+scr_local_launch)
        scr_ll_slope_37(ll_slope_37,ll_slope_37+scr_local_angles,ll_slope_37+scr_local_height,ll_slope_37+scr_local_s_type,ll_slope_37+scr_local_launch)
        scr_ll_slope_38(ll_slope_38,ll_slope_38+scr_local_angles,ll_slope_38+scr_local_height,ll_slope_38+scr_local_s_type,ll_slope_38+scr_local_launch)
        scr_ll_slope_37(rg_rail_4,rg_rail_4+scr_local_angles,rg_rail_4+scr_local_height,rg_rail_4+scr_local_s_type,rg_rail_4+scr_local_launch)
        scr_ll_slope_38(rg_rail_5,rg_rail_5+scr_local_angles,rg_rail_5+scr_local_height,rg_rail_5+scr_local_s_type,rg_rail_5+scr_local_launch)
        scr_ll_slope_37(rg_rail_6,rg_rail_6+scr_local_angles,rg_rail_6+scr_local_height,rg_rail_6+scr_local_s_type,rg_rail_6+scr_local_launch)
        scr_ll_slope_38(rg_rail_7,rg_rail_7+scr_local_angles,rg_rail_7+scr_local_height,rg_rail_7+scr_local_s_type,rg_rail_7+scr_local_launch)
        scr_ll_slope_37(rg_rail_13,rg_rail_13+scr_local_angles,rg_rail_13+scr_local_height,rg_rail_13+scr_local_s_type,rg_rail_13+scr_local_launch)
        scr_ll_slope_38(rg_rail_14,rg_rail_14+scr_local_angles,rg_rail_14+scr_local_height,rg_rail_14+scr_local_s_type,rg_rail_14+scr_local_launch)
        scr_ll_slope_37(rg_rail_16,rg_rail_16+scr_local_angles,rg_rail_16+scr_local_height,rg_rail_16+scr_local_s_type,rg_rail_16+scr_local_launch)
        scr_ll_slope_38(rg_rail_17,rg_rail_17+scr_local_angles,rg_rail_17+scr_local_height,rg_rail_17+scr_local_s_type,rg_rail_17+scr_local_launch)
        scr_ll_slope_37(ll_slope_43,ll_slope_43+scr_local_angles,ll_slope_43+scr_local_height,ll_slope_43+scr_local_s_type,ll_slope_43+scr_local_launch)
        scr_ll_slope_38(ll_slope_44,ll_slope_44+scr_local_angles,ll_slope_44+scr_local_height,ll_slope_44+scr_local_s_type,ll_slope_44+scr_local_launch)
        scr_mu_ramp_8 (ll_slope_39,ll_slope_39+scr_local_angles,ll_slope_39+scr_local_height,ll_slope_39+scr_local_s_type,ll_slope_39+scr_local_launch)
        scr_mu_ramp_9 (ll_slope_40,ll_slope_40+scr_local_angles,ll_slope_40+scr_local_height,ll_slope_40+scr_local_s_type,ll_slope_40+scr_local_launch)
        scr_mu_ramp_20(ll_slope_41,ll_slope_41+scr_local_angles,ll_slope_41+scr_local_height,ll_slope_41+scr_local_s_type,ll_slope_41+scr_local_launch)
        scr_mu_ramp_21(ll_slope_42,ll_slope_42+scr_local_angles,ll_slope_42+scr_local_height,ll_slope_42+scr_local_s_type,ll_slope_42+scr_local_launch)
        scr_mu_slope_14(ll_loop_2,ll_loop_2+scr_local_angles,ll_loop_2+scr_local_height,ll_loop_2+scr_local_s_type,ll_loop_2+scr_local_launch)
        scr_mu_slope_15(ll_loop_3,ll_loop_3+scr_local_angles,ll_loop_3+scr_local_height,ll_loop_3+scr_local_s_type,ll_loop_3+scr_local_launch)
        scr_mu_slope_16(ll_loop_4,ll_loop_4+scr_local_angles,ll_loop_4+scr_local_height,ll_loop_4+scr_local_s_type,ll_loop_4+scr_local_launch)
        scr_mu_slope_17(ll_loop_5,ll_loop_5+scr_local_angles,ll_loop_5+scr_local_height,ll_loop_5+scr_local_s_type,ll_loop_5+scr_local_launch)
        scr_mu_slope_6(ll_loop_6,ll_loop_6+scr_local_angles,ll_loop_6+scr_local_height,ll_loop_6+scr_local_s_type,ll_loop_6+scr_local_launch)
        scr_mu_slope_7(ll_loop_7,ll_loop_7+scr_local_angles,ll_loop_7+scr_local_height,ll_loop_7+scr_local_s_type,ll_loop_7+scr_local_launch)
        scr_mu_slope_8(ll_loop_8,ll_loop_8+scr_local_angles,ll_loop_8+scr_local_height,ll_loop_8+scr_local_s_type,ll_loop_8+scr_local_launch)
        scr_mu_slope_9(ll_loop_9,ll_loop_9+scr_local_angles,ll_loop_9+scr_local_height,ll_loop_9+scr_local_s_type,ll_loop_9+scr_local_launch)
        scr_cs_donut_6(ll_donut_6,ll_donut_6+scr_local_angles,ll_donut_6+scr_local_height,ll_donut_6+scr_local_s_type,ll_donut_6+scr_local_launch)
        scr_cs_donut_7(ll_donut_7,ll_donut_7+scr_local_angles,ll_donut_7+scr_local_height,ll_donut_7+scr_local_s_type,ll_donut_7+scr_local_launch)
        scr_cs_donut_8(ll_donut_8,ll_donut_8+scr_local_angles,ll_donut_8+scr_local_height,ll_donut_8+scr_local_s_type,ll_donut_8+scr_local_launch)
        scr_cs_donut_9(ll_donut_9,ll_donut_9+scr_local_angles,ll_donut_9+scr_local_height,ll_donut_9+scr_local_s_type,ll_donut_9+scr_local_launch)
        scr_mu_slope_2(ll_donut_2,ll_donut_2+scr_local_angles,ll_donut_2+scr_local_height,ll_donut_2+scr_local_s_type,ll_donut_2+scr_local_launch)
        scr_mu_slope_3(ll_donut_3,ll_donut_3+scr_local_angles,ll_donut_3+scr_local_height,ll_donut_3+scr_local_s_type,ll_donut_3+scr_local_launch)
        scr_mu_slope_4(ll_donut_4,ll_donut_4+scr_local_angles,ll_donut_4+scr_local_height,ll_donut_4+scr_local_s_type,ll_donut_4+scr_local_launch)
        scr_mu_slope_5(ll_donut_5,ll_donut_5+scr_local_angles,ll_donut_5+scr_local_height,ll_donut_5+scr_local_s_type,ll_donut_5+scr_local_launch)

        scr_mu_fof_0   (wd_fof_0,wd_fof_0+scr_local_angles,wd_fof_0+scr_local_height,wd_fof_0+scr_local_s_type,wd_fof_0+scr_local_launch)
        scr_mu_fof_0   (ll_fof_0,ll_fof_0+scr_local_angles,ll_fof_0+scr_local_height,ll_fof_0+scr_local_s_type,ll_fof_0+scr_local_launch)
        scr_mnt_fof_2  (ll_fof_1,ll_fof_1+scr_local_angles,ll_fof_1+scr_local_height,ll_fof_1+scr_local_s_type,ll_fof_1+scr_local_launch)
        scr_mnt_fof_3  (ll_fof_2,ll_fof_2+scr_local_angles,ll_fof_2+scr_local_height,ll_fof_2+scr_local_s_type,ll_fof_2+scr_local_launch)
        scr_mu_fof_0   (ll_fof_3,ll_fof_3+scr_local_angles,ll_fof_3+scr_local_height,ll_fof_3+scr_local_s_type,ll_fof_3+scr_local_launch)
        scr_mu_fof_0   (ll_fof_4,ll_fof_4+scr_local_angles,ll_fof_4+scr_local_height,ll_fof_4+scr_local_s_type,ll_fof_4+scr_local_launch)
        scr_mnt_fof_0  (wd_fof_1,wd_fof_1+scr_local_angles,wd_fof_1+scr_local_height,wd_fof_1+scr_local_s_type,wd_fof_1+scr_local_launch)
        scr_mnt_fof_0  (mnt_fof_hammer,mnt_fof_hammer+scr_local_angles,mnt_fof_hammer+scr_local_height,mnt_fof_hammer+scr_local_s_type,mnt_fof_hammer+scr_local_launch)
        scr_wd_fof_2   (wd_fof_2,wd_fof_2+scr_local_angles,wd_fof_2+scr_local_height,wd_fof_2+scr_local_s_type,wd_fof_2+scr_local_launch)
        scr_wd_fof_2   (wd_fof_3,wd_fof_3+scr_local_angles,wd_fof_3+scr_local_height,wd_fof_3+scr_local_s_type,wd_fof_3+scr_local_launch)
        scr_wd_fof_2   (wd_fof_3,wd_fof_3+scr_local_angles,wd_fof_3+scr_local_height,wd_fof_3+scr_local_s_type,wd_fof_3+scr_local_launch)
        scr_wd_fof_2   (wd_fof_4,wd_fof_4+scr_local_angles,wd_fof_4+scr_local_height,wd_fof_4+scr_local_s_type,wd_fof_4+scr_local_launch)
        scr_mu_fof_0   (rg_rail_0,rg_rail_0+scr_local_angles,rg_rail_0+scr_local_height,rg_rail_0+scr_local_s_type,rg_rail_0+scr_local_launch)
        scr_mu_fof_0   (rg_rail_1,rg_rail_1+scr_local_angles,rg_rail_1+scr_local_height,rg_rail_1+scr_local_s_type,rg_rail_1+scr_local_launch)
        scr_mu_fof_0   (rg_rail_12,rg_rail_12+scr_local_angles,rg_rail_12+scr_local_height,rg_rail_12+scr_local_s_type,rg_rail_12+scr_local_launch)
        scr_mu_fof_0   (rg_rail_15,rg_rail_15+scr_local_angles,rg_rail_15+scr_local_height,rg_rail_15+scr_local_s_type,rg_rail_15+scr_local_launch)

        scr_mu_fof_0   (ll_slope_26,ll_slope_26+scr_local_angles,ll_slope_26+scr_local_height,ll_slope_26+scr_local_s_type,ll_slope_26+scr_local_launch)
        scr_mnt_fof_2  (ll_slope_25,ll_slope_25+scr_local_angles,ll_slope_25+scr_local_height,ll_slope_25+scr_local_s_type,ll_slope_25+scr_local_launch)
        scr_mnt_fof_3  (ll_slope_24,ll_slope_24+scr_local_angles,ll_slope_24+scr_local_height,ll_slope_24+scr_local_s_type,ll_slope_24+scr_local_launch)
        scr_mu_fof_0   (ll_slope_27,ll_slope_27+scr_local_angles,ll_slope_27+scr_local_height,ll_slope_27+scr_local_s_type,ll_slope_27+scr_local_launch)
        scr_mu_fof_0   (ll_slope_28,ll_slope_28+scr_local_angles,ll_slope_28+scr_local_height,ll_slope_28+scr_local_s_type,ll_slope_28+scr_local_launch)

        //Mountain
        scr_mu_ramp_0(mnt_slope_11,mnt_slope_11+scr_local_angles,mnt_slope_11+scr_local_height,mnt_slope_11+scr_local_s_type,mnt_slope_11+scr_local_launch)
        scr_mu_ramp_1(mnt_slope_9,mnt_slope_9+scr_local_angles,mnt_slope_9+scr_local_height,mnt_slope_9+scr_local_s_type,mnt_slope_9+scr_local_launch)
        scr_mu_ramp_2(mnt_slope_8,mnt_slope_8+scr_local_angles,mnt_slope_8+scr_local_height,mnt_slope_8+scr_local_s_type,mnt_slope_8+scr_local_launch)
        scr_mu_ramp_3(mnt_slope_10,mnt_slope_10+scr_local_angles,mnt_slope_10+scr_local_height,mnt_slope_10+scr_local_s_type,mnt_slope_10+scr_local_launch)
        scr_mu_ramp_8(mnt_ramp_0,mnt_ramp_0+scr_local_angles,mnt_ramp_0+scr_local_height,mnt_ramp_0+scr_local_s_type,mnt_ramp_0+scr_local_launch)
        scr_mu_ramp_9(mnt_ramp_1,mnt_ramp_1+scr_local_angles,mnt_ramp_1+scr_local_height,mnt_ramp_1+scr_local_s_type,mnt_ramp_1+scr_local_launch)
        scr_mu_ramp_8(mnt_ramp_4,mnt_ramp_4+scr_local_angles,mnt_ramp_4+scr_local_height,mnt_ramp_4+scr_local_s_type,mnt_ramp_4+scr_local_launch)
        scr_mu_ramp_9(mnt_ramp_5,mnt_ramp_5+scr_local_angles,mnt_ramp_5+scr_local_height,mnt_ramp_5+scr_local_s_type,mnt_ramp_5+scr_local_launch)
        scr_mu_ramp_20(mnt_ramp_2,mnt_ramp_2+scr_local_angles,mnt_ramp_2+scr_local_height,mnt_ramp_2+scr_local_s_type,mnt_ramp_2+scr_local_launch)
        scr_mu_ramp_21(mnt_ramp_3,mnt_ramp_3+scr_local_angles,mnt_ramp_3+scr_local_height,mnt_ramp_3+scr_local_s_type,mnt_ramp_3+scr_local_launch)
        scr_mu_ramp_20(mnt_ramp_6,mnt_ramp_6+scr_local_angles,mnt_ramp_6+scr_local_height,mnt_ramp_6+scr_local_s_type,mnt_ramp_6+scr_local_launch)
        scr_mu_ramp_21(mnt_ramp_7,mnt_ramp_7+scr_local_angles,mnt_ramp_7+scr_local_height,mnt_ramp_7+scr_local_s_type,mnt_ramp_7+scr_local_launch)
        scr_mu_ramp_22(mnt_slope_15,mnt_slope_15+scr_local_angles,mnt_slope_15+scr_local_height,mnt_slope_15+scr_local_s_type,mnt_slope_15+scr_local_launch)
        scr_mu_ramp_23(mnt_slope_13,mnt_slope_13+scr_local_angles,mnt_slope_13+scr_local_height,mnt_slope_13+scr_local_s_type,mnt_slope_13+scr_local_launch)
        scr_mu_ramp_24(mnt_slope_12,mnt_slope_12+scr_local_angles,mnt_slope_12+scr_local_height,mnt_slope_12+scr_local_s_type,mnt_slope_12+scr_local_launch)
        scr_mu_ramp_25(mnt_slope_14,mnt_slope_14+scr_local_angles,mnt_slope_14+scr_local_height,mnt_slope_14+scr_local_s_type,mnt_slope_14+scr_local_launch)
        scr_mu_slope_6(mnt_slope_0,mnt_slope_0+scr_local_angles,mnt_slope_0+scr_local_height,mnt_slope_0+scr_local_s_type,mnt_slope_0+scr_local_launch)
        scr_mu_slope_7(mnt_slope_1,mnt_slope_1+scr_local_angles,mnt_slope_1+scr_local_height,mnt_slope_1+scr_local_s_type,mnt_slope_1+scr_local_launch)
        scr_mu_slope_8(mnt_slope_2,mnt_slope_2+scr_local_angles,mnt_slope_2+scr_local_height,mnt_slope_2+scr_local_s_type,mnt_slope_2+scr_local_launch)
        scr_mu_slope_9(mnt_slope_3,mnt_slope_3+scr_local_angles,mnt_slope_3+scr_local_height,mnt_slope_3+scr_local_s_type,mnt_slope_3+scr_local_launch)
        scr_mu_slope_2(mnt_slope_4,mnt_slope_4+scr_local_angles,mnt_slope_4+scr_local_height,mnt_slope_4+scr_local_s_type,mnt_slope_4+scr_local_launch)
        scr_mu_slope_3(mnt_slope_5,mnt_slope_5+scr_local_angles,mnt_slope_5+scr_local_height,mnt_slope_5+scr_local_s_type,mnt_slope_5+scr_local_launch)
        scr_mu_slope_4(mnt_slope_6,mnt_slope_6+scr_local_angles,mnt_slope_6+scr_local_height,mnt_slope_6+scr_local_s_type,mnt_slope_6+scr_local_launch)
        scr_mu_slope_5(mnt_slope_7,mnt_slope_7+scr_local_angles,mnt_slope_7+scr_local_height,mnt_slope_7+scr_local_s_type,mnt_slope_7+scr_local_launch)
        scr_mu_slope_6(mnt_slope_16,mnt_slope_16+scr_local_angles,mnt_slope_16+scr_local_height,mnt_slope_16+scr_local_s_type,mnt_slope_16+scr_local_launch)
        scr_mu_slope_7(mnt_slope_17,mnt_slope_17+scr_local_angles,mnt_slope_17+scr_local_height,mnt_slope_17+scr_local_s_type,mnt_slope_17+scr_local_launch)
        scr_mu_slope_8(mnt_slope_18,mnt_slope_18+scr_local_angles,mnt_slope_18+scr_local_height,mnt_slope_18+scr_local_s_type,mnt_slope_18+scr_local_launch)
        scr_mu_slope_9(mnt_slope_19,mnt_slope_19+scr_local_angles,mnt_slope_19+scr_local_height,mnt_slope_19+scr_local_s_type,mnt_slope_19+scr_local_launch)
        scr_mu_slope_2(mnt_slope_20,mnt_slope_20+scr_local_angles,mnt_slope_20+scr_local_height,mnt_slope_20+scr_local_s_type,mnt_slope_20+scr_local_launch)
        scr_mu_slope_3(mnt_slope_21,mnt_slope_21+scr_local_angles,mnt_slope_21+scr_local_height,mnt_slope_21+scr_local_s_type,mnt_slope_21+scr_local_launch)
        scr_mu_slope_4(mnt_slope_22,mnt_slope_22+scr_local_angles,mnt_slope_22+scr_local_height,mnt_slope_22+scr_local_s_type,mnt_slope_22+scr_local_launch)
        scr_mu_slope_5(mnt_slope_23,mnt_slope_23+scr_local_angles,mnt_slope_23+scr_local_height,mnt_slope_23+scr_local_s_type,mnt_slope_23+scr_local_launch)
        scr_mu_slope_6(mnt_slope_24,mnt_slope_24+scr_local_angles,mnt_slope_24+scr_local_height,mnt_slope_24+scr_local_s_type,mnt_slope_24+scr_local_launch)
        scr_mu_slope_7(mnt_slope_25,mnt_slope_25+scr_local_angles,mnt_slope_25+scr_local_height,mnt_slope_25+scr_local_s_type,mnt_slope_25+scr_local_launch)
        scr_mu_slope_8(mnt_slope_26,mnt_slope_26+scr_local_angles,mnt_slope_26+scr_local_height,mnt_slope_26+scr_local_s_type,mnt_slope_26+scr_local_launch)
        scr_mu_slope_9(mnt_slope_27,mnt_slope_27+scr_local_angles,mnt_slope_27+scr_local_height,mnt_slope_27+scr_local_s_type,mnt_slope_27+scr_local_launch)
        scr_mu_slope_2(mnt_slope_28,mnt_slope_28+scr_local_angles,mnt_slope_28+scr_local_height,mnt_slope_28+scr_local_s_type,mnt_slope_28+scr_local_launch)
        scr_mu_slope_3(mnt_slope_29,mnt_slope_29+scr_local_angles,mnt_slope_29+scr_local_height,mnt_slope_29+scr_local_s_type,mnt_slope_29+scr_local_launch)
        scr_mu_slope_4(mnt_slope_30,mnt_slope_30+scr_local_angles,mnt_slope_30+scr_local_height,mnt_slope_30+scr_local_s_type,mnt_slope_30+scr_local_launch)
        scr_mu_slope_5(mnt_slope_31,mnt_slope_31+scr_local_angles,mnt_slope_31+scr_local_height,mnt_slope_31+scr_local_s_type,mnt_slope_31+scr_local_launch)
        scr_mu_slope_18(mnt_ramp_8,mnt_ramp_8+scr_local_angles,mnt_ramp_8+scr_local_height,mnt_ramp_8+scr_local_s_type,mnt_ramp_8+scr_local_launch)
        scr_mu_slope_19(mnt_ramp_9,mnt_ramp_9+scr_local_angles,mnt_ramp_9+scr_local_height,mnt_ramp_9+scr_local_s_type,mnt_ramp_9+scr_local_launch)
        scr_mu_slope_0(mnt_ramp_10,mnt_ramp_10+scr_local_angles,mnt_ramp_10+scr_local_height,mnt_ramp_10+scr_local_s_type,mnt_ramp_10+scr_local_launch)
        scr_mu_slope_1(mnt_ramp_11,mnt_ramp_11+scr_local_angles,mnt_ramp_11+scr_local_height,mnt_ramp_11+scr_local_s_type,mnt_ramp_11+scr_local_launch)
        scr_mnt_fof_0 (mnt_fof_0,mnt_fof_0+scr_local_angles,mnt_fof_0+scr_local_height,mnt_fof_0+scr_local_s_type,mnt_fof_0+scr_local_launch)
        scr_mnt_fof_0 (mnt_fof_1,mnt_fof_1+scr_local_angles,mnt_fof_1+scr_local_height,mnt_fof_1+scr_local_s_type,mnt_fof_1+scr_local_launch)
        scr_mnt_fof_2 (mnt_fof_2,mnt_fof_2+scr_local_angles,mnt_fof_2+scr_local_height,mnt_fof_2+scr_local_s_type,mnt_fof_2+scr_local_launch)
        scr_mnt_fof_3 (mnt_fof_3,mnt_fof_3+scr_local_angles,mnt_fof_3+scr_local_height,mnt_fof_3+scr_local_s_type,mnt_fof_3+scr_local_launch)
        scr_mnt_fof_2 (mnt_fof_4,mnt_fof_4+scr_local_angles,mnt_fof_4+scr_local_height,mnt_fof_4+scr_local_s_type,mnt_fof_4+scr_local_launch)
        scr_mnt_fof_2 (mnt_fof_7,mnt_fof_7+scr_local_angles,mnt_fof_7+scr_local_height,mnt_fof_7+scr_local_s_type,mnt_fof_7+scr_local_launch)
        scr_mu_ramp_8(mnt_ramp_12,mnt_ramp_12+scr_local_angles,mnt_ramp_12+scr_local_height,mnt_ramp_12+scr_local_s_type,mnt_ramp_12+scr_local_launch)
        scr_mu_ramp_9(mnt_ramp_13,mnt_ramp_13+scr_local_angles,mnt_ramp_13+scr_local_height,mnt_ramp_13+scr_local_s_type,mnt_ramp_13+scr_local_launch)
        scr_mu_ramp_20(mnt_ramp_14,mnt_ramp_14+scr_local_angles,mnt_ramp_14+scr_local_height,mnt_ramp_14+scr_local_s_type,mnt_ramp_14+scr_local_launch)
        scr_mu_ramp_21(mnt_ramp_15,mnt_ramp_15+scr_local_angles,mnt_ramp_15+scr_local_height,mnt_ramp_15+scr_local_s_type,mnt_ramp_15+scr_local_launch)
        scr_mu_ramp_8(mnt_ramp_22,mnt_ramp_22+scr_local_angles,mnt_ramp_22+scr_local_height,mnt_ramp_22+scr_local_s_type,mnt_ramp_22+scr_local_launch)
        scr_mu_ramp_9(mnt_ramp_23,mnt_ramp_23+scr_local_angles,mnt_ramp_23+scr_local_height,mnt_ramp_23+scr_local_s_type,mnt_ramp_23+scr_local_launch)
        scr_mu_ramp_20(mnt_ramp_24,mnt_ramp_24+scr_local_angles,mnt_ramp_24+scr_local_height,mnt_ramp_24+scr_local_s_type,mnt_ramp_24+scr_local_launch)
        scr_mu_ramp_21(mnt_ramp_25,mnt_ramp_25+scr_local_angles,mnt_ramp_25+scr_local_height,mnt_ramp_25+scr_local_s_type,mnt_ramp_25+scr_local_launch)
        //Lagoon
        scr_ll_slope_0_alt(ll_slope_0,ll_slope_0+scr_local_angles,ll_slope_0+scr_local_height,ll_slope_0+scr_local_s_type,ll_slope_0+scr_local_launch)
        scr_ll_slope_1_alt(ll_slope_1,ll_slope_1+scr_local_angles,ll_slope_1+scr_local_height,ll_slope_1+scr_local_s_type,ll_slope_1+scr_local_launch)
        scr_ll_slope_2_alt(ll_slope_2,ll_slope_2+scr_local_angles,ll_slope_2+scr_local_height,ll_slope_2+scr_local_s_type,ll_slope_2+scr_local_launch)
        scr_ll_slope_3(ll_slope_3,ll_slope_3+scr_local_angles,ll_slope_3+scr_local_height,ll_slope_3+scr_local_s_type,ll_slope_3+scr_local_launch)
        scr_ll_slope_47(ll_slope_47,ll_slope_47+scr_local_angles,ll_slope_47+scr_local_height,ll_slope_47+scr_local_s_type,ll_slope_47+scr_local_launch)
        scr_ll_slope_48(ll_slope_48,ll_slope_48+scr_local_angles,ll_slope_48+scr_local_height,ll_slope_48+scr_local_s_type,ll_slope_48+scr_local_launch)
        scr_mnt_fof_0  (ll_slope_24,ll_slope_24+scr_local_angles,ll_slope_24+scr_local_height,ll_slope_24+scr_local_s_type,ll_slope_24+scr_local_launch)
        scr_mnt_fof_2  (ll_slope_25,ll_slope_25+scr_local_angles,ll_slope_25+scr_local_height,ll_slope_25+scr_local_s_type,ll_slope_25+scr_local_launch)
        scr_mnt_fof_3  (ll_fof_2,ll_fof_2+scr_local_angles,ll_fof_2+scr_local_height,ll_fof_2+scr_local_s_type,ll_fof_2+scr_local_launch)
        scr_mnt_fof_2  (ll_fof_1,ll_fof_1+scr_local_angles,ll_fof_1+scr_local_height,ll_fof_1+scr_local_s_type,ll_fof_1+scr_local_launch)

        //Sapphire Jungle        
        scr_mu_slope_2(sj_slope_2,sj_slope_2+scr_local_angles,sj_slope_2+scr_local_height,sj_slope_2+scr_local_s_type,sj_slope_2+scr_local_launch)
        scr_mu_slope_3(sj_slope_3,sj_slope_3+scr_local_angles,sj_slope_3+scr_local_height,sj_slope_3+scr_local_s_type,sj_slope_3+scr_local_launch)
        scr_mu_slope_4(sj_slope_4,sj_slope_4+scr_local_angles,sj_slope_4+scr_local_height,sj_slope_4+scr_local_s_type,sj_slope_4+scr_local_launch)
        scr_mu_slope_5(sj_slope_5,sj_slope_5+scr_local_angles,sj_slope_5+scr_local_height,sj_slope_5+scr_local_s_type,sj_slope_5+scr_local_launch)
        scr_mu_slope_6(sj_slope_6,sj_slope_6+scr_local_angles,sj_slope_6+scr_local_height,sj_slope_6+scr_local_s_type,sj_slope_6+scr_local_launch)
        scr_mu_slope_7(sj_slope_7,sj_slope_7+scr_local_angles,sj_slope_7+scr_local_height,sj_slope_7+scr_local_s_type,sj_slope_7+scr_local_launch)
        scr_mu_slope_8(sj_slope_8,sj_slope_8+scr_local_angles,sj_slope_8+scr_local_height,sj_slope_8+scr_local_s_type,sj_slope_8+scr_local_launch)
        scr_mu_slope_9(sj_slope_9,sj_slope_9+scr_local_angles,sj_slope_9+scr_local_height,sj_slope_9+scr_local_s_type,sj_slope_9+scr_local_launch)
        scr_mu_slope_10(sj_slope_10,sj_slope_10+scr_local_angles,sj_slope_10+scr_local_height,sj_slope_10+scr_local_s_type,sj_slope_10+scr_local_launch)
        scr_mu_slope_11(sj_slope_11,sj_slope_11+scr_local_angles,sj_slope_11+scr_local_height,sj_slope_11+scr_local_s_type,sj_slope_11+scr_local_launch)
        scr_mu_slope_12(sj_slope_12,sj_slope_12+scr_local_angles,sj_slope_12+scr_local_height,sj_slope_12+scr_local_s_type,sj_slope_12+scr_local_launch)
        scr_mu_slope_13(sj_slope_13,sj_slope_13+scr_local_angles,sj_slope_13+scr_local_height,sj_slope_13+scr_local_s_type,sj_slope_13+scr_local_launch)
        scr_mu_slope_14(sj_slope_14,sj_slope_14+scr_local_angles,sj_slope_14+scr_local_height,sj_slope_14+scr_local_s_type,sj_slope_14+scr_local_launch)
        scr_mu_slope_15(sj_slope_15,sj_slope_15+scr_local_angles,sj_slope_15+scr_local_height,sj_slope_15+scr_local_s_type,sj_slope_15+scr_local_launch)
        scr_mu_slope_16(sj_slope_16,sj_slope_16+scr_local_angles,sj_slope_16+scr_local_height,sj_slope_16+scr_local_s_type,sj_slope_16+scr_local_launch)
        scr_mu_slope_17(sj_slope_17,sj_slope_17+scr_local_angles,sj_slope_17+scr_local_height,sj_slope_17+scr_local_s_type,sj_slope_17+scr_local_launch)
        scr_mu_slope_10(sj_slope_10_alt,sj_slope_10_alt+scr_local_angles,sj_slope_10_alt+scr_local_height,sj_slope_10_alt+scr_local_s_type,sj_slope_10_alt+scr_local_launch)
        scr_mu_slope_11(sj_slope_11_alt,sj_slope_11_alt+scr_local_angles,sj_slope_11_alt+scr_local_height,sj_slope_11_alt+scr_local_s_type,sj_slope_11_alt+scr_local_launch)
        scr_mu_slope_12(sj_slope_12_alt,sj_slope_12_alt+scr_local_angles,sj_slope_12_alt+scr_local_height,sj_slope_12_alt+scr_local_s_type,sj_slope_12_alt+scr_local_launch)
        scr_mu_slope_13(sj_slope_13_alt,sj_slope_13_alt+scr_local_angles,sj_slope_13_alt+scr_local_height,sj_slope_13_alt+scr_local_s_type,sj_slope_13_alt+scr_local_launch)
        scr_mu_slope_14(sj_slope_14_alt,sj_slope_14_alt+scr_local_angles,sj_slope_14_alt+scr_local_height,sj_slope_14_alt+scr_local_s_type,sj_slope_14_alt+scr_local_launch)
        scr_mu_slope_15(sj_slope_15_alt,sj_slope_15_alt+scr_local_angles,sj_slope_15_alt+scr_local_height,sj_slope_15_alt+scr_local_s_type,sj_slope_15_alt+scr_local_launch)
        scr_mu_slope_16(sj_slope_16_alt,sj_slope_16_alt+scr_local_angles,sj_slope_16_alt+scr_local_height,sj_slope_16_alt+scr_local_s_type,sj_slope_16_alt+scr_local_launch)
        scr_mu_slope_17(sj_slope_17_alt,sj_slope_17_alt+scr_local_angles,sj_slope_17_alt+scr_local_height,sj_slope_17_alt+scr_local_s_type,sj_slope_17_alt+scr_local_launch)
        scr_mu_slope_2(sj_donut_2,sj_donut_2+scr_local_angles,sj_donut_2+scr_local_height,sj_donut_2+scr_local_s_type,sj_donut_2+scr_local_launch)
        scr_mu_slope_3(sj_donut_3,sj_donut_3+scr_local_angles,sj_donut_3+scr_local_height,sj_donut_3+scr_local_s_type,sj_donut_3+scr_local_launch)
        scr_mu_slope_4(sj_donut_4,sj_donut_4+scr_local_angles,sj_donut_4+scr_local_height,sj_donut_4+scr_local_s_type,sj_donut_4+scr_local_launch)
        scr_mu_slope_5(sj_donut_5,sj_donut_5+scr_local_angles,sj_donut_5+scr_local_height,sj_donut_5+scr_local_s_type,sj_donut_5+scr_local_launch)
        scr_cs_donut_6(sj_donut_6,sj_donut_6+scr_local_angles,sj_donut_6+scr_local_height,sj_donut_6+scr_local_s_type,sj_donut_6+scr_local_launch)
        scr_cs_donut_7(sj_donut_7,sj_donut_7+scr_local_angles,sj_donut_7+scr_local_height,sj_donut_7+scr_local_s_type,sj_donut_7+scr_local_launch)
        scr_cs_donut_8(sj_donut_8,sj_donut_8+scr_local_angles,sj_donut_8+scr_local_height,sj_donut_8+scr_local_s_type,sj_donut_8+scr_local_launch)
        scr_cs_donut_9(sj_donut_9,sj_donut_9+scr_local_angles,sj_donut_9+scr_local_height,sj_donut_9+scr_local_s_type,sj_donut_9+scr_local_launch)
        scr_mu_ramp_4(sj_ramp_4,sj_ramp_4+scr_local_angles,sj_ramp_4+scr_local_height,sj_ramp_4+scr_local_s_type,sj_ramp_4+scr_local_launch)
        scr_mu_ramp_5(sj_ramp_5,sj_ramp_5+scr_local_angles,sj_ramp_5+scr_local_height,sj_ramp_5+scr_local_s_type,sj_ramp_5+scr_local_launch)
        scr_mu_ramp_16(sj_ramp_16,sj_ramp_16+scr_local_angles,sj_ramp_16+scr_local_height,sj_ramp_16+scr_local_s_type,sj_ramp_16+scr_local_launch)
        scr_mu_ramp_17(sj_ramp_17,sj_ramp_17+scr_local_angles,sj_ramp_17+scr_local_height,sj_ramp_17+scr_local_s_type,sj_ramp_17+scr_local_launch)
        scr_mnt_fof_0  (sj_fof_0,sj_fof_0+scr_local_angles,sj_fof_0+scr_local_height,sj_fof_0+scr_local_s_type,sj_fof_0+scr_local_launch)

        //Ladders
        scr_ladder_0    (spr_ladder_0,spr_ladder_0+scr_local_angles,spr_ladder_0+scr_local_height,spr_ladder_0+scr_local_s_type,spr_ladder_0+scr_local_launch)
        scr_ladder_0    (spr_ladder_1,spr_ladder_1+scr_local_angles,spr_ladder_1+scr_local_height,spr_ladder_1+scr_local_s_type,spr_ladder_1+scr_local_launch)
        scr_ladder_0    (spr_ladder_2,spr_ladder_2+scr_local_angles,spr_ladder_2+scr_local_height,spr_ladder_2+scr_local_s_type,spr_ladder_2+scr_local_launch)
        scr_ladder_0    (spr_ladder_3,spr_ladder_3+scr_local_angles,spr_ladder_3+scr_local_height,spr_ladder_3+scr_local_s_type,spr_ladder_3+scr_local_launch)
        scr_ladder_0    (spr_ladder_4,spr_ladder_4+scr_local_angles,spr_ladder_4+scr_local_height,spr_ladder_4+scr_local_s_type,spr_ladder_4+scr_local_launch)
        scr_ladder_0    (spr_ladder_5,spr_ladder_5+scr_local_angles,spr_ladder_5+scr_local_height,spr_ladder_5+scr_local_s_type,spr_ladder_5+scr_local_launch)
        scr_ladder_0    (spr_ladder_6,spr_ladder_6+scr_local_angles,spr_ladder_6+scr_local_height,spr_ladder_6+scr_local_s_type,spr_ladder_6+scr_local_launch)
        scr_ladder_0    (spr_ladder_7,spr_ladder_7+scr_local_angles,spr_ladder_7+scr_local_height,spr_ladder_7+scr_local_s_type,spr_ladder_7+scr_local_launch)
        //Switches
        scr_switch_0    (spr_switch_0,spr_switch_0+scr_local_angles,spr_switch_0+scr_local_height,spr_switch_0+scr_local_s_type,spr_switch_0+scr_local_launch)
        scr_switch_1    (spr_switch_2,spr_switch_2+scr_local_angles,spr_switch_2+scr_local_height,spr_switch_2+scr_local_s_type,spr_switch_2+scr_local_launch)
        scr_switch_1    (spr_switch_4,spr_switch_4+scr_local_angles,spr_switch_4+scr_local_height,spr_switch_4+scr_local_s_type,spr_switch_4+scr_local_launch)
        scr_hangbar     (spr_hangbar_0,spr_hangbar_0+scr_local_angles,spr_hangbar_0+scr_local_height,spr_hangbar_0+scr_local_s_type,spr_hangbar_0+scr_local_launch)
        scr_hangbar     (spr_hangbar_1,spr_hangbar_1+scr_local_angles,spr_hangbar_1+scr_local_height,spr_hangbar_1+scr_local_s_type,spr_hangbar_1+scr_local_launch)
        scr_hangbar     (spr_hangbar_2,spr_hangbar_2+scr_local_angles,spr_hangbar_2+scr_local_height,spr_hangbar_2+scr_local_s_type,spr_hangbar_2+scr_local_launch)
        scr_hangbar     (spr_hangbar_3,spr_hangbar_3+scr_local_angles,spr_hangbar_3+scr_local_height,spr_hangbar_3+scr_local_s_type,spr_hangbar_3+scr_local_launch)
        scr_hangbar     (spr_hangbar_4,spr_hangbar_4+scr_local_angles,spr_hangbar_4+scr_local_height,spr_hangbar_4+scr_local_s_type,spr_hangbar_4+scr_local_launch)
        scr_hangbar     (spr_hangbar_ignore,spr_hangbar_ignore+scr_local_angles,spr_hangbar_ignore+scr_local_height,spr_hangbar_ignore+scr_local_s_type,spr_hangbar_ignore+scr_local_launch)
        //Water-Running
        scr_water_running(tile_water_running,tile_water_running+scr_local_angles,tile_water_running+scr_local_height,tile_water_running+scr_local_s_type,tile_water_running+scr_local_launch)
        //Flat Surface Tiles
        //scr_flat_surface_tiles[length-1] = 0
        //scr_flat_surface_tiles[mu_flat_0] = 1 
        flat_surface_tile_registry = ds_list_create()
        //Temple
        flat_surface_tile_registry[| mu_flat_0] = true
        flat_surface_tile_registry[| mu_flat_1] = true
        flat_surface_tile_registry[| mu_flat_2] = true
        flat_surface_tile_registry[| mu_flat_3] = true
        flat_surface_tile_registry[| mu_flat_4] = true
        flat_surface_tile_registry[| mu_flat_5] = true
        flat_surface_tile_registry[| mu_flat_6] = true
        flat_surface_tile_registry[| mu_flat_7] = true
        flat_surface_tile_registry[| mu_flat_8] = true
        flat_surface_tile_registry[| mu_flat_9] = true
        flat_surface_tile_registry[| mu_flat_10] = true
        flat_surface_tile_registry[| mu_flat_11] = true
        flat_surface_tile_registry[| mu_flat_12] = true
        flat_surface_tile_registry[| mu_flat_13] = true
        flat_surface_tile_registry[| mu_flat_14] = true
        flat_surface_tile_registry[| mu_flat_15] = true
        flat_surface_tile_registry[| mu_flat_16] = true
        flat_surface_tile_registry[| mu_flat_17] = true
        flat_surface_tile_registry[| mu_flat_18] = true
        flat_surface_tile_registry[| mu_flat_19] = true
        flat_surface_tile_registry[| mu_flat_20] = true
        flat_surface_tile_registry[| mu_flat_21] = true
        flat_surface_tile_registry[| mu_flat_22] = true
        flat_surface_tile_registry[| mu_flat_23] = true
        flat_surface_tile_registry[| mu_flat_24] = true
        flat_surface_tile_registry[| mu_flat_25] = true
        flat_surface_tile_registry[| mu_flat_26] = true
        flat_surface_tile_registry[| mu_flat_27] = true
        flat_surface_tile_registry[| mu_flat_28] = true
        flat_surface_tile_registry[| mu_flat_29] = true
        flat_surface_tile_registry[| mu_flat_30] = true
        flat_surface_tile_registry[| mu_flat_31] = true
        flat_surface_tile_registry[| mu_flat_32] = true
        flat_surface_tile_registry[| mu_flat_33] = true
        flat_surface_tile_registry[| mu_flat_34] = true
        flat_surface_tile_registry[| mu_flat_35] = true
        flat_surface_tile_registry[| mu_flat_37] = true
        flat_surface_tile_registry[| mu_flat_38] = true
        flat_surface_tile_registry[| mu_door_0] = true
        flat_surface_tile_registry[| mu_door_1] = true
        flat_surface_tile_registry[| mu_door_2] = true
        //West District
        flat_surface_tile_registry[| wd_flat_0] = true
        flat_surface_tile_registry[| wd_flat_1] = true
        flat_surface_tile_registry[| wd_flat_2] = true
        flat_surface_tile_registry[| wd_flat_3] = true
        flat_surface_tile_registry[| wd_flat_4] = true
        flat_surface_tile_registry[| wd_flat_5] = true
        flat_surface_tile_registry[| wd_flat_6] = true
        flat_surface_tile_registry[| wd_flat_7] = true
        flat_surface_tile_registry[| wd_flat_8] = true
        flat_surface_tile_registry[| wd_flat_9] = true
        flat_surface_tile_registry[| wd_flat_10] = true
        flat_surface_tile_registry[| wd_flat_11] = true
        flat_surface_tile_registry[| wd_flat_12] = true
        flat_surface_tile_registry[| wd_flat_13] = true
        flat_surface_tile_registry[| wd_flat_14] = true
        flat_surface_tile_registry[| wd_flat_15] = true
        flat_surface_tile_registry[| wd_flat_16] = true
        flat_surface_tile_registry[| wd_flat_17] = true
        flat_surface_tile_registry[| wd_flat_18] = true
        flat_surface_tile_registry[| wd_flat_19] = true
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Shang Mu Architect Editor

//Shang Mu Architect Editor Variables
use_editor     = 0                 //Are we currently using the editor?
use_cursor_x   = 0                //What is our cursor's X position?
use_cursor_y   = 0                //What is our cursor's Y position?
use_cursor_prx = 0                //What is our cursor's previous X position?
use_cursor_pry = 0                //What is our cursor's previous Y position?
use_cursor_spr = 0                //What is our cursor's sprite?
use_cursor_mode = 0               //What is our current method of input?
use_grid       = 1                //What is our current grid's size?
use_move       = 0                //Are we pressing the move button?
use_delete     = 0                //Are we pressing the delete button?
use_put_here   = 0                //Are we pressing the pute here button?
use_copy       = 0                //Are we pressing the copy button?
use_layer_up   = 0                //Are we pressing the layer up button?
use_layer_down = 0                //Are we pressing the layer down button?
use_snap_up    = 0                //Are we pressing the snap up button?
use_snap_down  = 0                //Are we pressing the snap down button?
use_pause      = 0                //Are we pressing the pause button?
use_new_tile   = 0                //Are we pressing the new tile button?
use_move_left  = 0                //Are we pressing the left button?
use_move_right = 0                //Are we pressing the right button?
use_move_up    = 0                //Are we pressing the up button?
use_move_down  = 0                //Are we pressing the down button?
alt_left       = 0                //Are we pressing the left button?
alt_right      = 0                //Are we pressing the right button?
alt_up         = 0                //Are we pressing the up button?
alt_down       = 0                //Are we pressing the down button?
user_cursor_mode = 0              //Are We Allowed To Use The Cursor?
use_write_delay = 0               //How Long Should We Activate All Instances In The Room?
use_maps_load = 0                 //Should We Load A New Level?
use_maps_select = 0               //What Stage Should We Load?
use_cuts_select = ""              //What Cutscene Should We Load?
use_maps_x    = 0                 //Restore Camera's Previous X Position
use_maps_y    = 0                 //Restore Camera's Previous Y Position
user_changed_files = 1            //Have We Recently Modified Files In The Maps Folder?

//Shang Mu Academy UI Variables
use_menu     = 0                //Are we currently in the main menu?
use_menu_x   = 0                //What is our horizontal menu position?
use_menu_y   = 0                //What is our vertical menu position?
use_menu_pos_x = 0              //What is our horizontal menu position in pixels?
use_menu_pos_y = 0              //What is our vertical menu position in pixels?
ui_selected_skin   = spr_lilac_bench //Who is our currently selected character?
ui_selected_frame  = 0               //What is our selected character's current animation frame?
ui_selected_pos    = 0               //What is our currently selected character's position?
ui_selected_name   = "Lilac"         //What is our currently selected character's name?
ui_selected_offset_x = 18            //What is our currently selected character's X position?
ui_selected_offset_y = 132           //What is our currently selected character's Y position?
use_a        = 0                //Are we pressing the A button? (Accept)
use_b        = 0                //Are we pressing the B button? (Cancel)
use_c        = 0                //Are we pressing the C button? (Change Character)
use_d        = 0                //Are we pressing the D button? (Change Palette)
use_start    = 0                //Are we pressing the Start button? (Accept)
use_left     = 0                //Are we pressing left?
use_right    = 0                //Are we pressing right?
use_up       = 0                //Are we pressing up?
use_down     = 0                //Are we pressing down?
display_time = 0                //What is the time attack record for this particular stage?
display_page = 0                //Which page are we currently on?
tile_modify_properties_id = -1
use_zoom_multiplier = 1         //What is our current zoom level? (For scaling background layers appropriately)
use_zoom_scale_factor = 1
use_maps_files[0,0] = "..."
use_maps_files[0,1] = "..."
use_maps_files[0,2] = "..."
use_maps_files[0,3] = "..."
use_maps_files[0,4] = "..."
use_maps_pages = 0

use_test_variable = program_directory + "\Maps\Test.ini"
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Title Screen Menu
title_scroll_x   = 157      //X position offset for menu elements
title_offset_x   = 0        //What is our cursor's X offset?
title_scroll_active = 0     //Are the menus currently scrolling?
title_scroll_timer = 0      //How long are we allowed to scroll?
title_scroll_page  = 0      //What is our current page?
title_animation  = 0        //What is our current animation frame for the title screen menu cursor?
title_position   = 0        //What is our cursor's current offset on the menu?
title_page       = 0        //What is our current page on the menu?
title_scroll     = 0        //What is our cursor's current position on the menu?
title_bg_current = 0        //What is our background's current frame of animation?
title_type       = 0        //What is the type of our currently selected input device?
title_joy_poll   = 0        //At which stage are we modifying assigned inputs?
title_joy_polltimer = 0     //How long before we're allowed to poll for inputs?
title_joy_poll_button = 0   //Which button are we pressing during polling?
title_joy_poll_key = 0      //Which key are we pressing during polling?
title_joy_cool_down  = 0    //How long before we're allowed to interact with the menus again?
title_room_goto = 0         //Which room are we heading to after the transition?
title_room_timer = 0        //How long should we wait before changing rooms?
title_item_shake_timer = -1 //Is the menu item shaking?
title_item_shake_mod = 1    //Menu item shake modifier
title_item_shake_iter = 0   //Menu item shake iteration timer
title_item_shake_iterations = 0 //Menu item shake iteration timer
title_item_shake_cur = 0    //Which menu item are we currently shaking?
title_cursor_shake = 0      //Are we currently shaking this menu cursor?
title_item_shake[0]  = 0    //Are we currently shaking this menu element?
title_item_shake[1]  = 0    //Are we currently shaking this menu element?
title_item_shake[2]  = 0    //Are we currently shaking this menu element?
title_item_shake[3]  = 0    //Are we currently shaking this menu element?
title_item_shake[4]  = 0    //Are we currently shaking this menu element?
title_item_shake[5]  = 0    //Are we currently shaking this menu element?
title_item_shake[6]  = 0    //Are we currently shaking this menu element?
title_item_shake[7]  = 0    //Are we currently shaking this menu element?
title_item_shake[8]  = 0    //Are we currently shaking this menu element?
title_item_shake[9]  = 0    //Are we currently shaking this menu element?
title_item_shake[10] = 0    //Are we currently shaking this menu element?
title_item_shake[11] = 0    //Are we currently shaking this menu element?
title_item_shake[12] = 0    //Are we currently shaking this menu element?
title_item_shake[13] = 0    //Are we currently shaking this menu element?
title_item_shake[14] = 0    //Are we currently shaking this menu element?
title_item_shake[15] = 0    //Are we currently shaking this menu element?
title_item_shake[16] = 0    //Are we currently shaking this menu element?
//Player Mode Alpha Transparency
title_bg_alpha_0 = 0.9      //What is our controller background's transparency? (Player Mode)
title_bg_alpha_1 = 0.9      //What is our controller background's transparency? (Player Mode)
title_bg_alpha_2 = 0.9      //What is our controller background's transparency? (Player Mode)
title_bg_alpha_3 = 0.9      //What is our controller background's transparency? (Player Mode)
title_bg_alpha_4 = 0.9      //What is our controller background's transparency? (Player Mode)
title_bg_alpha_5 = 0.9      //What is our controller background's transparency? (Player Mode)
title_bg_alpha_6 = 0.9      //What is our controller background's transparency? (Player Mode)
title_bg_alpha_7 = 0.9      //What is our controller background's transparency? (Player Mode)
//Editor Mode Alpha Transparency
title_ed_alpha_0  = 0.9      //What is our controller background's transparency? (Editor Mode)
title_ed_alpha_1  = 0.9      //What is our controller background's transparency? (Editor Mode)
title_ed_alpha_2  = 0.9      //What is our controller background's transparency? (Editor Mode)
title_ed_alpha_3  = 0.9      //What is our controller background's transparency? (Editor Mode)
title_ed_alpha_4  = 0.9      //What is our controller background's transparency? (Editor Mode)
title_ed_alpha_5  = 0.9      //What is our controller background's transparency? (Editor Mode)
title_ed_alpha_6  = 0.9      //What is our controller background's transparency? (Editor Mode)
title_ed_alpha_7  = 0.9      //What is our controller background's transparency? (Editor Mode)
title_ed_alpha_8  = 0.9      //What is our controller background's transparency? (Editor Mode)
title_ed_alpha_9  = 0.9      //What is our controller background's transparency? (Editor Mode)
title_ed_alpha_10 = 0.9      //What is our controller background's transparency? (Editor Mode)
title_ed_alpha_11 = 0.9      //What is our controller background's transparency? (Editor Mode)
title_ed_alpha_12 = 0.9      //What is our controller background's transparency? (Editor Mode)
title_ed_alpha_13 = 0.9      //What is our controller background's transparency? (Editor Mode)
title_ed_alpha_14 = 0.9      //What is our controller background's transparency? (Editor Mode)
title_ed_alpha_15 = 0.9      //What is our controller background's transparency? (Editor Mode)
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Refer to Room Start for other values that need to be refreshed per room</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///As a safety measure, restart program if the resource manager is destroyed
///under circumstances that were not anticipated
game_restart();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Spawn at Player Next Spawner's X/Y Coordinates
px = multimap_player_x           //Player X POS
py = multimap_player_y          //Player X POS
start_x = multimap_player_x      //Player X POS
start_y = multimap_player_y      //Player X POS
view_xview[view_port] = multimap_player_x-213    //Camera X POS
view_yview[view_port] = multimap_player_x-120    //Camera X POS
checkpoint_x = multimap_player_x //Player X POS
checkpoint_y = multimap_player_y //Player X POS
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Keyboard, Controller, and Mouse Input System

//=====================General Program Functions=====================//

if keyboard_check(vk_shift)
    {
        if keyboard_check_pressed(vk_f1)
            {
                user_combat_freeze_frame += 1;
                if user_combat_freeze_frame &gt; 1
                    user_combat_freeze_frame = 0;
                audio_play_sound(pause_select,50,false);
            }
    }
else
    {
        if keyboard_check_pressed(vk_f1) and room != rm_editor
            scr_set_debug_mode_f1();
    }

if keyboard_check(vk_f2) and not instance_exists(DISCLAIMER)
    scr_set_reset_f2();

if keyboard_check_released(vk_f2)
    {
        key_reset_timer = 0;
        key_reset_alpha = 0;
    }
if keyboard_check_pressed(vk_f3)
    scr_set_controller_slot_f3();

if keyboard_check_pressed(vk_f4)
    scr_set_controller_slot_f4();

if keyboard_check_released(vk_f5) and room = rm_player
    scr_set_message("Cannot save stages outside Editor Mode!");
    
if keyboard_check_pressed(vk_f6)
    scr_set_controller_type_f6();

if keyboard_check_pressed(vk_f7)
    scr_set_resize_game_window_f7();

if keyboard_check_pressed(vk_f8)
    scr_set_vsync_f8();

//Set the game program to fullscreen, and visa versa
if (keyboard_check_direct(vk_ralt) and keyboard_check_pressed(vk_enter))
    {
        fullscreen += 1
        if fullscreen &gt; 1 fullscreen = 0;
        if fullscreen = 0 window_set_fullscreen(false);
        if fullscreen = 1 window_set_fullscreen(true);
        audio_play_sound(pause_select,50,false);
    }
if keyboard_check_pressed(vk_f9)
    scr_set_controller_overlay_f9();

if keyboard_check_pressed(vk_f10)
    scr_set_zoom_level_f10();

if keyboard_check_pressed(vk_f11)
    scr_set_mute_or_unmute_music_f11();

//Save Screenshots
if keyboard_check_pressed(vk_f12)
    scr_set_screenshot();

//Enable Debug Profiler Overlay
if keyboard_check_pressed(vk_pause)
    {
        debug_profiler += 1
        if debug_profiler &gt; 1
            {
                debug_profiler = 0
                show_debug_overlay(false)
            }
        if debug_profiler = 1 show_debug_overlay(true);
    }

//=====================Automatic Input Switching=====================//

//Switch to Keyboard if input is detected
if keyboard_check(vk_anykey) or mouse_check_button(mb_any)
or joy_mouse_button_switch = 1
    {
        joy_input[2,1] = 0
        //Reset Screensaver Timer
        joy_input_screen_saver = 0
    }
//Switch to Joystick if input is detected
else
    {
        joy_input[2,1] = 1
        //Iterate Screensaver Timer
        joy_input_screen_saver += 1
        joy_mouse_button_busy_timer = 0
    }

if user_move_list_display = 1 or skin = spr_milla or (skin = spr_carol and bike = 1)
    {
        if keyboard_check(vk_anykey) or mouse_check_button(mb_any) user_move_list_control_type = 0;
        //Check Controller's Action Buttons
        if gamepad_button_check(joy_modern_id,joy_a_mod) = 1
        or gamepad_button_check(joy_modern_id,joy_b_mod) = 1
        or gamepad_button_check(joy_modern_id,joy_c_mod) = 1
        or gamepad_button_check(joy_modern_id,joy_d_mod) = 1
        or gamepad_button_check(joy_modern_id,joy_start_mod) = 1
        //Check Controller's Dpad
        or gamepad_button_check(joy_modern_id,joy_left_mod) = 1
        or gamepad_button_check(joy_modern_id,joy_right_mod) = 1
        or gamepad_button_check(joy_modern_id,joy_up_mod) = 1
        or gamepad_button_check(joy_modern_id,joy_down_mod) = 1
            user_move_list_control_type = 1;
    }

//=====================Automatic Input Unlocking=====================//

if joy_input[2,6] &gt; 0
    {
        joy_input[2,6] -= 1
        hsp = 0
        gravity_speed = 0
        anim_current=anim_standing
    }

//=======================Screen Saver Behavior=======================//

//Increase Alpha After Five Minutes Of No Activity
if joy_input_screen_saver &gt; 3000 and joy_input_screen_saver_alpha &lt; 0.45
    joy_input_screen_saver_alpha += 0.025;
//Decrease Alpha If There Is Activity
if joy_input_screen_saver &lt; 3000 and joy_input_screen_saver_alpha &gt; 0
    joy_input_screen_saver_alpha -= 0.025;

//Reset Screensaver Timer If There Are Any Inputs
if joy_input[0,0] = 1 or joy_input[0,1] = 1
or joy_input[0,2] = 1 or joy_input[0,3] = 1
or joy_input[1,0] = 1 or joy_input[1,2] = 1
or joy_input[1,3] = 1 or joy_input[2,0] = 1
or joy_input[1,4] = 1
    joy_input_screen_saver = 0;

//========================Start Menu Behavior========================//

if user_cursor_mode = 0
{
//Pause Menu Logic
if pause = 1
    {
        //Increment Inputs for "Up" and "Down"
        if joy_input[0,3] = 1 and pause_lock = 0 Jpause[2]+=1; else Jpause[2]=0;       //Joystick Up
        if joy_input[0,1] = 1 and pause_lock = 0 Jpause[3]+=1; else Jpause[3]=0;       //Joystick Down
        if joy_input[1,3] = 1 or joy_input[1,4] = 1 scr_set_mouse_mode_off(0);
        //Pause Menu Selections
        if room = rm_editor
            {
                if Jpause[2] = 1 and yy &gt; 0  and pause_lock = 0 {yy-=24; audio_play_sound(pause_select,50,false)}
                if Jpause[3] = 1 and yy &lt; 48 and pause_lock = 0 {yy+=24; audio_play_sound(pause_select,50,false)}
            }
        else
            {
                if Jpause[2] = 1 and yy &gt; 0  and pause_lock = 0 {yy-=24; audio_play_sound(pause_select,50,false)}
                if pause_sub_menu = 0
                    {
                        if Jpause[3] = 1 and yy &lt; 96 and pause_lock = 0 {yy+=24; audio_play_sound(pause_select,50,false)}
                        if yy &gt; 96 yy = 0;

                        if joy_mouse_button_switch = 1
                            {
                                if device_mouse_x_to_gui(0) &gt; 136 and device_mouse_x_to_gui(0) &lt; 296
                                    {
                                        if device_mouse_y_to_gui(0) &gt; 118 and device_mouse_y_to_gui(0) &lt; 134
                                            yy = 0;
                                        if device_mouse_y_to_gui(0) &gt; 141 and device_mouse_y_to_gui(0) &lt; 157
                                            yy = 24;
                                        if device_mouse_y_to_gui(0) &gt; 164 and device_mouse_y_to_gui(0) &lt; 180
                                            yy = 48;
                                        if device_mouse_y_to_gui(0) &gt; 187 and device_mouse_y_to_gui(0) &lt; 203
                                            yy = 72;
                                        if device_mouse_y_to_gui(0) &gt; 211 and device_mouse_y_to_gui(0) &lt; 228
                                            yy = 96;
                                    }
                            }
                    }
                else
                    {
                        if Jpause[3] = 1 and yy &lt; 144 and pause_lock = 0 {yy+=24; audio_play_sound(pause_select,50,false)}
                        if yy &gt; 120 yy = 0;

                        if joy_mouse_button_switch = 1
                            {
                                if device_mouse_x_to_gui(0) &gt; 136 and device_mouse_x_to_gui(0) &lt; 296
                                    {
                                        if device_mouse_y_to_gui(0) &gt; 96 and device_mouse_y_to_gui(0) &lt; 113
                                            yy = 0;
                                        if device_mouse_y_to_gui(0) &gt; 116 and device_mouse_y_to_gui(0) &lt; 133
                                            yy = 24;
                                        if device_mouse_y_to_gui(0) &gt; 136 and device_mouse_y_to_gui(0) &lt; 153
                                            yy = 48;
                                        if device_mouse_y_to_gui(0) &gt; 156 and device_mouse_y_to_gui(0) &lt; 173
                                            yy = 72;
                                        if device_mouse_y_to_gui(0) &gt; 176 and device_mouse_y_to_gui(0) &lt; 193
                                            yy = 96;
                                        if device_mouse_y_to_gui(0) &gt; 196 and device_mouse_y_to_gui(0) &lt; 213
                                            yy = 120;
                                    }
                            }
                    }
            }
        //Execute Pause Menu Selections
        if pause_sub_menu_timer = 0
            {
                if (joy_input[1,2] = 1 and yy=0 and pause_lock = 0 and user_access_bar_y_target = 274 and pause_sub_menu = 0)
                or (joy_mouse_button_switch = 1  and pause_sub_menu = 0 and mouse_check_button_pressed(joy_mouse_button_left)
                and device_mouse_x_to_gui(0) &gt; 152 and device_mouse_x_to_gui(0) &lt; 291
                and device_mouse_y_to_gui(0) &gt; 118 and device_mouse_y_to_gui(0) &lt; 134)
                    {
                        if ground = 1 pause_lock = 8;
                        else          pause_lock = 0;
                        pause=0 yy=0 Jpause[1]=0 scr_resume_sounds();
                    }
            }
        if pause_sub_menu_timer &gt; 0
            pause_sub_menu_timer -= 1;

        //Pause Menu Items
        if pause_sub_menu = 0
            {
                //Restart
                if (joy_input[1,2] = 1 and ((room = rm_editor and yy=24) or (room != rm_editor and yy=48))
                and pause_lock = 0)
                or (joy_mouse_button_switch = 1 and mouse_check_button_pressed(joy_mouse_button_left)
                and device_mouse_x_to_gui(0) &gt; 152 and device_mouse_x_to_gui(0) &lt; 291
                and ((room = rm_editor and device_mouse_y_to_gui(0) &gt; 156 and device_mouse_y_to_gui(0) &lt; 175)
                or (room != rm_editor and device_mouse_y_to_gui(0) &gt; 162 and device_mouse_y_to_gui(0) &lt; 182)))
                    {
                        //Exceptions list for hub maps
                        var yes = 1;
                        if room = rm_campaign
                            yes = scr_get_restart_map_exceptions_list();
                        if lives &gt; 0 and room != rm_editor and yes = 1
                            {
                                pause_lock = 1
                                pause=0
                                yy=0
                                Jpause[1]=0
                                scr_resume_sounds()
                                scr_lilac_variables()
                                scr_carol_variables()
                                scr_milla_variables()
                                scr_attack_variables()
                                jump_override = 0
                                Animations_Override = 0
                                active_attack = 0
                                gravity_override = 0
                                breath = breath_max
                                user_access_bar_y_target = 274
                                user_access_bar_y_offset = 274
                                //Reset drown timer
                                alarm_timer = 660
                                if room = rm_player use_maps_load = 1;
                                audio_stop_sound(snd_drowning)
                                //Stop Carol's Bike's Sounds
                                audio_stop_sound(carol_bike_idle)
                                audio_stop_sound(bike_pitch)
                                audio_stop_sound(carol_bike_moving)
                                audio_stop_sound(carol_bike_skidding)
                                if room = rm_campaign
                                    {
                                        shield = spr_shield_wood    //Current Shield
                                        shield_health   = 2         //Current Shield Health
                                        shield_active   = 0         //Is Our Shield Active?
                                        shield_invuln   = 32        //How Long Before the Shield Accept Damage Again?
                                        shield_frame    = 0         //Current Shield Frame of Animation
                                        shield_speed    = 0         //Animation Speed of the Shield
                                        shield_timer    = -8        //How Long Before the Shield Is Active?
                                        shield_flash    = 0         //How Long Should the Shield Flash Last?
                                        shield_hold     = 0         //Next Shield in the Queue
                                        shield_rotate   = 0         //What Is Our Rotation? (Water Shield Only)
                                        shield_framemax = 0         //Maximum Number of Animated Shield Frames
                                        shield_rotate_x = 0         //X Position of the Shield
                                        shield_rotate_y = 0         //Y Position of the Shield
                                        shield_angle    = 0         //Angle of The Shield While Orbiting the Player
                                    }
                                now_loading = 1
                                lives -= 1;
                            }
                        if lives &lt;= 0 or room = rm_editor or yes = 0
                            {
                                if not audio_is_playing(character_parry)
                                    audio_play_sound(character_parry,50,false);
                            }
                    }
                //Potions
                if (room != rm_editor and yy=24
                and pause_lock = 0 and transition_active = 0)
                or (joy_mouse_button_switch = 1 and room != rm_editor
                and pause_lock = 0 and transition_active = 0
                and device_mouse_x_to_gui(0) &gt; 138 and device_mouse_x_to_gui(0) &lt; 428
                and device_mouse_y_to_gui(0) &gt; 141 and device_mouse_y_to_gui(0) &lt; 157)
                    {
                        var yes = 0;
                        //Confirm Press
                        if joy_input[1,2] = 1 {yes = 1; pause_potion_menu_accept += 1;}
                        else                  pause_potion_menu_accept = 0;
                        //Confirm Left
                        if joy_input[0,2] = 1 {yes = 1; pause_potion_menu_left += 1;}
                        else                  pause_potion_menu_left = 0;
                        //Confirm Right
                        if joy_input[0,0] = 1 {yes = 1; pause_potion_menu_right += 1;}
                        else                  pause_potion_menu_right = 0;
                        //Sub-Menu Navigation
                        if pause_potion_menu_left = 1
                            {
                                pause_potion_menu_select -= 1
                                if pause_potion_menu_select &lt; 0
                                    pause_potion_menu_select = 5;
                                audio_play_sound(pause_select,50,false)
                            }
                        if pause_potion_menu_right = 1
                            {
                                pause_potion_menu_select += 1
                                if pause_potion_menu_select &gt; 5
                                    pause_potion_menu_select = 0;
                                audio_play_sound(pause_select,50,false)
                            }
                        //Mouse Navigation
                        if joy_mouse_button_switch = 1 and room != rm_editor
                            {
                                if device_mouse_x_to_gui(0) &gt; 287 and device_mouse_x_to_gui(0) &lt; 306
                                    pause_potion_menu_select = 0;
                                if device_mouse_x_to_gui(0) &gt; 307 and device_mouse_x_to_gui(0) &lt; 326
                                    pause_potion_menu_select = 1;
                                if device_mouse_x_to_gui(0) &gt; 327 and device_mouse_x_to_gui(0) &lt; 346
                                    pause_potion_menu_select = 2;
                                if device_mouse_x_to_gui(0) &gt; 347 and device_mouse_x_to_gui(0) &lt; 366
                                    pause_potion_menu_select = 3;
                                if device_mouse_x_to_gui(0) &gt; 367 and device_mouse_x_to_gui(0) &lt; 386
                                    pause_potion_menu_select = 4;
                                if device_mouse_x_to_gui(0) &gt; 387 and device_mouse_x_to_gui(0) &lt; 406
                                    pause_potion_menu_select = 5;
                            }
                        if (pause_potion_menu_accept = 1)
                        or (joy_mouse_button_switch = 1 and mouse_check_button_pressed(joy_mouse_button_left))
                            {
                                switch(pause_potion_menu_select)
                                    {
                                        //Petal Potion
                                        case 0:
                                            {
                                                if potion_petal_potion &gt; 0
                                                    {
                                                        if petals &lt; petalsmax
                                                            {
                                                                petals += 1
                                                                potion_petal_potion -= 1
                                                                audio_play_sound(snd_potion_use,50,false)
                                                                audio_play_sound(petal_grab,50,false)
                                                            }
                                                        if petals &gt;= petalsmax
                                                            {
                                                                petals = petalsmax
                                                                audio_play_sound(character_parry,50,false)
                                                            }
                                                    }
                                                else
                                                    {
                                                        audio_play_sound(character_parry,50,false)
                                                    }
                                                break;
                                            }
                                        //Stamina Potion
                                        case 1:
                                            {
                                                if potion_stamina_drink &gt; 0
                                                    {
                                                        if (stamina &lt; 150)
                                                        or (skin = spr_milla and milla_flutter_stamina_bar &lt; 65)
                                                            {
                                                                stamina += 100
                                                                if stamina &gt; 100 stamina_boosted = 1;
                                                                if stamina &gt; 150 stamina = 150;
                                                                milla_flutter_stamina_bar = 65
                                                                audio_play_sound(snd_midboss_gate,50,false)
                                                                potion_stamina_drink -= 1
                                                                audio_play_sound(snd_potion_use,50,false)
                                                            }
                                                        if (stamina &gt;= 150)
                                                        or (skin = spr_milla and milla_flutter_stamina_bar &gt;= 65)
                                                            {
                                                                stamina = 150
                                                                audio_play_sound(character_parry,50,false)
                                                            }
                                                    }
                                                else
                                                    {
                                                        audio_play_sound(character_parry,50,false)
                                                    }
                                                break;
                                            }
                                        //Feather Potion
                                        case 2:
                                            {
                                                if potion_feather_potion &gt; 0
                                                    {
                                                        if potion_feather_timer &lt;= 0
                                                            {
                                                                potion_feather_potion -= 1
                                                                obj_game_logic.potion_feather_timer = sprite_get_width(spr_hud_feather_timer)
                                                                audio_play_sound(snd_potion_use,50,false)
                                                            }
                                                        else
                                                            {
                                                                audio_play_sound(character_parry,50,false)
                                                            }
                                                    }
                                                else
                                                    {
                                                        audio_play_sound(character_parry,50,false)
                                                    }
                                                break;
                                            }
                                        //Petal Core
                                        case 3:
                                            {
                                                if potion_petal_core &gt; 0
                                                    {
                                                        if potion_petal_timer = 0
                                                            {
                                                                potion_petal_timer = 12
                                                                potion_petal_core -= 1
                                                                audio_play_sound(snd_potion_use,50,false)
                                                                audio_play_sound(petal_absorbed,50,false)
                                                            }
                                                        else
                                                            {
                                                                audio_play_sound(character_parry,50,false)
                                                            }
                                                    }
                                                else
                                                    {
                                                        audio_play_sound(character_parry,50,false)
                                                    }
                                                break;
                                            }
                                        //Stamina Core
                                        case 4:
                                            {
                                                if (potion_stamina_core &gt; 0 and speed_boosted_timer = 0)
                                                    {
                                                        speed_boosted_timer = sprite_get_width(spr_hud_booster_timer)
                                                        audio_play_sound(snd_petal_shatter,50,false)
                                                        potion_stamina_core -= 1
                                                        audio_play_sound(snd_potion_use,50,false)
                                                    }
                                                else
                                                    {
                                                        audio_play_sound(character_parry,50,false)
                                                    }
                                                break;
                                            }
                                        //Mystery Potatoes
                                        case 5:
                                            {
                                                if potion_mystery_potion &gt; 0
                                                    {
                                                        if potion_mystery_timer &lt;= 0
                                                            {
                                                                potion_mystery_potion -= 1
                                                                potion_mystery_effect = floor(random_range(0,12.8))
                                                                //Mystery Effects
                                                                switch(potion_mystery_effect)
                                                                    {
                                                                        case 5:
                                                                            {
                                                                                if cube_rain_timer = 0
                                                                                    cube_rain_timer = 300;
                                                                                else
                                                                                    audio_play_sound(character_parry,50,false);
                                                                                break;
                                                                            }
                                                                        //Petal Potion
                                                                        case 6:
                                                                            {
                                                                                if petals &lt; petalsmax
                                                                                    {
                                                                                        petals += 3
                                                                                        audio_play_sound(petal_grab,50,false)
                                                                                    }
                                                                                if petals &gt;= petalsmax
                                                                                    {
                                                                                        petals = petalsmax
                                                                                        audio_play_sound(character_parry,50,false)
                                                                                    }
                                                                                break;
                                                                            }
                                                                        //Stamina Potion
                                                                        case 7:
                                                                            {
                                                                                if (stamina &lt; 150)
                                                                                or (skin = spr_milla and milla_flutter_stamina_bar &lt; 65)
                                                                                    {
                                                                                        stamina += 100
                                                                                        if stamina &gt; 100 stamina_boosted = 1;
                                                                                        if stamina &gt; 150 stamina = 150;
                                                                                        milla_flutter_stamina_bar = 65
                                                                                        audio_play_sound(snd_midboss_gate,50,false)
                                                                                        potion_stamina_drink -= 1
                                                                                    }
                                                                                if (stamina &gt;= 150)
                                                                                or (skin = spr_milla and milla_flutter_stamina_bar &gt;= 65)
                                                                                    {
                                                                                        stamina = 150
                                                                                        audio_play_sound(character_parry,50,false)
                                                                                    }
                                                                                break;
                                                                            }
                                                                        //Petal Core
                                                                        case 8:
                                                                            {
                                                                                if potion_petal_timer = 0
                                                                                    {
                                                                                        potion_petal_timer = 12
                                                                                        potion_petal_core -= 1
                                                                                        obj_game_logic.potion_mystery_timer = sprite_get_width(spr_hud_mystery_timer)
                                                                                        audio_play_sound(petal_absorbed,50,false)
                                                                                    }
                                                                                else
                                                                                    {
                                                                                        audio_play_sound(character_parry,50,false)
                                                                                    }
                                                                                break;
                                                                            }
                                                                        //Stamina Core
                                                                        case 9:
                                                                            {
                                                                                speed_boosted_timer = sprite_get_width(spr_hud_booster_timer)
                                                                                obj_game_logic.potion_mystery_timer = sprite_get_width(spr_hud_mystery_timer)
                                                                                audio_play_sound(snd_petal_shatter,50,false)
                                                                                break;
                                                                            }
                                                                        //Feather Potion
                                                                        case 10:
                                                                            {
                                                                                obj_game_logic.potion_feather_timer = sprite_get_width(spr_hud_feather_timer)
                                                                                obj_game_logic.potion_mystery_timer = sprite_get_width(spr_hud_mystery_timer)
                                                                                break;
                                                                            }
                                                                        //Bomb
                                                                        case 11:
                                                                            {
                                                                                bomb_id = instance_create(universal_player_x,universal_player_y,obj_bomb)
                                                                                bomb_id.detonate = 1
                                                                                bomb_id.detonate_delay = 1
                                                                                bomb_id.detonate_for_milla = 1
                                                                                audio_play_sound(snd_explosion,50,false)
                                                                                //Heal player to negate explosive damage
                                                                                petals += 4
                                                                                if petals &gt;= petalsmax petals = petalsmax;
                                                                            }
                                                                        //Fully Healing Potion
                                                                        case 12:
                                                                            {
                                                                                if petals &lt; petalsmax
                                                                                    {
                                                                                        petals = petalsmax
                                                                                        audio_play_sound(petal_grab,50,false)
                                                                                    }
                                                                                if petals &gt;= petalsmax
                                                                                    {
                                                                                        petals = petalsmax
                                                                                        audio_play_sound(character_parry,50,false)
                                                                                    }
                                                                                break;
                                                                            }
                                                                    }
                                                                if room != rm_editor
                                                                and potion_mystery_effect &gt;= 2 and potion_mystery_effect &lt;= 5
                                                                    {
                                                                        if use_weather_conditions != 1
                                                                            {
                                                                                audio_stop_sound(snd_rain)
                                                                                audio_stop_sound(snd_tempest)
                                                                                audio_play_sound(snd_rain,50,true)
                                                                                use_weather_conditions = 1
                                                                                obj_game_logic.potion_mystery_timer = sprite_get_width(spr_hud_mystery_timer)
                                                                            }
                                                                    }
                                                                audio_play_sound(snd_potion_use,50,false)
                                                            }
                                                        else
                                                            {
                                                                audio_play_sound(character_parry,50,false)
                                                            }
                                                    }
                                                else
                                                    {
                                                        audio_play_sound(character_parry,50,false)
                                                    }
                                                break;
                                            }
                                    }
                            }
                    }
                //Options
                if (joy_input[1,2] = 1 and room != rm_editor and yy=72
                and pause_lock = 0 and transition_active = 0)
                or (joy_mouse_button_switch = 1 and room != rm_editor
                and pause_lock = 0 and transition_active = 0
                and mouse_check_button_pressed(joy_mouse_button_left)
                and device_mouse_x_to_gui(0) &gt; 138 and device_mouse_x_to_gui(0) &lt; 274
                and (device_mouse_y_to_gui(0) &gt; 187 and device_mouse_y_to_gui(0) &lt; 204))
                    {
                        pause_sub_menu = 1
                        yy = 0
                        pause_sub_menu_timer = 8
                        audio_play_sound(pause_select,50,false)
                    }
                //Quit
                if (joy_input[1,2] = 1 and ((room = rm_editor and yy=48) or (room != rm_editor and yy=96))
                and pause_lock = 0 and transition_active = 0)
                or (joy_mouse_button_switch = 1 and mouse_check_button_pressed(joy_mouse_button_left)
                and device_mouse_x_to_gui(0) &gt; 152 and device_mouse_x_to_gui(0) &lt; 291
                and ((room = rm_editor and device_mouse_y_to_gui(0) &gt; 179 and device_mouse_y_to_gui(0) &lt; 198)
                or (room != rm_editor and device_mouse_y_to_gui(0) &gt; 210 and device_mouse_y_to_gui(0) &lt; 228)))
                    {
                        if room != rm_editor
                            {
                                pause_lock = 1
                                audio_play_sound(pause_exit,50,false)
                                transition_position = 0
                                transition_active = 1
                                joy_input[2,6] = 30
                                user_access_bar_y_target = 274
                                user_access_bar_y_offset = 274
                            }
                        else
                            scr_set_play_mode();
                    }
                //Go to the Main Menu
                if transition_active = 1
                    {
                        transition_return += 1
                        if transition_return = 21
                            {
                                scr_stop_sounds();
                                transition_active = 0
                                transition_return = 0
                                transition_position = 0
                                yy=0
                                pause = 0
                                pause_lock = 0
                                Jpause[0]=0
                                Jpause[1]=0
                                checkpoint_timer_mil = 0 //Clear millisecond checkpoint
                                checkpoint_timer_sec = 0 //Clear second checkpoint
                                checkpoint_timer_min = 0 //Clear minute checkpoint
                                checkpoint_x = 0         //Clear checkpoint x position
                                checkpoint_y = 0         //Clear checkpoint y position
                                hurt[0] = 0
                                hurt[1] = 0
                                hurt[3] = 0
                                scr_lilac_variables()
                                scr_carol_variables()
                                scr_milla_variables()
                                scr_attack_variables()
                                jump_override = 0
                                Animations_Override = 0
                                active_attack = 0
                                gravity_override = 0
                                breath = breath_max
                                user_access_bar_y_target = 274
                                user_access_bar_y_offset = 274
                                //Reset drown timer
                                alarm_timer = 660
                                audio_stop_sound(snd_drowning)
                                //Stop Carol's Bike's Sounds
                                audio_stop_sound(carol_bike_idle)
                                audio_stop_sound(bike_pitch)
                                audio_stop_sound(carol_bike_moving)
                                audio_stop_sound(carol_bike_skidding)
                                if room = rm_campaign
                                    {
                                        var get_yes = scr_get_restart_map_exceptions_list();
                                        var room_id = rm_title_screen;
                                        if get_yes = 0
                                            room_id = rm_title_screen;
                                        if get_yes = 1
                                            {
                                                if campaign_menu_mode = 3
                                                    room_id = rm_sm_character_select
                                                else
                                                    {
                                                        use_cuts_select = campaign_stage_exit_to
                                                        room_id = rm_campaign
                                                    }
                                            }
                                        if campaign_stage_exit_to = ""
                                            {
                                                room_id = rm_title_screen
                                            }
                                        room_goto(room_id)
                                    }
                                else
                                    room_goto(rm_main_menu);
                            }
                    }
            }
        //Options Menu
        if user_access_bar_y_target = 274 and pause_sub_menu = 1
            {
                var yes = 0;
                //Confirm Press
                if joy_input[1,2] = 1 {yes = 1; pause_sub_menu_button += 1;}
                else                  pause_sub_menu_button = 0;
                //Confirm Left
                if joy_input[0,2] = 1 {yes = 1; pause_sub_menu_left += 1;}
                else                  pause_sub_menu_left = 0;
                //Confirm Right
                if joy_input[0,0] = 1 {yes = 1; pause_sub_menu_right += 1;}
                else                  pause_sub_menu_right = 0;

                //Exit
                if (joy_input[1,0] = 1)
                or (yes = 1 and pause_sub_menu_button = 1 and yy = 120)
                or (joy_mouse_button_switch = 1 and mouse_check_button(joy_mouse_button_left)
                and device_mouse_x_to_gui(0) &gt; 121 and device_mouse_x_to_gui(0) &lt; 388
                and device_mouse_y_to_gui(0) &gt; 196 and device_mouse_y_to_gui(0) &lt; 213
                and pause_sub_menu_timer = 0)
                    {
                        pause_sub_menu = 0
                        yy = 0
                        pause_sub_menu_timer = 8
                        scr_set_save_extended_settings()
                        audio_play_sound(pause_select,50,false)
                    }
                //Menu Selections
                if (yes = 1 or (mouse_check_button_pressed(joy_mouse_button_left)
                and device_mouse_x_to_gui(0) &gt; 121 and device_mouse_x_to_gui(0) &lt; 388))
                and (yy &gt;= 0 and yy &lt; 120) and pause_sub_menu_timer = 0
                    {
                        if (yy = 0 and yes = 1)
                        or (joy_mouse_button_switch = 1)
                            {
                                if (pause_sub_menu_button = 1 or pause_sub_menu_right = 1)
                                or (mouse_check_button_pressed(joy_mouse_button_left)
                                and device_mouse_y_to_gui(0) &gt; 96 and device_mouse_y_to_gui(0) &lt; 113)
                                    {
                                        yy = 0
                                        user_camera_shake_intensity += 0.25
                                        if user_camera_shake_intensity &gt; 1.5
                                            user_camera_shake_intensity = 0;
                                        pause_sub_menu_timer = 8
                                        audio_play_sound(pause_select,50,false)
                                    }
                                if pause_sub_menu_left = 1
                                    {
                                        user_camera_shake_intensity -= 0.25
                                        if user_camera_shake_intensity &lt; 0
                                            user_camera_shake_intensity = 1.5;
                                        pause_sub_menu_timer = 8
                                        audio_play_sound(pause_select,50,false)
                                    }
                            }
                        if (yy = 24 and yes = 1)
                        or (joy_mouse_button_switch = 1)
                            {
                                if (pause_sub_menu_button = 1 or pause_sub_menu_right = 1)
                                or (mouse_check_button_pressed(joy_mouse_button_left)
                                and device_mouse_y_to_gui(0) &gt; 116 and device_mouse_y_to_gui(0) &lt; 133)
                                    {
                                        yy = 24
                                        user_disable_zoom_gimmick += 1
                                        if user_disable_zoom_gimmick &gt; 1
                                            user_disable_zoom_gimmick = 0;
                                        pause_sub_menu_timer = 8
                                        audio_play_sound(pause_select,50,false)
                                    }
                                if pause_sub_menu_left = 1
                                    {
                                        user_disable_zoom_gimmick -= 1
                                        if user_disable_zoom_gimmick &lt; 0
                                            user_disable_zoom_gimmick = 1;
                                        pause_sub_menu_timer = 8
                                        audio_play_sound(pause_select,50,false)
                                    }
                            }
                        if (yy = 48 and yes = 1)
                        or (joy_mouse_button_switch = 1)
                            {
                                if (pause_sub_menu_button = 1 or pause_sub_menu_right = 1)
                                or (mouse_check_button_pressed(joy_mouse_button_left)
                                and device_mouse_y_to_gui(0) &gt; 136 and device_mouse_y_to_gui(0) &lt; 153)
                                    {
                                        yy = 48
                                        user_move_list_display += 1
                                        if user_move_list_display &gt; 1
                                            user_move_list_display = 0;
                                        pause_sub_menu_timer = 8
                                        audio_play_sound(pause_select,50,false)
                                    }
                                if pause_sub_menu_left = 1
                                    {
                                        user_move_list_display -= 1
                                        if user_move_list_display &lt; 0
                                            user_move_list_display = 1;
                                        pause_sub_menu_timer = 8
                                        audio_play_sound(pause_select,50,false)
                                    }
                            }
                        if (yy = 72 and yes = 1)
                        or (joy_mouse_button_switch = 1)
                            {
                                if (pause_sub_menu_button = 1 or pause_sub_menu_right = 1)
                                or (mouse_check_button_pressed(joy_mouse_button_left)
                                and device_mouse_y_to_gui(0) &gt; 156 and device_mouse_y_to_gui(0) &lt; 173)
                                    {
                                        yy = 72
                                        user_enemy_health_display += 1
                                        if user_enemy_health_display &gt; 1
                                            user_enemy_health_display = 0;
                                        pause_sub_menu_timer = 8
                                        audio_play_sound(pause_select,50,false)
                                    }
                                if pause_sub_menu_left = 1
                                    {
                                        user_enemy_health_display -= 1
                                        if user_enemy_health_display &lt; 0
                                            user_enemy_health_display = 1;
                                        pause_sub_menu_timer = 8
                                        audio_play_sound(pause_select,50,false)
                                    }
                            }
                        if (yy = 96 and yes = 1)
                        or (joy_mouse_button_switch = 1)
                            {
                                if (pause_sub_menu_button = 1 or pause_sub_menu_right = 1)
                                or (mouse_check_button_pressed(joy_mouse_button_left)
                                and device_mouse_y_to_gui(0) &gt; 176 and device_mouse_y_to_gui(0) &lt; 193)
                                    {
                                        yy = 96
                                        deadzone_mod += 0.05
                                        if deadzone_mod &gt; 0.95
                                            deadzone_mod = 0;
                                        pause_sub_menu_timer = 8
                                        audio_play_sound(pause_select,50,false)
                                    }
                                if pause_sub_menu_left = 1
                                    {
                                        deadzone_mod -= 0.05
                                        if deadzone_mod &lt; 0
                                            deadzone_mod = 0.95;
                                        pause_sub_menu_timer = 8
                                        audio_play_sound(pause_select,50,false)
                                    }
                            }
                    }
            }

        //=========Character Switching Key=========//
        
        //Only allow changing of characters when they are standing still;
        //switching characters during most actions unique to individual
        //characters can crash the program, or cause visual bugs

        //Detect presses for the special key
        if (joy_input[1,3] = 1) joy_input[2,7] += 1;
        if (joy_input[1,3] = 0) joy_input[2,7]  = 0;

        //Switch characters based on special key iterations
        if (joy_input[2,7] = 1) and debug_hud = 0
            {
                switch(debug_character_position)
                    {
                        //Switch to Lilac
                        case 0: {scr_set_lilac(); alt_skin = 0; break;}
                        //Switch to Carol
                        case 1: {scr_set_carol(); alt_skin = 0; break;}
                        //Switch to Milla
                        case 2: {scr_set_milla(); alt_skin = 0; break;}
                        //Switch to Spade
                        case 3: {scr_set_spade(); alt_skin = 0; break;}
                        //Switch to Carrie
                        case 4: {alt_skin = 1; scr_set_carol(); scr_set_carrie(); break;}
                        //Switch to Chiasa
                        case 5: {alt_skin = 2; scr_set_carol(); scr_set_chiasa(); break;}
                    }
                debug_character_position += 1;
                //Reset character iterations if we are scrolling beyond the range of the character roster
                if (debug_character_position &gt; 5 or debug_character_position &lt; 0) debug_character_position = 0;
                //Play sound effect
                audio_play_sound(pause_select,50,false)
            }
        if (joy_input[1,4] = 1) and (skin = spr_carol and alt_skin != 1) and debug_hud = 0
            {
                scr_set_carol();
                if alt_skin = 0 scr_set_carols_bike();
                if alt_skin = 2
                    {
                        alt_skin = 2;
                        scr_set_chiasa();
                        scr_set_carols_bike();
                        lives_spr = 10
                        my_pal_sprite = spr_chiasa_palette
                        ui_pal_sprite = spr_chiasa_palette
                        snd_player_hurt_0 = snd_carrie_hurt_1    //Hurt Sound 1
                        snd_player_hurt_1 = snd_carrie_hurt_2    //Hurt Sound 2
                        snd_player_death  = snd_carrie_death     //Death Sound
                        push_sound = snd_carrie_attack_leap
                        swimming_frame = anim_carol[anim_swimming,0]
                    }
                if !audio_is_playing(carol_gas_can)
                    audio_play_sound(carol_gas_can,50,false);
            }

    }

//Press the Start Button
if joy_input[2,0] = 1 and death[0] = 0 and user_cursor_mode = 0 and targets_ready = 0
    {
        //Increment Pause Input
        Jpause[0]+=1
        //Increment Pause State
        if Jpause[0] = 1 Jpause[1] += 1;
        switch(Jpause[1])
            {
                //Pause the game
                case 1:
                    {
                        if pause = 0
                            {
                                pause = 1
                                pause_lock = 8
                                joy_input[1,2] = 0
                                pause_sub_menu = 0
                                if yy &gt; 24 yy = 0;
                                user_access_bar_y_target = 274
                                user_access_bar_y_offset = 274
                                pause_potion_menu_offset = -32
                                pause_potion_menu_select = 0
                                pause_potion_menu_alpha = 0
                                pause_potion_menu_left = 0
                                pause_potion_menu_right = 0
                                pause_potion_menu_select = 0
                                pause_potion_menu_accept = 0
                                pause_sub_menu_transition = 0
                                //Clip potion count to a specific amount if exploits were
                                //used to get above that amount
                                if potion_petal_potion &gt; 10
                                    potion_petal_potion = 10;
                                if potion_petal_core &gt; 2
                                    potion_petal_core = 2;
                                if potion_stamina_drink &gt; 10
                                    potion_stamina_drink = 10;
                                if potion_stamina_core &gt; 2
                                    potion_stamina_core = 2;
                                if potion_feather_potion &gt; 2
                                    potion_feather_potion = 2;
                                if potion_mystery_potion &gt; 12
                                    potion_mystery_potion = 12;
                                instance_destroy(obj_pause_fade)
                                instance_create(x,y,obj_pause_fade)
                                audio_play_sound(pause_jingle,50,false);
                                scr_pause_sounds();
                            }
                        break;
                    }
                //Unpause the game
                case 2:
                    {
                        pause = 0
                        Jpause[1]=0
                        pause_lock = 0
                        pause_sub_menu = 0
                        user_access_bar_y_target = 274
                        user_access_bar_y_offset = 274
                        pause_potion_menu_offset = -32
                        pause_potion_menu_select = 0
                        pause_potion_menu_alpha = 0
                        pause_potion_menu_left = 0
                        pause_potion_menu_right = 0
                        pause_potion_menu_select = 0
                        pause_potion_menu_accept = 0
                        scr_resume_sounds();
                        break;
                    }
            }

    }
//If we have released the start button, reset input incrementer
if joy_input[2,0] = 0 Jpause[0] = 0;

} //End Play Mode Check

//Unlock all inputs if the input lock timer is reset
if joy_input[2,6] = 0
{

//==================Collect Input From the Keyboard==================//

//If The Keyboard Is Assigned For Input, Read The Keyboard For Inputs
if joy_input[2,1] = 0
    {
        //D-Pad Movement
        joy_input[0,0] = keyboard_check(key_right)  //Joystick Right
        joy_input[0,1] = keyboard_check(key_down)   //Joystick Down
        joy_input[0,2] = keyboard_check(key_left)   //Joystick Left
        joy_input[0,3] = keyboard_check(key_up)     //JoyStick Up
        //Player Actions
        joy_input[1,0] = keyboard_check(key_a)      //Joystick A (Attack)
        joy_input[1,2] = keyboard_check(key_b)      //Joystick B (Jump)
        joy_input[1,3] = keyboard_check(key_c)      //Joystick C (Special)
        joy_input[1,4] = keyboard_check(key_d)      //Joystick D "Select"
        joy_input[2,0] = keyboard_check(key_start)  //Joystick "Start"
        //Lock the use of the enter key when invoking alt right for fullscreen mode toggle
        if keyboard_check_direct(vk_ralt) and key_start = 13 joy_input[2,0] = 0;

        if mouse_check_button(mb_left)
            {
                if room != rm_editor
                    {
                        if joy_mouse_button_switch = 0
                            {
                                joy_mouse_button_busy_timer += 1
                                joy_mouse_button_busy_angle += 4
                                if joy_mouse_button_busy_timer &gt; 16
                                    {
                                        if use_menu = 0 and user_cursor_mode = 0
                                            {
                                                joy_mouse_button_flash = 1;
                                                joy_mouse_button_alpha = 1;
                                            }
                                        joy_mouse_button_switch = 1;
                                        joy_mouse_button_busy_timer = 0;
                                    }
                            }
                    }
            }
        //Mouse Movement
        if joy_mouse_button_switch = 1
            {
                if room = rm_editor and user_cursor_mode = 1
                    scr_set_mouse_mode_off(0);
                if gamepad_is_connected(joy_modern_id)
                    {
                        //Check Controller's Action Buttons
                        if gamepad_button_check(joy_modern_id,joy_a_mod) = 1
                        or gamepad_button_check(joy_modern_id,joy_b_mod) = 1
                        or gamepad_button_check(joy_modern_id,joy_c_mod) = 1
                        or gamepad_button_check(joy_modern_id,joy_d_mod) = 1
                        or gamepad_button_check(joy_modern_id,joy_start_mod) = 1
                            scr_set_mouse_mode_off(0);
                    }
                if joy_mouse_button_cooldown &gt; 0
                    joy_mouse_button_cooldown -= 1;
                joy_input[1,5] = 0  //Joystick Proxy For "Start"
                if pause = 0 and user_cursor_mode = 0
                    {
                        if shop_menu_movement_override = 0
                            {
                                if (device_mouse_y_to_gui(0) &lt;= 37-mouse_deadzone_up)     joy_input[0,3] = 1; //Joystick Up
                                if (device_mouse_x_to_gui(0) &lt;= 185-mouse_deadzone_left)  joy_input[0,2] = 1; //Joystick Left
                                if (device_mouse_y_to_gui(0) &gt;= 202+mouse_deadzone_down)  joy_input[0,1] = 1; //Joystick Down
                                if (device_mouse_x_to_gui(0) &gt;= 240+mouse_deadzone_right) joy_input[0,0] = 1; //Joystick Right
                            }
                        //Mouse Left
                        if (mouse_check_button(mb_left))
                            joy_input[1,mouse_left] = 1;
                        //Mouse Right
                        if (mouse_check_button(mb_right))
                            joy_input[1,mouse_right] = 1;
                        //Middle Button
                        if (mouse_check_button(mb_middle))
                            joy_input[1,mouse_middle] = 1;
                        //Wheel Down
                        if mouse_wheel_down()
                            joy_input[1,mouse_scroll_down] = 1;
                        //Wheel Up
                        if mouse_wheel_up() joy_input[1,mouse_scroll_up] = 1;
                        //Press Start If Proxy Was Pressed
                        if joy_input[1,5] = 1 joy_input[2,0] = 1;
                    }
                //Mouse Cursor Animation
                joy_mouse_button_frame += 0.25
                if joy_mouse_button_frame &gt; 5.8
                    joy_mouse_button_frame = 0;
                //Flash Mouse Directions HUD
                if joy_mouse_button_flash &gt; 0
                    {
                        joy_mouse_button_flash += 1
                        if joy_mouse_button_flash = 16 joy_mouse_button_alpha = 0;
                        if joy_mouse_button_flash = 32 joy_mouse_button_alpha = 1;
                        if joy_mouse_button_flash = 48 joy_mouse_button_alpha = 0;
                        if joy_mouse_button_flash = 64 joy_mouse_button_alpha = 1;
                        if joy_mouse_button_flash &gt; 80
                            {
                                joy_mouse_button_flash = 0;
                                joy_mouse_button_alpha = 0;
                            }
                    }
            }

        //Disable in-game actions when hurt
        if (pause = 0 and (hurt[1] = 1 or hurt[1] &gt;= 32))
            {
                joy_input[0,0] = 0 joy_input[0,1] = 0 joy_input[0,2] = 0 joy_input[0,3] = 0
                joy_input[1,0] = 0 joy_input[1,2] = 0 joy_input[1,3] = 0 joy_input[1,4] = 0
            }
    } //End of Keyboard Check

//==================Collect Input From the Joystick==================//

//If A Modern Joystick Is Assigned For Input, Read The Joystick For Inputs
if joy_input[2,1] = 1
    {
        //If a modern joystick is not assigned for input, disable joystick inputs
        if not gamepad_is_connected(joy_modern_id)
            {
                //D-Pad Movement
                joy_input[0,0] = 0  //Joystick Right
                joy_input[0,1] = 0  //Joystick Down
                joy_input[0,2] = 0  //Joystick Left
                joy_input[0,3] = 0  //JoyStick Up
                //Player Actions
                joy_input[1,0] = 0  //Joystick A (Attack)
                joy_input[1,2] = 0  //Joystick B (Jump)
                joy_input[1,3] = 0  //Joystick C (Special)
                joy_input[1,4] = 0  //Joystick D "Select"
                joy_input[2,0] = 0  //Joystick "Start"
            }
        else
            {
                //D-Pad Movement
                joy_input[0,0] = gamepad_button_check(joy_modern_id,joy_right_mod)  //Joystick Right
                joy_input[0,1] = gamepad_button_check(joy_modern_id,joy_down_mod)   //Joystick Down
                joy_input[0,2] = gamepad_button_check(joy_modern_id,joy_left_mod)   //Joystick Left
                joy_input[0,3] = gamepad_button_check(joy_modern_id,joy_up_mod)     //JoyStick Up

                //Clear Action Variables
                joy_input[1,0] = 0 joy_input[1,2] = 0 joy_input[1,3] = 0 joy_input[2,0] = 0

                //Player Actions
                joy_input[1,0] = gamepad_button_check(joy_modern_id,joy_a_mod)         //Joystick A (Attack)
                joy_input[1,2] = gamepad_button_check(joy_modern_id,joy_b_mod)         //Joystick B (Jump)
                joy_input[1,3] = gamepad_button_check(joy_modern_id,joy_c_mod)         //Joystick C (Special)
                joy_input[1,4] = gamepad_button_check(joy_modern_id,joy_d_mod)         //Joystick D "Select"
                joy_input[2,0] = gamepad_button_check(joy_modern_id,joy_start_mod)     //Joystick "Start"

                //If Analog Hotkeys Are Enabled, Perform Actions Based On Inputs
                if enable_hotkeys = 1
                    {
                        //Left Analog Stick
                        if (gamepad_axis_value(joy_modern_id,gp_axislh) &lt; -deadzone_mod) scr_set_hotkey(left_stick_left);
                        if (gamepad_axis_value(joy_modern_id,gp_axislh) &gt;  deadzone_mod) scr_set_hotkey(left_stick_right);
                        if (gamepad_axis_value(joy_modern_id,gp_axislv) &lt; -deadzone_mod) scr_set_hotkey(left_stick_up);
                        if (gamepad_axis_value(joy_modern_id,gp_axislv) &gt;  deadzone_mod) scr_set_hotkey(left_stick_down);
                        //Right Analog Stick
                        if (gamepad_axis_value(joy_modern_id,gp_axisrh) &lt; -deadzone_mod) scr_set_hotkey(right_stick_left);
                        if (gamepad_axis_value(joy_modern_id,gp_axisrh) &gt;  deadzone_mod) scr_set_hotkey(right_stick_right);
                        if (gamepad_axis_value(joy_modern_id,gp_axisrv) &lt; -deadzone_mod) scr_set_hotkey(right_stick_up);
                        if (gamepad_axis_value(joy_modern_id,gp_axisrv) &gt;  deadzone_mod) scr_set_hotkey(right_stick_down);
                    }
                //Disable in-game actions when hurt
                if (pause = 0 and (hurt[1] = 1 or hurt[1] &gt;= 32))
                    {
                        joy_input[0,0] = 0 joy_input[0,1] = 0 joy_input[0,2] = 0 joy_input[0,3] = 0
                        joy_input[1,0] = 0 joy_input[1,2] = 0 joy_input[1,3] = 0 joy_input[1,4] = 0
                    }
            }
    } //End of Joystick Check

} //End of Input Lock Check
else
    {
        //D-Pad Movement
        joy_input[0,0] = 0  //Joystick Right
        joy_input[0,1] = 0  //Joystick Down
        joy_input[0,2] = 0  //Joystick Left
        joy_input[0,3] = 0  //JoyStick Up
        //Player Actions
        joy_input[1,0] = 0  //Joystick A (Attack)
        joy_input[1,2] = 0  //Joystick B (Jump)
        joy_input[1,3] = 0  //Joystick C (Special)
        joy_input[1,4] = 0  //Joystick D "Select"
        joy_input[2,0] = 0  //Joystick "Start"
    }

//Do Not Allow the Player to Use the Jump Button Unless They Let Go of It
if pause_lock &gt; 0
    {
        //Check the Jump Button and Jump Key
        var joy_pad_b = gamepad_button_check(joy_modern_id,joy_b_mod)
        var joy_key_b = keyboard_check(key_b)

        //Disable the Pause Lock If the Player Has Let Go of the Jump Button
        if joy_pad_b = 0 and joy_key_b = 0 pause_lock = 0;
        //Keep the Jump Button and Jump Key Disabled If The Player Is Still Pressing It
        else joy_input[1,2] = 0;
    }

//Disable the Jump Button If the Player Hasn't Let Go of It Yet
if pause_lock &gt; 0 and joy_input[1,0] = 1 joy_input[1,0] = 0;

//==============================//
//        Debug Switches        //
//==============================//

if debug_hud = 0
    {
        //=========Character Switching Keys=========//

        //Switch To Lilac
        if keyboard_check_pressed(49)
            {
                alt_skin += 1
                if skin != spr_lilac
                    alt_skin = 0;
                if alt_skin &gt; 2
                    {
                        lives_spr = 0
                        alt_skin = 0
                    }
                scr_set_lilac();
                if skin = spr_lilac
                    {
                        if alt_skin = 1 lives_spr = 6;
                        if alt_skin = 2 lives_spr = 11;
                    }
                else
                    alt_skin = 0;
            }
        //Switch To Carol
        if keyboard_check_pressed(50)
            {
                alt_skin = 0
                scr_set_carol()
            }
        //Switch To Milla
        if keyboard_check_pressed(51)
            {
                alt_skin += 1
                if skin != spr_milla
                    alt_skin = 0;
                scr_set_milla();
                if alt_skin &gt; 1
                    alt_skin = 0;
            }
        //Switch To Spade
        if keyboard_check_pressed(52) {scr_set_spade(); alt_skin = 0;}
        //Switch to Carrie
        if keyboard_check_pressed(53) {alt_skin = 1; scr_set_carrie();}
        //Switch to Chiasa
        if keyboard_check_pressed(54) {alt_skin = 2; scr_set_chiasa();}
        //Switch To Carol's Bike
        if keyboard_check_pressed(55)
            {
                if alt_skin = 0
                    {
                        scr_set_carol(); scr_set_carols_bike(); alt_skin = 0;
                    }
                if alt_skin = 2
                    {
                        alt_skin = 2;
                        scr_set_chiasa();
                        scr_set_carols_bike();
                        lives_spr = 10
                        my_pal_sprite = spr_chiasa_palette
                        ui_pal_sprite = spr_chiasa_palette
                        snd_player_hurt_0 = snd_carrie_hurt_1    //Hurt Sound 1
                        snd_player_hurt_1 = snd_carrie_hurt_2    //Hurt Sound 2
                        snd_player_death  = snd_carrie_death     //Death Sound
                        push_sound = snd_carrie_attack_leap
                        swimming_frame = anim_carol[anim_swimming,0]
                    }
            }    }//End of Debug Mode Safety Check
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///HUD Elements and Instance Management 

//===============Weather Conditions===============//
if (pause = 0 and user_cursor_mode = 0)
or (room = rm_editor)
    {
        if use_weather_conditions &gt; 0
            {
                //Rain Effects
                switch(use_weather_conditions)
                    {
                        case 1:  {if pause = 0 {use_weather_fade_target = 0.35; use_weather_y_0 += 8; use_weather_timer += 0.25;} break;}
                        case 2:  {if pause = 0 {use_weather_fade_target = 0.50; use_weather_y_0 += 16; use_thunder_timer += 1; use_weather_timer += 0.35;} break;}
                        case 3:
                            {
                                if pause = 0
                                    {
                                        use_weather_fade_target = 0.65
                                        use_weather_timer += 0.50
                                        if use_weather_direction = 0
                                            {
                                                use_weather_x_0 -= 16;
                                            }
                                        if use_weather_direction = 1
                                            {
                                                use_weather_x_0 += 16;
                                            }
                                        use_weather_y_0 += 24
                                        use_thunder_timer += 1
                                        //Only create flood balls if we are above water
                                        if view_yview[view_port] &lt; water_height
                                        and instance_number(obj_flood_ball) &lt; 16
                                            {
                                                use_flood_timer += 1
                                                if use_flood_timer = 8
                                                    {
                                                        instance_create(view_xview[view_port]+(view_wview[view_port]/2),view_yview[view_port],obj_flood_ball)
                                                        //instance_create(view_xview[view_port]+(view_wview[view_port]*0.75),view_yview[view_port],obj_flood_ball)
                                                    }
                                                if use_flood_timer = 12
                                                    {
                                                        instance_create(view_xview[view_port]+view_wview[view_port]-64,view_yview[view_port],obj_flood_ball)
                                                        //instance_create(view_xview[view_port]+(view_wview[view_port]*0.35),view_yview[view_port],obj_flood_ball)
                                                    }
                                                if use_flood_timer = 16
                                                    {
                                                        instance_create(view_xview[view_port]+64,view_yview[view_port],obj_flood_ball)
                                                        use_flood_timer = 0
                                                    }
                                            }
                                    }
                                break;
                            }
                        case 4:  {if pause = 0 {use_weather_fade_target = 0.35; use_weather_y_0 += 8; use_weather_timer += 0.25;} break;}
                        case 5:  {if pause = 0 {use_weather_fade_target = 0.35; use_weather_y_0 += 8; use_weather_timer += 0.25;} break;}
                        default: {use_weather_fade_target = 0; break;}
                    }
                if use_thunder_timer &gt; 240
                    {
                        audio_play_sound(snd_thunder,50,false)
                        use_thunder_timer = 0
                        use_thunder_fade_effect = 0.15
                        use_thunder_fade_target = 0
                        use_weather_direction += 1
                        if use_weather_direction &gt; 1
                            use_weather_direction = 0;
                    }
                //Reset Rain Offsets
                if use_weather_x_0 &lt; -240
                or use_weather_x_0 &gt; 240
                    use_weather_x_0 = 0;
                if use_weather_y_0 &gt;= 240
                    use_weather_y_0 = 0;
                //Splatter Animations
                if use_weather_timer &gt; 8.8
                    use_weather_timer = 5;
            }
        else
            {
                use_weather_fade_target = 0;
                use_weather_direction = 0
            }
        use_weather_fade_effect = lerp(use_weather_fade_effect,use_weather_fade_target,0.15);
        use_thunder_fade_effect = lerp(use_thunder_fade_effect,use_thunder_fade_target,0.10);
    }

//Pause Safety Check
if pause = 0 and user_cursor_mode = 0

{

//Time Counter (Don't count time if we are dead)
if timer_stop = 0 hud_timer_mil+=1.66666666666666666666666666666;
if hud_timer_mil&gt;99 {hud_timer_sec+=1 hud_timer_mil=0}
if hud_timer_sec&gt;59
    {
        hud_timer_min+=1
        hud_timer_sec=0
        if story_mode = 1
            player_play_time[player_current] += 1;
    }
if hud_timer_min&gt;99 {hud_timer_min=99}

//===========Player Logic Freeze Frame Timer===========//

//Stage 2 of pause gap
if pause_logic_gap = 2 pause_logic_gap = 0;

//Stage 1 of pause gap
if pause_logic_gap = 1 pause_logic_gap = 2;

//Decrement freeze frames
if pause_logic &gt; 0 and pause = 0 and pause_logic_gap = 0
    {
        if user_turbo_mode = 1 and pause_logic &gt; 3 pause_logic = 3;
        pause_logic -=1;
        //If we have fully counted down from five frames, initiate stage 1 of pause gap
        if pause_logic &lt;= 0 pause_logic_gap = 1;
        if user_combat_freeze_frame = 0 and pause_logic &gt; 3
            pause_logic = 1;
    }

if milla_pause_logic &gt; 0 milla_pause_logic -= 1;

//=================HUD Offset Handler=================//

//Reveal the HUD if we have started the stage
if (HUD_offset!=0 and death[0] = 0 and transition_alpha &lt;= 0 and targets_ready != 3) HUD_offset+=1;
//Return the HUD to its starting position if we have died
if (HUD_offset&gt;-56 and death[0] = 1) or (targets_ready = 3) HUD_offset-=1;

//================Stamina Bar Shimmer=================//

//Animation Timer for Stamina Bar Shimmer
shine_frame += 0.32

if shine_frame&gt;16 shine_frame = 0;

//Flash Stamina Bar When Health Petals Are Low
if petals &lt; 1
    {
        hud_flash+=0.2
        
        if hud_flash &gt;= 2 hud_flash = 0;
    }
else hud_flash = 0;

//==================Stamina Booster===================//

if speed_boosted_timer != 0
    {
        speed_boosted_timer -= 0.0075
        speed_boosted_target_timer += 1
        stamina+=0.8
        hud_bar_asset = spr_hud_bar_boosted
        hud_bar_asset_alt = spr_hud_bar_alt_boosted
        if speed_boosted_timer &lt; 1
            {
                speed_boosted_timer = 0
                hud_bar_asset = spr_hud_bar
                hud_bar_asset_alt = spr_hud_bar_alt
            }
        if speed_boosted_target_timer &gt; 3
            {
                speed_boosted_alpha += 1
                if speed_boosted_alpha &gt; 1 speed_boosted_alpha = 0;
                speed_boosted_target_timer = 0
            }
    }

//====================Feather Potion====================//

if potion_feather_timer &gt; 0
    {
        potion_feather_timer -= 0.0075
    }

//====================Mystery Potion====================//

if potion_mystery_timer &gt; 0
    {
        potion_mystery_timer -= 0.0075
        //Apply Mystery Effects
        switch(potion_mystery_effect)
            {
                //Change Camera Angle Based On Tile Angle; Only Enable For Recording Memes :^P
                case 0: {view_angle[view_port] = -angle_a; break;}
                case 1: {view_angle[view_port] = -180; break;}
            }
        //Stop Applying Rain Effects
        if potion_mystery_effect &gt;= 2 and potion_mystery_effect &lt;= 5
            {
                if potion_mystery_timer &lt; 1 and use_weather_conditions = 1
                    {
                        audio_stop_sound(snd_rain)
                        audio_stop_sound(snd_tempest)
                        use_weather_conditions = 0
                    }
            }
    }

//================Gem Particle Effect=================//

if gem_particle_trigger = 1 and performance_profile = 1
and debug_hud = 1
    {
        //Particle 1
        if gem_particle_trig_0 = 1
            {
                //Iterate Animation Frames
                if (gem_particle_frame_0 &gt; 5) {gem_particle_frame_0 = 5; gem_waiting_0 = 1;}
                else                          gem_particle_frame_0+=0.16;
                //Increment timer, and lower transparency
                if gem_waiting_0 = 1 {gem_ispeed_0+=1; gem_particle_alpha_0-=0.05;}
                //Destroy Self After Timer Is Finished
                if gem_particle_alpha_0&lt;0 gem_particle_trig_0 = 0;
            }
        //Particle 2
        if gem_particle_trig_1 = 1
            {
                //Iterate Animation Frames
                if (gem_particle_frame_1 &gt; 5) {gem_particle_frame_1 = 5; gem_waiting_1 = 1;}
                else                          gem_particle_frame_1+=0.16;
                //Increment timer, and lower transparency
                if gem_waiting_1 = 1 {gem_ispeed_1+=1; gem_particle_alpha_1-=0.05;}
                //Destroy Self After Timer Is Finished
                if gem_particle_alpha_1&lt;0 gem_particle_trig_1 = 0;
            }
        //Particle 3
        if gem_particle_trig_2 = 1
            {
                //Iterate Animation Frames
                if (gem_particle_frame_2 &gt; 5) {gem_particle_frame_2 = 5; gem_waiting_2 = 1;}
                else                          gem_particle_frame_2+=0.16;
                //Increment timer, and lower transparency
                if gem_waiting_2 = 1 {gem_ispeed_2+=1; gem_particle_alpha_2-=0.05;}
                //Destroy Self After Timer Is Finished
                if gem_particle_alpha_2&lt;0 gem_particle_trig_2 = 0;
            }
        //Particle 4
        if gem_particle_trig_3 = 1
            {
                //Iterate Animation Frames
                if (gem_particle_frame_3 &gt; 5) {gem_particle_frame_3 = 5; gem_waiting_3 = 1;}
                else                          gem_particle_frame_3+=0.16;
                //Increment timer, and lower transparency
                if gem_waiting_3 = 1 {gem_ispeed_3+=1; gem_particle_alpha_3-=0.05;}
                //Destroy Self After Timer Is Finished
                if gem_particle_alpha_3&lt;0 gem_particle_trig_3 = 0;
            }
        //Particle 5
        if gem_particle_trig_4 = 1
            {
                //Iterate Animation Frames
                if (gem_particle_frame_4 &gt; 5) {gem_particle_frame_4 = 5; gem_waiting_4 = 1;}
                else                          gem_particle_frame_4+=0.16;
                //Increment timer, and lower transparency
                if gem_waiting_4 = 1 {gem_ispeed_4+=1; gem_particle_alpha_4-=0.05;}
                //Destroy Self After Timer Is Finished
                if gem_particle_alpha_4&lt;0 gem_particle_trig_4 = 0;
            }
        //Particle 6
        if gem_particle_trig_5 = 1
            {
                //Iterate Animation Frames
                if (gem_particle_frame_5 &gt; 5) {gem_particle_frame_5 = 5; gem_waiting_5 = 1;}
                else                          gem_particle_frame_5+=0.16;
                //Increment timer, and lower transparency
                if gem_waiting_5 = 1 {gem_ispeed_5+=1; gem_particle_alpha_5-=0.05;}
                //Destroy Self After Timer Is Finished
                if gem_particle_alpha_5&lt;0 gem_particle_trig_5 = 0;
            }
        //Particle 7
        if gem_particle_trig_6 = 1
            {
                //Iterate Animation Frames
                if (gem_particle_frame_6 &gt; 5) {gem_particle_frame_6 = 5; gem_waiting_6 = 1;}
                else                          gem_particle_frame_6+=0.16;
                //Increment timer, and lower transparency
                if gem_waiting_6 = 1 {gem_ispeed_6+=1; gem_particle_alpha_6-=0.05;}
                //Destroy Self After Timer Is Finished
                if gem_particle_alpha_6&lt;0 gem_particle_trig_6 = 0;
            }
        //Particle 8
        if gem_particle_trig_7 = 1
            {
                //Iterate Animation Frames
                if (gem_particle_frame_7 &gt; 5) {gem_particle_frame_7 = 5; gem_waiting_7 = 1;}
                else                          gem_particle_frame_7+=0.16;
                //Increment timer, and lower transparency
                if gem_waiting_7 = 1 {gem_ispeed_7+=1; gem_particle_alpha_7-=0.05;}
                //Destroy Self After Timer Is Finished
                if gem_particle_alpha_7&lt;0 gem_particle_trig_7 = 0;
            }
        //Particle 9
        if gem_particle_trig_8 = 1
            {
                //Iterate Animation Frames
                if (gem_particle_frame_8 &gt; 5) {gem_particle_frame_8 = 5; gem_waiting_8 = 1;}
                else                          gem_particle_frame_8+=0.16;
                //Increment timer, and lower transparency
                if gem_waiting_8 = 1 {gem_ispeed_8+=1; gem_particle_alpha_8-=0.05;}
                //Destroy Self After Timer Is Finished
                if gem_particle_alpha_8&lt;0 gem_particle_trig_8 = 0;
            }
        //Particle 10
        if gem_particle_trig_9 = 1
            {
                //Iterate Animation Frames
                if (gem_particle_frame_9 &gt; 5) {gem_particle_frame_9 = 5; gem_waiting_9 = 1;}
                else                          gem_particle_frame_9+=0.16;
                //Increment timer, and lower transparency
                if gem_waiting_9 = 1 {gem_ispeed_9+=1; gem_particle_alpha_9-=0.05;}
                //Destroy Self After Timer Is Finished
                if gem_particle_alpha_9&lt;0 gem_particle_trig_9 = 0;
            }
        //Particle 11
        if gem_particle_trig_10 = 1
            {
                //Iterate Animation Frames
                if (gem_particle_frame_10 &gt; 5) {gem_particle_frame_10 = 5; gem_waiting_10 = 1;}
                else                           gem_particle_frame_10+=0.16;
                //Increment timer, and lower transparency
                if gem_waiting_10 = 1 {gem_ispeed_10+=1; gem_particle_alpha_10-=0.05;}
                //Destroy Self After Timer Is Finished
                if gem_particle_alpha_10&lt;0 gem_particle_trig_10 = 0;
            }
        //Particle 12
        if gem_particle_trig_11 = 1
            {
                //Iterate Animation Frames
                if (gem_particle_frame_11 &gt; 5) {gem_particle_frame_11 = 5; gem_waiting_11 = 1;}
                else                           gem_particle_frame_11+=0.16;
                //Increment timer, and lower transparency
                if gem_waiting_11 = 1 {gem_ispeed_11+=1; gem_particle_alpha_11-=0.05;}
                //Destroy Self After Timer Is Finished
                if gem_particle_alpha_11&lt;0 gem_particle_trig_11 = 0;
            }
        //Particle 13
        if gem_particle_trig_12 = 1
            {
                //Iterate Animation Frames
                if (gem_particle_frame_12 &gt; 5) {gem_particle_frame_12 = 5; gem_waiting_12 = 1;}
                else                           gem_particle_frame_12+=0.16;
                //Increment timer, and lower transparency
                if gem_waiting_12 = 1 {gem_ispeed_12+=1; gem_particle_alpha_12-=0.05;}
                //Destroy Self After Timer Is Finished
                if gem_particle_alpha_12&lt;0 gem_particle_trig_12 = 0;
            }
        //Particle 14
        if gem_particle_trig_13 = 1
            {
                //Iterate Animation Frames
                if (gem_particle_frame_13 &gt; 5) {gem_particle_frame_13 = 5; gem_waiting_13 = 1;}
                else                           gem_particle_frame_13+=0.16;
                //Increment timer, and lower transparency
                if gem_waiting_13 = 1 {gem_ispeed_13+=1; gem_particle_alpha_13-=0.05;}
                //Destroy Self After Timer Is Finished
                if gem_particle_alpha_13&lt;0 gem_particle_trig_13 = 0;
            }
        //Disable Drawing of Gem Particles, if None Are Actively Drawing
        if  gem_particle_trig_0  = 0 and gem_particle_trig_1  = 0 and gem_particle_trig_2 = 0
        and gem_particle_trig_3  = 0 and gem_particle_trig_4  = 0 and gem_particle_trig_5 = 0
        and gem_particle_trig_6  = 0 and gem_particle_trig_7  = 0 and gem_particle_trig_8 = 0
        and gem_particle_trig_9  = 0 and gem_particle_trig_10 = 0 and gem_particle_trig_11 = 0
        and gem_particle_trig_12 = 0 and gem_particle_trig_13 = 0
            {
                gem_plus_pos = 0
                gem_particle_trigger = 0
            }
    }

//================Stamina Bar Counter=================//

//Increment Stamina Value, Unless Attacks Are Using The Stamina Bar
if stamina_pause = 0 and stamina &lt; 100
    {
        stamina+=0.4
        stamina_boosted = 0
        if user_turbo_mode = 1 stamina+=0.4;
    }
//Reset Stamina To 100% If Value Is Too High
if stamina&gt;=100
    {
        if stamina_boosted = 0 stamina = 100;
        if stamina_boosted = 1 and stamina &gt; 150 stamina = 150;
        //Increment Stamina Flash Timer
        stamina_confirm += 1
    }
//Reset Stamina Flash Timer If Value Is Too Low
if stamina&gt;0 and stamina&lt;100 stamina_confirm = stamina_gem;
//Raise Stamina Bar Above 0 If An Attack Is Drawing Too Much
if stamina &lt; 0 stamina = 0;
//Flash stamina bar again if we have collected a gem
if stamina_gem_con = 1
    {
        //Increment Stamina Flash Timer
        stamina_gem += 1
        //Rest Flash Timer Values After Several Frames
        if stamina_gem &gt; 7
            {
                stamina_gem = 0
                stamina_gem_con = 0
            }
    }

//================Health Regen Counter=================//

if user_regen_health = 1
or potion_petal_timer &gt; 0
    {
        user_regen_health_timer += 1

        if (user_regen_health_timer = 120)
            {
                petals += 1;
                if petals &gt; petalsmax petals = petalsmax;
                user_regen_health_timer = 0
                if potion_petal_timer &gt; 0
                    potion_petal_timer -= 1;                    
            }
    }

//=============Underwater Breathing Timer=============//

//If the player is underwater, display the air bar and countdown
if (above_water = 0) and death[0] = 0
    {
        //Sequentially lower breath values
        if breath &gt; 1.5 or (shield != spr_shield_water and shield_active = 1) breath-=breath_modifier;
        //Flash breath timer when running low on air
        if breath &lt;= 1.5
            {
                if breath&lt;0 breath = 1.5;
                breath-=0.5
            }
        //If we are using a water shield, keep breath at 100%
        if shield=spr_shield_water and shield_active = 1
        //Or only standing slightly inside the global body of water
        or (py &lt; water_height+24 and !instance_exists(water_ID))
            breath=breath_max;
        //Offset air bar until it's in place
        if breath_offset&lt;16 breath_offset += 1;
        //Spawn health petal if we are inside a petal pool
        var petal_ID = collision_point(universal_player_x,universal_player_y,obj_smart_petal_pool,false,true);
        if instance_exists(petal_ID)
            {
                petal_heal_timer += 1
                if petal_heal_timer = 60
                    {
                        instance_create(universal_player_x,universal_player_y,obj_petal_pickup)
                        petal_heal_timer = 0
                    }
            }
        else
            petal_heal_timer = 0
    }
//Otherwise, refresh the air bar
else
    {
        breath = breath_max
        petal_heal_timer = 0
        //Slide the air bar out of view
        if breath_offset&gt;-14 breath_offset -= 1;
        //Reset drown timer
        alarm_timer = 660;
        //Disable audio playback
        if audio_is_playing(snd_drowning) audio_stop_sound(snd_drowning);
    }

//===============Underwater Drown Timer===============//

if (breath&lt;=1.5 and death[0] = 0)
    {
        //Subtract from the timer
        if alarm_timer &gt; 0 alarm_timer -= 1;
        //Shake the sprite
        alarm_shake_x = random_range(-1,1)
        alarm_shake_y = random_range(-1,1)
        //Advance the alarm's frames, and play sounds
        switch(alarm_timer)
            {
                //Death State
                case   0:
                    {
                        //Do not drown if we are in the level editor
                        if room != rm_editor
                            {
                                //Activate death trigger
                                death[0] = 1
                                //Subtract one life from the lives counter
                                lives -= 1
                                //Reset transition timer's variable if it wasn't reset previously
                                transition_timer = 0
                                //Reset transition color's transparency if it wasn't reset previously
                                transition_alpha = 0
                                //Play drowned sound
                                audio_play_sound(snd_drowned,50,false);
                            }
                        //Otherwise, refresh air bar
                        else
                            {
                                breath = breath_max
                                //Reset drown timer
                                alarm_timer = 660;
                            }
                        break;
                    }
                case 180:   {alarm_frame += 1; break;}
                case 240:   {alarm_frame += 1; break;}
                case 300:   {alarm_frame += 1; break;}
                case 360:   {alarm_frame += 1; break;}
                case 420:   {alarm_frame += 1; break;}
                case 480:   {alarm_frame += 1; break;}
                case 540:   {alarm_frame += 1; break;}
                case 600:   {alarm_frame += 1; break;}
                case 659:   {audio_play_sound(snd_drowning,50,false); break;}
            }
    }

//================Invincibility Timer================//

if invuln_hud_time &gt; 0
    {
        //Decrement Invincibility Timer
        invuln_hud_time -= 1
        //Set the invincibility icon to flicker
        if invuln_hud_time &gt; 1 and invuln_hud_time &lt; 1340
            {
                //Increment Flicker Timer
                invuln_hud_draw += invuln_hud_modi
                //Increment Flicker Modifier
                if invuln_hud_modi &lt; 0.5 invuln_hud_modi += 0.00025;
                //Reset Flicker
                if invuln_hud_draw &gt; 0.9 invuln_hud_draw = 0;
            }
        if invuln_hud_acti = 0 and invuln_hud_time &gt; 1 and invuln_hud_time &lt; 2620
            {
                invuln_hud_acti = 1
                hud_petals = spr_hud_petal_invuln
            }
        //Reset the flicker timer and modifier for the invincibility timer one frame before it reaches 0
        if invuln_hud_time = 1
            {
                invuln_hud_draw = 0
                invuln_hud_modi = 0
                invuln_hud_acti = 0
                hud_petals = spr_hud_petal
                audio_stop_sound(ost_invincibility_theme_bob)
                scr_adjust_music_extra_life(obj_game_logic.music_volume/100,2750,0)
            }
        //Animate Alarm Clock Icon
        switch(invuln_hud_time)
            {
                case 2679: {invuln_hud_fram = 0; break;}
                case 2345: {invuln_hud_fram = 1; break;}
                case 2010: {invuln_hud_fram = 2; break;}
                case 1675: {invuln_hud_fram = 3; break;}
                case 1340: {invuln_hud_fram = 4; break;}
                case 1005: {invuln_hud_fram = 5; break;}
                case  670: {invuln_hud_fram = 6; break;}
                case  335: {invuln_hud_fram = 7; break;}
            }

        //---Particle System---//
        //---------------------//

        //Particle 1 Logic
        part_frame[0]+=0.4; frame_speed[0]-=2;
        //Reset Particle Animation and Position
        if part_frame[0] &gt;= 7 {part_frame[0]=0; frame_speed[0]=0; position_offset[0]=universal_player_x+random_range(-30,-15);
        sparkle_offset[0]=universal_player_y}
        //Particle 2 Logic
        part_frame[1]+=0.4; frame_speed[1]-=2;
        //Reset Particle Animation and Position
        if part_frame[1] &gt;= 13 {part_frame[1]=0; frame_speed[1]=0; position_offset[1]=universal_player_x+random_range(-30,-15);
        sparkle_offset[1]=universal_player_y}
        //Particle 3 Logic
        part_frame[2]+=0.4; frame_speed[2]-=2;
        //Reset Particle Animation and Position
        if part_frame[2] &gt;= 19 {part_frame[2]=0; frame_speed[2]=0; position_offset[2]=universal_player_x+random_range(-25,-15);
        sparkle_offset[2]=universal_player_y}
        //Particle 4 Logic
        part_frame[3]+=0.4; frame_speed[3]-=2;
        //Reset Particle Animation and Position
        if part_frame[3] &gt;= 15 {part_frame[3]=0; frame_speed[3]=0; position_offset[3]=universal_player_x+random_range(-25,-15);
        sparkle_offset[3]=universal_player_y}
        //Particle 5 Logic
        part_frame[4]+=0.4; frame_speed[4]-=2;
        //Reset Particle Animation and Position
        if part_frame[4] &gt;= 11 {part_frame[4]=0; frame_speed[4]=0; position_offset[4]=universal_player_x+random_range(-9,9);
        sparkle_offset[4]=universal_player_y}
        //Particle 6 Logic
        part_frame[5]+=0.4; frame_speed[5]-=2;
        //Reset Particle Animation and Position
        if part_frame[5] &gt;= 8 {part_frame[5]=0; frame_speed[5]=0; position_offset[5]=universal_player_x+random_range(-40,18);
        sparkle_offset[5]=universal_player_y}
        //Particle 7 Logic
        part_frame[6]+=0.4; frame_speed[6]-=2;
        //Reset Particle Animation and Position
        if part_frame[6] &gt;= 24 {part_frame[6]=0; frame_speed[6]=0; position_offset[6]=universal_player_x+random_range(-40,18);
        sparkle_offset[6]=universal_player_y}
        //Particle 8 Logic
        part_frame[7]+=0.4; frame_speed[7]-=2;
        //Reset Particle Animation and Position
        if part_frame[7] &gt;= 9 {part_frame[7]=0; frame_speed[7]=0; position_offset[7]=universal_player_x+random_range(-40,18);
        sparkle_offset[7]=universal_player_y}
        //Particle 9 Logic
        part_frame[8]+=0.4; frame_speed[8]-=2;
        //Reset Particle Animation and Position
        if part_frame[8] &gt;= 17 {part_frame[8]=0; frame_speed[8]=0; position_offset[8]=universal_player_x+random_range(0,18);
        sparkle_offset[8]=universal_player_y}
        //Particle 10 Logic
        part_frame[9]+=0.4; frame_speed[9]-=2;
        //Reset Particle Animation and Position
        if part_frame[9] &gt;= 20 {part_frame[9]=0; frame_speed[9]=0; position_offset[9]=universal_player_x+random_range(0,18);
        sparkle_offset[9]=universal_player_y}
    }
else
    if invuln_hud_acti != 0
        {
            if anim_current!=anim_carol_wildclaws
            and anim_current!=anim_lilac_dragon_boost_1
            and anim_current!=anim_lilac_dragon_boost_2
            and anim_current!=anim_lilac_dragon_boost_r
                invuln_hud_acti = 0;
        }
    

//============Water Surface Splash Effects============//

//Determine size of the splash effect, based on vertical speed
if gravity_speed &gt; 0 and py &lt; water_height
    sfactor = gravity_speed/16;
//If the player has landed on the surface of the water, create a splash effect
if (py &gt; water_height and py &lt; water_height+16 and splash_confirm=0 and gravity_speed!=0 and use_editor = 0)
    {
        splash_x = px
        splash_confirm = 1
        //Spawn bubble particles
        if (bubble_visibility[0] = 0)
            {
                bubble_visibility[0] = 1
                bubble_offset_x[0] = universal_player_x
                bubble_offset_y[0] = universal_player_y
            }
        if (bubble_visibility[1] = 0) bubble_visibility[1] = 1;
        if (bubble_visibility[2] = 0) bubble_visibility[2] = 1;
        if waterline_index = spr_slime_waterline
            audio_play_sound(snd_mud_splat,50,false);
        else
            audio_play_sound(character_splash,50,false);
    }
//If we have confirmed a splash, allow the splash effect to play
if splash_confirm = 1 and user_cursor_mode = 0
    {
        //Iterate animation frames
        splash_frame += 0.25
        //If we have completed the animation, reset variables
        if splash_frame&gt;8.8 {splash_frame=-1; splash_confirm=0; sfactor = 0.5;}
        //If we have not completed the animation, and the player has resurfaced already,
        //restart the animation
        if (splash_frame&gt;4) and (py &gt; water_height and py &lt; water_height+16)
            {
                splash_frame = 0
                splash_x = px
                sfactor = 0.5
                if waterline_index = spr_slime_waterline
                    audio_play_sound(snd_mud_splat,50,false);
                else
                    audio_play_sound(character_splash,50,false);
            }
    }

//===============Water Bubble Particles===============//

//Draw Bubble Particles
if bubble_visibility[0] &gt; 0
    {
        //Iterate bubble timer
        bubble_visibility[0] += 1

        //Raise the bubble upward
        bubble_offset_y[0] -= 1

        //If the bubble is above the surface of the water, reset its position at the player's mouth
        if bubble_offset_y[0] &lt; water_height
            {
                bubble_offset_x[0] = universal_player_x;
                bubble_offset_y[0] = universal_player_y;
                //If the player is also above the water, disable visibility of the bubble
                if py &lt; water_height bubble_visibility[0] = 0;
            }
    }
if bubble_visibility[1] &gt; 0
    {
        //Iterate bubble timer
        bubble_visibility[1] += 1

        if bubble_visibility[1] = 180
            {
                bubble_offset_x[1] = universal_player_x;
                bubble_offset_y[1] = universal_player_y;
            }
        if bubble_visibility[1] &gt; 180
            {
                //Raise the bubble upward
                bubble_offset_y[1] -= 1

                //If the bubble is above the surface of the water, reset its position at the player's mouth
                if bubble_offset_y[1] &lt; water_height
                    {
                        bubble_offset_x[1] = universal_player_x;
                        bubble_offset_y[1] = universal_player_y;
                        //If the player is also above the water, disable visibility of the bubble
                        if py &lt; water_height bubble_visibility[1] = 0;
                    }
            }
    }
if bubble_visibility[2] &gt; 0
    {
        //Iterate bubble timer
        bubble_visibility[2] += 1

        if bubble_visibility[2] = 360
            {
                bubble_offset_x[2] = universal_player_x;
                bubble_offset_y[2] = universal_player_y;
            }
        if bubble_visibility[2] &gt; 360
            {
                //Raise the bubble upward
                bubble_offset_y[2] -= 1
        
                //If the bubble is above the surface of the water, reset its position at the player's mouth
                if bubble_offset_y[2] &lt; water_height
                    {
                        bubble_offset_x[2] = universal_player_x;
                        bubble_offset_y[2] = universal_player_y;
                        //If the player is also above the water, disable visibility of the bubble
                        if py &lt; water_height bubble_visibility[2] = 0;
                    }
            }
    }

//=========Water Surface Logic And Animations=========//

//Raise or lower the water levels as the water line changes
if water_height &lt; water_line water_height+=use_flood_fill_speed;
if water_height &gt; water_line water_height-=use_flood_fill_speed;
//Waver the water's height
if water_trigger = 0 {water_offset+=0.05 if water_offset&gt;4  water_trigger=1;}
if water_trigger = 1 {water_offset-=0.05 if water_offset&lt;-4 water_trigger=0;}

//=========Hurting Petal Scattering Particles=========//

if (hurt[0] = 1 and shield_active = 0)
    {
        //Directional Movement Based On Angle
        petal_hurt_x[0] += 4*cos(petal_hurt_dir[0])
        petal_hurt_y[0] += 4*sin(petal_hurt_dir[0])
        petal_hurt_x[1] += 4*cos(petal_hurt_dir[1])
        petal_hurt_y[1] += 4*sin(petal_hurt_dir[1])
        petal_hurt_x[2] += 4*cos(petal_hurt_dir[2])
        petal_hurt_y[2] += 4*sin(petal_hurt_dir[2])
        petal_hurt_x[3] += 4*cos(petal_hurt_dir[3])
        petal_hurt_y[3] += 4*sin(petal_hurt_dir[3])
        petal_hurt_x[4] += 4*cos(petal_hurt_dir[4])
        petal_hurt_y[4] += 4*sin(petal_hurt_dir[4])
        //Petal Rotation Angle
        petal_hurt_ang[0] -= 4
        petal_hurt_ang[1] -= 4
        petal_hurt_ang[2] -= 4
        petal_hurt_ang[3] -= 4
        petal_hurt_ang[4] -= 4
    }

} //End of Pause Safety Check

if instance_exists(obj_pulley_rope_hor) obj_pulley_rope_hor.image_index = pulley_rope_frame;
//Iterate Timer for Rendering Waterline Frames
water_timer+=0.12 
//Reset Animation
if water_timer&gt;8 water_timer=0;

if pause = 0
    {
        //Animate all crystal gems
        if instance_exists(obj_gem)
            {
                //Animations
                crystal_gem_frame += 0.12
                if crystal_gem_frame &gt; 5.8 crystal_gem_frame = 0;
                switch(floor(crystal_gem_frame))
                    {
                        case 0: {obj_gem.sheet_frame_pos_x = 1; break;}
                        case 1: {obj_gem.sheet_frame_pos_x = (obj_gem.sheet_frame_width)+(obj_gem.sheet_frame_offset)+1; break;}
                        case 2: {obj_gem.sheet_frame_pos_x = (obj_gem.sheet_frame_width*2)+(obj_gem.sheet_frame_offset*2)+1; break;}
                        case 3: {obj_gem.sheet_frame_pos_x = (obj_gem.sheet_frame_width*3)+(obj_gem.sheet_frame_offset*3)+1; break;}
                        case 4: {obj_gem.sheet_frame_pos_x = (obj_gem.sheet_frame_width*4)+(obj_gem.sheet_frame_offset*4)+1; break;}
                        case 5: {obj_gem.sheet_frame_pos_x = (obj_gem.sheet_frame_width*5)+(obj_gem.sheet_frame_offset*5)+1; break;}
                    }
            }

        if instance_exists(obj_petal)
            {
                //Animations
                obj_petal.sheet_speed += obj_petal.sheet_anim_speed
                if obj_petal.sheet_speed &gt; 1
                    {
                        obj_petal.sheet_frame_pos_x += obj_petal.sheet_frame_width+obj_petal.sheet_frame_offset
                        if obj_petal.sheet_frame_pos_x &gt;= sprite_get_width(obj_petal.sprite_index)
                            obj_petal.sheet_frame_pos_x = 1;
                        obj_petal.sheet_speed = 0
                    }
            }

        //Animations for global timers
        pulley_rope_frame += 0.35
        if pulley_rope_frame &gt; 3.8
            pulley_rope_frame = 0;
        
        //Sync all animations for rotating spikes
        if instance_exists(obj_mu_rotating_spikes)
            {
                obj_mu_rotating_spikes.frame = rotating_spikes_frame
        
                rotating_spikes_frame += 0.20
        
                if (rotating_spikes_frame &gt; 7.9) rotating_spikes_frame = 0;
            }
        //Sync all animations for escalators
        if instance_exists(obj_escalator_parent)
            {       
                obj_escalator_parent.frame += 0.5
        
                if (obj_escalator_parent.frame &gt; 6.9) obj_escalator_parent.frame = 0;
            }
    }

//=============Instance Activation Management=============//

//Deactivate all instances besides the Main Logic Object
instance_deactivate_all(true);

//Keep instances within the screen's region activated.
instance_activate_region(view_xview[view_port]-192,view_yview[view_port]-192,view_wview[view_port]+384,view_hview[view_port]+384,true);
//Keep background scroller activated
instance_activate_object(obj_activate_parent)
instance_activate_object(obj_test_target)
instance_activate_object(obj_mu_ball_spike)
instance_activate_object(obj_waterfall)
instance_activate_object(obj_bg_train_station)
//Also keep platform modifiers activated, they're too much hassle to keep deactivated :^P
instance_activate_object(obj_platform_hor)
instance_activate_object(obj_platform_ver)
instance_activate_object(obj_platform_half_cir)
instance_activate_object(obj_platform_cir)
instance_activate_object(obj_water_platform_hor)
instance_activate_object(obj_water_platform_ver)
instance_activate_object(obj_keycard_door)
if room = rm_editor
    {
        instance_activate_object(obj_checkpoint)
        instance_activate_object(obj_camera_boundary_top)
        instance_activate_object(obj_camera_boundary_bottom)
        instance_activate_object(obj_camera_boundary_left)
        instance_activate_object(obj_camera_boundary_right)
        instance_activate_object(obj_player_spawnpoint)
        instance_activate_object(obj_player_spawnpoint_next)
        instance_activate_object(obj_player_spawnpoint_lilac)
        instance_activate_object(obj_player_spawnpoint_carol)
        instance_activate_object(obj_player_spawnpoint_milla)
        instance_activate_object(obj_player_spawnpoint_spade)
        instance_activate_object(obj_player_spawnpoint_carrie)
        instance_activate_object(obj_player_spawnpoint_chiasa)
        instance_activate_object(obj_player_spawnpoint_carols_bike)
        instance_activate_object(obj_waterheight)
        instance_activate_object(obj_player_spawner)
        if obj_level_editor.use_enemy_mode_iterations = 1
            {
                instance_activate_object(obj_enemy_parent);
                instance_activate_object(obj_mega_item_parent);
            }
    }
instance_activate_object(obj_instant_water_specify)
instance_activate_object(obj_dna_cannon)
instance_activate_object(obj_fireworks_tank)
instance_activate_object(obj_blade_subordinate)
instance_activate_object(obj_bouncer)
instance_activate_object(obj_star_marine)
instance_activate_object(obj_hand_parent)
instance_activate_object(obj_guardian)
instance_activate_object(obj_guardian_claws)
instance_activate_object(obj_guardian_clone_head)
//Activate moving platform variants of specific enemies
instance_activate_object(obj_metal_pup_child)
instance_activate_object(obj_dna_cannon_child)
instance_activate_object(obj_rna_cannon_child)
instance_activate_object(obj_rocket_puncher_child)
instance_activate_object(obj_turretus_child)
instance_activate_object(obj_fire_spitter_child)
instance_activate_object(obj_ghetto_blaster_child)
instance_activate_object(obj_bullfrag_child)
if instance_exists(obj_slime_water)
    {
        obj_slime_water.clouds_x_left += 0.5
        if obj_slime_water.clouds_x_left &gt; 256
            obj_slime_water.clouds_x_left = 0;
    }

//If we are currently writing tile and object data to a map file, activate all instances in the room
if use_write_delay = 1 instance_activate_all();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Transitions System

//==========================================================================//
//                            Transitions System                            //
//==========================================================================//

//===============Ready! Go!===============//

if (room != rm_editor and user_cursor_mode = 0)
{

switch(targets_ready)
    {
        case 0: {break;}
        //Ready!
        case 1:
            {
                if use_maps_current_map = 0
                    {
                        xcompass = 720     //Override all horizontal movement
                        joy_input[1,0] = 0 //Override attack button
                        joy_input[1,3] = 0 //Override special button
                        joy_input[2,0] = 0 //Override pause button
                        gravity_ladder = 0 //Override ladder state
                        //hud_timer_mil = checkpoint_timer_mil  //Override millisecond counter
                        //hud_timer_sec = checkpoint_timer_sec  //Override second counter
                        //hud_timer_min = checkpoint_timer_min  //Override minute counter
                        timer_stop = 1     //Stop timer
        
                        //Increment the length of the ready bar
                        hud_ready_bar_length+=1
        
                        //Play "Ready!" sound
                        if hud_ready_bar_length = 4 audio_play_sound(snd_ready,50,false);
        
                        //Set X/Y coordinates to the checkpoint position, if it isn't empty
                        if hud_ready_bar_length = 2
                            {
                                if checkpoint_x &gt; 0 and checkpoint_y &gt; 0
                                    {
                                        px = checkpoint_x
                                        py = checkpoint_y
                                    }
                            }
                        if hud_ready_bar_length = 30
                            {
                                //Disable transition if it hasn't already disappeared
                                transition_active = 0
                                transition_alpha = 0
                                transition_persistence = 0
                                transition_position = 0
                            }
        
                        //Play "Go!" sound
                        if hud_ready_bar_length &gt;=116
                            {
                                audio_play_sound(snd_go,50,false)
                                hud_ready_bar_length = 0
                                targets_ready = 2
                                xcompass = 0
                                //Disable transition if it hasn't already disappeared
                                transition_active = 0
                                transition_alpha = 0
                                transition_persistence = 0
                                transition_position = 0
                            }
                        //Start stage early if bosses are present
                        if use_win_conditions = 2
                            {
                                hud_ready_bar_length = 0
                                stage_transition_alpha = 1
                                stage_transition_timer = 0
                                targets_ready = 4
                                xcompass = 720
                            }
                    }
                else
                    {
                        targets_ready = 0
                        timer_stop = 0
                        xcompass = 0
                    }
                break;
            }
        //Simplified shaking system for the "Go!" icon of the transition
        case 2:
            {
                //Increment hud item shake length timer
                hud_go_shake_timer+=1
                //Re-enable timer
                timer_stop = 0
                //Menu item x shake
                switch(hud_go_shake_timer)
                    {
                        case 0: {hud_go_shake=1;  break;}
                        case 1: {hud_go_shake=-1; break;}
                        case 2: {hud_go_shake=1;  break;}
                        case 3: {hud_go_shake=-1; break;}
                        case 4: {hud_go_shake=0;  break;}
                    }
                //If the timer has ended, stop menu item shake
                if hud_go_shake_timer&gt;12
                    {
                        hud_go_shake_timer =  0
                        hud_go_shake       =  0
                        targets_ready = 0
                    }
                break;
            }
        //Victory!
        case 3:
            {
                //Disable pause menu
                pause_lock = 1
                pause=0
                yy=0
                Jpause[0]=0
                Jpause[1]=0
                death[0] = 0
                scr_resume_sounds()
                scr_attack_variables()
                //Refill the player's breath bar
                breath=breath_max
                //Refill the player's breath alarm
                alarm_timer=660
                //Reset the player's alarm animation
                alarm_frame=0

                //Wait until we have landed to perform further actions
                if ground = 1
                    {
                        //Set the current animation to the victory pose
                        if anim_current != anim_victory
                            {
                                anim_current = anim_victory
                                checkpoint_timer_mil = 0 //Clear millisecond checkpoint
                                checkpoint_timer_sec = 0 //Clear second checkpoint
                                checkpoint_timer_min = 0 //Clear minute checkpoint
                                checkpoint_x = 0         //Clear checkpoint x position
                                checkpoint_y = 0         //Clear checkpoint y position
                                action_frame = 0         //Clear Lilac's action sprite
                                hurt[0] = 0
                                hurt[1] = 0
                                hurt[3] = 0
                            }
                        xcompass = 720     //Override all horizontal movement
                        hsp = 0            //Override horizontal speed
                        joy_input[0,0] = 0 //Override joystick right
                        joy_input[0,1] = 0 //Override joystick down
                        joy_input[0,2] = 0 //Override joystick left
                        joy_input[0,3] = 0 //Override joystick up
                        joy_input[1,0] = 0 //Override attack button
                        joy_input[1,2] = 0 //Override jump button
                        joy_input[1,3] = 0 //Override special button
                        joy_input[1,4] = 0 //Override alt special button
                        joy_input[2,0] = 0 //Override pause button
                        joy_input[2,4] = 0
                        attack[0] = 0
                        attack[1] = 0
                        attack[2] = 0
                        attack[3] = 0
                        jump_lock = 0
                        jump_override = 0
                    }

                //Stop timer
                timer_stop = 1

                //Prevent the player from taking damage during the victory animation
                invuln_hud_acti = 1
                //Increment hud item shake length timer
                if hud_go_shake_timer &gt;= 0 hud_go_shake_timer+=1;
                //Menu item x shake
                switch(hud_go_shake_timer)
                    {
                        case 0: {hud_go_shake=1;  break;}
                        case 1: {hud_go_shake=-1; break;}
                        case 2: {hud_go_shake=1;  break;}
                        case 3: {hud_go_shake=-1; break;}
                        case 4: {hud_go_shake=0;  break;}
                        case 5:
                                {
                                    hud_go_shake_timer =  0
                                    hud_go_shake       =  1
                                    hud_go_shake_loops += 1
                                    break;
                                }
                    }
                    
                //If the timer has ended, stop menu item shake
                if hud_go_shake_loops &gt; 8
                    {
                        hud_go_shake_timer = -8
                        hud_go_shake       =  0
                        hud_go_shake_loops =  0
                        hud_go_trans_timer =  1
                        instance_create(0,0,obj_results_screen);
                    }                    

                if instance_exists(obj_results_screen)
                    {
                        if obj_results_screen.ui_count_timer = -1
                            {
                                hud_go_trans_timer += 1
                                //Once half of a second has passed, start the transition
                                if hud_go_trans_timer = 100
                                    {
                                        transition_active = 1
                                        title_room_goto=rm_main_menu
                                        if room = rm_campaign
                                            {
                                                title_room_goto=rm_cutscene
                                                use_cuts_select = campaign_stage_goto_next
                                                use_cutscene = 1
                                            }
                                        audio_play_sound(pause_exit,50,false)
                                    }
                            }
                    }
                //Go back to the level select room after the transition
                if hud_go_trans_timer &gt; 50
                    {
                        title_room_timer += 1
                        if title_room_timer = 1
                            {
                                //Record time attack record to the map file
                                if room = rm_player
                                    {
                                        if user_turbo_mode_used = 0
                                            {
                                                //Initialize variables
                                                var string_part_0 = string(hud_timer_min)
                                                var string_part_1 = string(hud_timer_sec)
                                                var string_part_2 = string(hud_timer_mil)
                                                //Add a zero to the minute string
                                                if hud_timer_min &lt; 10 string_part_0 = "0" + string(hud_timer_min)
                                                if hud_timer_min = 0  string_part_0 = "00"
                                                //Add a zero to the second string
                                                if hud_timer_sec &lt; 10 string_part_1 = "0" + string(hud_timer_sec)
                                                if hud_timer_sec = 0  string_part_1 = "00"
                                                //Add a zero to the millisecond string
                                                if hud_timer_mil &lt; 10 string_part_2 = "0" + string(hud_timer_mil)
                                                if hud_timer_mil = 0  string_part_2 = "00"
                                                string_part_2 = string_copy(string_part_2,1,2)
                                                //Compare new string to previously recorded string
                                                ini_open_ns(program_directory + "Maps\" + use_maps_select)
                                                var string_compare_new = string_digits(string_part_0+string_part_1+string_part_2)
                                                var string_compare_old = string_digits(ini_read_string("lvl_hd","lvl_best_time","600000"))
                                                //If the new string is a smaller value than the old one, when both are converted to digits,
                                                //write a new time attack record in the map file
                                                if string_compare_new &lt; string_compare_old
                                                    {
                                                        ini_write_string("lvl_hd","lvl_best_time",string_part_0+string_part_1+string_part_2);
                                                        audio_play_sound(petal_absorbed,50,false)
                                                        hud_new_record = 1
                                                    }
                                                //Close the map file
                                                ini_close_ns()
                                            }
                                        //Don't Let People's Time Attack Record Count As Much If Turbo Mode Is Enabled &gt;:P
                                        else scr_set_message("Records not saved when Turbo Mode is used!");
                                    }
                                if room = rm_campaign
                                and campaign_stage_section[0] != "TaishanTutorial.map"
                                    {
                                        if user_turbo_mode_used = 0
                                            {
                                                //Initialize variables
                                                var string_part_0 = string(hud_timer_min)
                                                var string_part_1 = string(hud_timer_sec)
                                                var string_part_2 = string(hud_timer_mil)
                                                //Add a zero to the minute string
                                                if hud_timer_min &lt; 10 string_part_0 = "0" + string(hud_timer_min)
                                                if hud_timer_min = 0  string_part_0 = "00"
                                                //Add a zero to the second string
                                                if hud_timer_sec &lt; 10 string_part_1 = "0" + string(hud_timer_sec)
                                                if hud_timer_sec = 0  string_part_1 = "00"
                                                //Add a zero to the millisecond string
                                                if hud_timer_mil &lt; 10 string_part_2 = "0" + string(hud_timer_mil)
                                                if hud_timer_mil = 0  string_part_2 = "00"
                                                string_part_2 = string_copy(string_part_2,1,2)
                                                //Compare new string to previously recorded string
                                                var string_compare_new = string_digits(string_part_0+string_part_1+string_part_2)
                                                var string_compare_old = string_digits(player_best_time[time_attack_stage])
                                                if string_compare_new &lt; string_compare_old
                                                    {
                                                        ini_open_ns(program_directory + "gamedata.dat")
                                                        //If the new string is a smaller value than the old one, when both are converted to digits,
                                                        //write a new time attack record in the map file
                                                        ini_write_string("save_time_attack","stage_"+string(time_attack_stage),string_part_0+string_part_1+string_part_2)
                                                        player_best_time[time_attack_stage] = string_part_0+string_part_1+string_part_2
                                                        audio_play_sound(petal_absorbed,50,false)
                                                        hud_new_record = 1
                                                        //Close the map file
                                                        ini_close_ns()
                                                    }
                                                var string_compare_new = player_best_crystals_count
                                                var string_compare_old = real(player_best_crystals[time_attack_stage])
                                                if string_compare_new &gt; string_compare_old
                                                    {
                                                        ini_open_ns(program_directory + "gamedata.dat")
                                                        //If the new string is a smaller value than the old one, when both are converted to digits,
                                                        //write a new time attack record in the map file
                                                        ini_write_string("save_time_attack","stage_"+string(time_attack_stage)+"_gems",string(player_best_crystals_count))
                                                        player_best_crystals[time_attack_stage] = string(player_gems[player_current])
                                                        audio_play_sound(gem_sound,50,false)
                                                        hud_new_record = 1
                                                        //Close the map file
                                                        ini_close_ns()
                                                    }
                                            }
                                        //Don't Let People's Time Attack Record Count As Much If Turbo Mode Is Enabled &gt;:P
                                        else scr_set_message("Records not saved when Turbo Mode is used!");
                                        //Save Data For Classic Mode Saves
                                        if classic_mode = 1
                                            scr_set_save_data();
                                    }
                                use_maps_load = 0
                                use_maps_select = ""
                                joy_input[2,6] = 30
                            }
                        //After the iteration timer ends, change rooms
                        if title_room_timer = 80
                            {
                                //End the skewed slice transition
                                transition_active = 0
                                transition_position = 0
                                //Refresh all character variables
                                scr_lilac_variables()
                                scr_carol_variables()
                                scr_milla_variables()
                                //Clear the timers
                                title_room_timer = 0
                                hud_go_shake_timer = 0
                                //Disable invulnerability
                                invuln_hud_acti = 0
                                //Disable Carol's bike sounds
                                audio_stop_sound(carol_bike_moving)
                                audio_stop_sound(carol_bike_idle)
                                //End the target transition
                                targets_ready = 0
                                //Re-enable timer
                                timer_stop = 0
                                //Set our target value to 1, so the character's animation code
                                //doesn't see a count of 0 and assume it's time for the victory animation,
                                //which puts the transition into an endless loop :^P
                                targets = 1
                                if room = rm_campaign
                                    {
                                        use_cuts_select = campaign_stage_goto_next
                                        if campaign_cutscene_index &gt; -1
                                            {
                                                use_cutscene = campaign_cutscene_index
                                                room_goto(rm_cutscene)
                                            }
                                        //If we have loaded a stage maps playlist where the boss has been previously
                                        //defeated, go back to a campaign map's hub area, instead of a cutscene map
                                        if campaign_cutscene_index = -1
                                            {
                                                room_goto(rm_campaign)
                                            }
                                        //If we have loaded a stage maps playlist from time attack mode, return to its
                                        //menu
                                        if campaign_cutscene_index = -2
                                            {
                                                room_goto(rm_sm_character_select)
                                            }
                                        //If we have loaded a stage maps playlist from classic mode, return to the
                                        //title-screen if the game is "over"
                                        if campaign_cutscene_index = -3
                                            {
                                                room_goto(rm_title_screen)
                                            }
                                    }
                                else
                                    room_goto(rm_main_menu);
                                if room = rm_campaign and campaign_stage_section[0] = "TaishanTutorial.map"
                                    room_goto(rm_title_screen);
                                use_maps_load = 0
                                use_maps_select = ""
                                hud_go_trans_timer = 0
                                //D-Pad Movement
                                joy_input[0,0] = 0  //Joystick Right
                                joy_input[0,1] = 0  //Joystick Down
                                joy_input[0,2] = 0  //Joystick Left
                                joy_input[0,3] = 0  //JoyStick Up
                                //Player Actions
                                joy_input[1,0] = 0  //Joystick A (Attack)
                                joy_input[1,2] = 0  //Joystick B (Jump)
                                joy_input[1,3] = 0  //Joystick C (Special)
                                joy_input[1,4] = 0  //Joystick D (Switch)
                                joy_input[2,0] = 0  //Joystick "Start"
                                joy_input[2,6] = 30
                            }
                    }
                break;
            }
        //Boss stage transition
        case 4:
            {
                if (use_maps_current_map = 0)
                or (room = rm_campaign and campaign_stage_select = 0)
                    {
                        xcompass = 720     //Override all horizontal movement
                        //D-Pad Movement
                        joy_input[0,0] = 0  //Joystick Right
                        joy_input[0,1] = 0  //Joystick Down
                        joy_input[0,2] = 0  //Joystick Left
                        joy_input[0,3] = 0  //JoyStick Up
                        //Player Actions
                        joy_input[1,0] = 0 //Override attack button
                        joy_input[1,2] = 0 //Joystick B (Jump)
                        joy_input[1,3] = 0 //Override special button
                        joy_input[1,4] = 0 //Override alt special button
                        joy_input[2,0] = 0 //Override pause button
                        gravity_ladder = 0 //Override ladder state
                        if stage_transition_timer = 0
                            {
                                stage_transition_title_y -= 5
                                stage_transition_subtitle_y -= 5
                                if stage_transition_title_y &lt;= internal_res_height-64
                                    stage_transition_timer = 1;
                                if checkpoint_x &gt; 0 and checkpoint_y &gt; 0
                                    {
                                        px = checkpoint_x
                                        py = checkpoint_y
                                    }
                            }
                        if stage_transition_timer &gt;= 1
                            {
                                stage_transition_timer += 1
                                if stage_transition_timer &gt; 30 and stage_transition_alpha &gt; 0
                                    {
                                        stage_transition_alpha -= 0.1
                                    }
                            }
                        if stage_transition_alpha &lt;= 0 and stage_transition_timer &gt; 60
                            {
                                stage_transition_title_x_offset -= 15
                                stage_transition_subtitle_x_offset += 15
                            }
                        //Re-enable timer
                        if stage_transition_subtitle_x_offset &gt; 280
                            {
                                xcompass = 0
                                timer_stop = 0
                                targets_ready = 0
                            }
                    }
                else
                    {
                        targets_ready = 0
                        timer_stop = 0
                        xcompass = 0
                    }
                if room = rm_campaign and campaign_stage_select &gt; 0
                    {
                        stage_transition_alpha -= 0.1
                        if stage_transition_alpha &lt;= 0
                            {
                                targets_ready = 0
                                timer_stop = 0
                                xcompass = 0
                            }
                    }
                break;
            }
    }

//===============Death===============//

//If we have died, trigger our death animation
if death[0] = 1 and targets_ready != 3
    {
        //Set current animation to the death animation
        anim_current=anim_death
        targets_ready = 5
        //Iterate transition timer
        transition_timer += 1
        if death_not_really = 1
            transition_timer += 1;
        transition_game_over_x += 5;
        if transition_game_over_x &gt; 204 transition_game_over_x = 204;
        //Stop the timer
        timer_stop = 1
        //Disable spring animations
        if transition_timer = 1
            {
                spring_trigger = 0
                if lives &lt; 0 and death_not_really = 0
                    transition_game_over = 1;
                //Disable Carol's bike sounds
                audio_stop_sound(carol_bike_moving)
                audio_stop_sound(carol_bike_idle)
            }

        //D-Pad Movement
        joy_input[0,0] = 0  //Joystick Right
        joy_input[0,1] = 0  //Joystick Down
        joy_input[0,2] = 0  //Joystick Left
        joy_input[0,3] = 0  //JoyStick Up
        //Player Actions
        joy_input[1,0] = 0  //Joystick A (Attack)
        joy_input[1,2] = 0  //Joystick B (Jump)
        joy_input[1,3] = 0  //Joystick C (Special)
        joy_input[1,4] = 0  //Joystick D (Switch)
        joy_input[2,0] = 0  //Joystick "Start"

        //Play evil laughter death sound, if we're playing at max difficulty
        if transition_timer = 60 and user_enemy_level &gt;= 4
            audio_play_sound(snd_enemy_evil_laugh,50,false);

        //Fade to black after a certain period of time
        if transition_timer&gt;=94
            {
                transition_alpha+=0.0288;
                if death_not_really = 1 transition_alpha+=0.0288;
            }
        if (transition_timer &gt;=208 and death_not_really = 0
        and transition_game_over = 0)
            transition_loading = 1;
        //Restart the stage
        if (transition_timer&gt;=212 and transition_game_over = 0)
            {
                transition_timer = 0                //Reset transition timer
                if death_not_really = 1
                    transition_alpha = 0;
                px=start_x                          //Reset Player X position to the start
                py=start_y                          //Reset Player Y position to the start
                if checkpoint_x &gt; 0 and checkpoint_y &gt; 0
                    {
                        px = checkpoint_x
                        py = checkpoint_y
                    }
                death[0] = 0                        //Reset death state
                hurt[0]  = 0                        //Reset hurt state
                hurt[1]  = 0                        //Reset hurt timer, otherwise our controls in the menus will be locked :^P
                xdir = 1                            //Set facing direction to the right
                sprite_set_offset(spr_lilac,55,70)
                sprite_set_offset(spr_lilac_tail_2,40,48)
                lilac_dragon_boost_offset = 0
                //Refresh all character variables
                scr_lilac_variables();
                scr_carol_variables();
                scr_milla_variables();
                //Stop Carol's Bike's Sounds
                audio_stop_sound(carol_bike_idle)
                audio_stop_sound(bike_pitch)
                audio_stop_sound(carol_bike_moving)
                audio_stop_sound(carol_bike_skidding)
                //Refresh all shield variables (Prevents any shields collected directly before death from persisting)
                shield = spr_shield_wood    //Current Shield
                shield_health   = 2         //Current Shield Health
                shield_active   = 0         //Is Our Shield Active?
                shield_invuln   = 32        //How Long Before the Shield Accept Damage Again?
                shield_frame    = 0         //Current Shield Frame of Animation
                shield_speed    = 0         //Animation Speed of the Shield
                shield_timer    = -8        //How Long Before the Shield Is Active?
                shield_flash    = 0         //How Long Should the Shield Flash Last?
                shield_hold     = 0         //Next Shield in the Queue
                shield_rotate   = 0         //What Is Our Rotation? (Water Shield Only)
                shield_framemax = 0         //Maximum Number of Animated Shield Frames
                shield_rotate_x = 0         //X Position of the Shield
                shield_rotate_y = 0         //Y Position of the Shield
                shield_angle    = 0         //Angle of The Shield While Orbiting the Player
                //Refresh all drown timer variables
                alarm_frame     = 0         //Current animation frame for breath alarm
                alarm_timer     = 660       //Timer for breath alarm
                alarm_shake_x   = 0         //Alarm Sprite Shake X
                alarm_shake_y   = 0         //Alarm Sprite Shake Y
                //Reset the timer on the HUD to the values provided by the previous checkpoint
                //hud_timer_mil = checkpoint_timer_mil
                //hud_timer_sec = checkpoint_timer_sec
                //hud_timer_min = checkpoint_timer_min
                //Re-enable the timer
                timer_stop = 0
                //Restart the stage
                if death_not_really = 0
                    {
                        //Refill health petal meter based on which character we're playing as
                        petals = 14
                        petalsmax = 14
                        if skin = spr_milla {petals = 10; petalsmax = 10;}
                        if lives &gt;= 0
                            {
                                //Reload map if we are in player mode
                                use_maps_load = 1;
                                targets = 1
                                targets_ready = 0
                                joy_input[2,6] = 30
                                room_restart();
                            }
                        //Return to the main menu if we have run out of lives
                        if lives &lt; 0
                            {
                                lives = 5
                                targets = 1
                                targets_ready = 0
                                use_maps_load = 0
                                joy_input[2,6] = 30
                                room_goto(rm_main_menu)
                            }
                    }
                else
                    {
                        hsp = 0
                        gravity_speed = 0
                        frame = 0
                        anim_current = anim_standing
                        targets_ready = 0
                        use_zoom_iterate = 0
                        use_zoom_scale_factor = 1
                        use_zoom_x_view = internal_res_width
                        use_zoom_y_view = internal_res_height
                        use_zoom_counter = 0
                    }
            }
        //If we were underwater, keep us falling downward
        if py &gt; water_height and gravity_speed &lt;= 2 and ground = 0 gravity_speed+=gravity_accel;
        //Stop us from moving on the ground
        if ground = 1 hsp = 0;
    }

} //End Player Mode Check

//Undo fade to black after a certain period of time
if (transition_alpha &gt; 0 and death[0] = 0) transition_alpha-=0.1; //Original value = 0.0288

//Hold the transition over the screen for a few frames longer, after entering a new room
if transition_persistence &gt; 0 or now_loading &gt;= 1 or transition_loading = 1
    {
        //Hold the loading screen over the transition for a few more frames
        if now_loading = 0 transition_persistence -= 1;
        //Restart the room
        if now_loading &gt;= 1 now_loading += 1;
        if now_loading = 3
            {
                now_loading = 0
                room_restart();
            }
    }

if transition_active = 1
    {
        if transition_position &lt;= 527 transition_position += 31;
        if transition_position &gt;  527 transition_loading = 1;
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Generic Player Movement</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Player Movement, Collisions, and Damage

//Check if we are paused first
if pause = 0 and user_cursor_mode = 0 and pause_logic = 0
{

//==========================================================================//
//                            Platforming System                            //
//==========================================================================//

//Search for smart pools
water_ID = collision_point(px,py,obj_smart_pools,false,true);

if py &lt; water_height and !instance_exists(water_ID)
    above_water = 1;
else
    above_water = 0;

//===============Standing Actions===============//

//Check for attacks before allowing standing and movement actions
if (attack[0] = 0 and hsp = 0 and ground = 1 and Animations_Override = 0 and death[0] = 0)
    {
        //Standing Actions//
        //----------------//

        //Look Up Animation (Key Press)
        if (joy_input[0,3] = 1 and joy_input[0,1] = 0 and (anim_current = anim_standing or anim_current=anim_idle_1))
            {
                anim_idle_timer=0
                anim_current=anim_looking_up;
            }
        //Look Down Animation (Key Press)
        if (joy_input[0,1] = 1 and joy_input[0,3] = 0 and (anim_current = anim_standing or anim_current=anim_idle_1))
            {
                anim_idle_timer=0
                anim_current=anim_ducking;
            }
        //Key Release
        if (anim_current = anim_ducking    and joy_input[0,1] = 0) //Looking Up
        or (anim_current = anim_looking_up and joy_input[0,3] = 0) //Looking Down
        or (joy_input[0,1] = 0 and joy_input[0,3] = 0 and anim_current != anim_standing
        and anim_current != anim_jump and anim_idle_timer &lt; 530) //No longer doing either
            anim_current=anim_standing;
        //Wall Pushing
        if (joy_input[0,2] = 1 and joy_input[0,0] = 0 and ground = 1
        and anim_current != anim_jump and attack[0] = 0)
            {
                //Left
                if tile_angle=0 anim_current=anim_wall_pushing;
                else anim_current=anim_standing;
                xdir=-1;
                push_timer += 1
            }
        if (joy_input[0,0] = 1 and joy_input[0,2] = 0 and ground = 1
        and anim_current != anim_jump and attack[0] = 0)
            {
                //Right
                if tile_angle=0 anim_current=anim_wall_pushing;
                else anim_current=anim_standing;
                xdir=1;
                push_timer += 1
            }
        if push_timer = 64
            audio_play_sound(o.push_sound,50,false);
        if joy_input[0,2] = 0 and joy_input[0,0] = 0
            {
                if push_timer &gt; 0
                    {
                        push_timer = 0;
                        audio_stop_sound(push_sound);
                    }
            }
        //Check for double inputs before allowing Look Up and Look Down animations
        if  (joy_input[0,3] = 1 and joy_input[0,1] = 1)
        and (anim_current = anim_looking_up and frame &gt; 1)
        or  (anim_current = anim_walking)
        or  (anim_current = anim_swimming)
        or  (anim_current = anim_skidding)
            anim_current = anim_standing;
    }
if anim_current = anim_ducking player_hitbox_radius = 32;
else player_hitbox_radius = 64;
//Walking and Running Animations
if (gravity_speed = 0 and attack[0] = 0 and hsp!=0 and anim_current != anim_jump and Animations_Override = 0
and spring_timer = -1)
    {
        //If the player isn't skidding
        if ground = 1 and (anim_current!= anim_skidding
        //If the player is skidding!
        or anim_current = anim_skidding and (joy_input[0,0] = 1 and joy_input[0,2] = 0 and hsp &gt; 0)
        or anim_current = anim_skidding and (joy_input[0,2] = 1 and joy_input[0,0] = 0 and hsp &lt; 0)
        //If the player has not left the standing animation for any reason after starting movement
        or anim_current = anim_standing)
            {
                //Walking Animation
                if (abs(hsp) &gt; 0 and abs(hsp) &lt; hcap-1) anim_current = anim_walking;
                //Running Animation
                if (abs(hsp) &gt;= 5 and abs(hsp) &lt; 9.5) anim_current = anim_running;
                //Running Faster Animation
                if (abs(hsp) &gt;= 9.5) anim_current = anim_faster;
            }
        //Idle Animation
        if (hsp = 0) and (anim_current=anim_walking or anim_current=anim_running)
            anim_current = anim_standing;
            
        //Skidding Animation
        if  (joy_input[0,0] = 1 and hsp &lt; -3.4 or joy_input[0,2] = 1 and hsp &gt; 3.4)
        and (anim_current = anim_running or anim_current = anim_faster) and ground=1
        and fling_timer=0 and gravity_rail_check = 0
            {
                //Skid Animation
                anim_current = anim_skidding
                //Initialize Animation Frames
                skid_animation_frame[0] = -2  skid_animation_frame[1] = -3
                skid_animation_frame[2] = -4  skid_animation_frame[3] = -5
                skid_animation_frame[4] = -6  skid_animation_frame[5] = -7
                skid_animation_frame[6] = -8  skid_animation_frame[7] = -9
                skid_animation_frame[8] = -10 skid_animation_frame[9] = -11
                //Play Sound
                audio_play_sound(snd_player_skid,50,false)
            }
        //Rain Footsteps
        if (use_weather_conditions &gt; 0 and py &lt; water_height and !instance_exists(water_ID))
            {
                if (anim_current = anim_walking
                or  anim_current = anim_running
                or  anim_current = anim_faster)
                    {
                        anim_sound_timer += 1
                        if anim_sound_timer = 1
                            audio_play_sound(character_water_foot_step,50,false);
                        if anim_sound_timer &gt; 32 or ground = 0
                            anim_sound_timer = 0;
                    }
            }
    }
//End of Attack Check

//If the player is stuck in the standing animation for any unforeseeable reason, set them to a different animation
if gravity_rail_check = 0
    {
        if (anim_current=anim_standing or anim_current=anim_jump) and gravity_speed  = 0 and hsp!=0 anim_current=anim_walking;
        if (anim_current=anim_standing and gravity_speed != 0) anim_current=anim_falling;
        if audio_is_playing(snd_rail_loop)
            {
                scr_set_rail_grinding_stop()
            }
    }
else
    {
        if (ground = 1)
            {
                rail_grinding_iterations += 0.50
                if rail_grinding_iterations &gt; 5
                    rail_grinding_iterations = 0;
                switch(rail_grinding_iterations)
                    {
                        case 0: {rail_grinding_particle_x[0] = px+random_range(-8,8); rail_grinding_particle_y[0] = py; rail_grinding_particle_ang[0] = 0; break;}
                        case 1: {rail_grinding_particle_x[1] = px; rail_grinding_particle_y[1] = py+random_range(-8,8); rail_grinding_particle_ang[1] = 0; break;}
                        case 2: {rail_grinding_particle_x[2] = px+random_range(-8,8); rail_grinding_particle_y[2] = py; rail_grinding_particle_ang[2] = 0; break;}
                        case 3: {rail_grinding_particle_x[3] = px; rail_grinding_particle_y[3] = py+random_range(-8,8); rail_grinding_particle_ang[3] = 0; break;}
                        case 4: {rail_grinding_particle_x[4] = px+random_range(-8,8); rail_grinding_particle_y[4] = py; rail_grinding_particle_ang[4] = 0; break;}
                        case 5: {rail_grinding_particle_x[5] = px; rail_grinding_particle_y[5] = py+random_range(-8,8); rail_grinding_particle_ang[5] = 0; break;}
                    }
                var rail_grinding_count = 0;
                while(rail_grinding_count &lt;= 5)
                    {
                        rail_grinding_particle_y[rail_grinding_count] -= 4
                        rail_grinding_particle_ang[rail_grinding_count] += 6*-xdir
                        rail_grinding_count += 1
                    }
            }
    }

//================Universal Player Orbit================//

//Because a lot of things need to be 24 pixels above the player, essentially centered on the player,
//instead of their feet, create an orbital position around the player's x/y positions based on their angle
universal_player_x = px+lengthdir_x(24,angle_a+90)
universal_player_y = py+lengthdir_y(24,angle_a+90)

//===============Tile Compass Adjustments===============//

//Modify direction of movement based on angle
switch(xcompass)
    {
        case 0:   {px+=hsp; break;} //Default: "Ground"; Forward Horizontal Speed
        case 90:  {py-=hsp; break;} //Default: "Right"; Upward Gravity Speed
        case 180: {px-=hsp; break;} //Default: "Ceiling"; Backward Horizontal Speed
        case 270: {py+=hsp; break;} //Default: "Left"; Downward Y Speed
        //Default: "Flat Ceiling"; Backward Horizontal Speed
        case 360: {px+=tile_surface_hor_speed*-xdir; break;}
    }

/*  If we are on a wall or ceiling, and have jumped,
    release tile compass lock on gravity          */
if (anim_current=anim_jump and xcompass!=0 and gravity_ceiling=0)
or (ground=0)
//If we have landed on a flat surface tile
or (tile_exists(tile_surface_id[2]) or tile_exists(tile_companion_id[2,0]) or tile_exists(tile_companion_id[2,1]))
    xcompass = 0;
if flat_surface_lag &gt; 0 flat_surface_lag -= 1;
if (abs(hsp) &lt; 0.40 and xcompass != 0)
    {
        flat_surface_lag = 2
        xcompass = 0
    }

//================Slope Ceiling Clipping================//

//Keep a copy of our gravity speed for converting into horizontal speed, when clipping onto a ceiling
if tile_wall_speed_copy != gravity_speed
    {
        if bike = 0 tile_wall_speed_copy = abs(gravity_speed);
        if bike = 1 and anim_current=anim_carol_wall_jump tile_wall_speed_copy = abs(bike_gravity_speed);
    }

//==================Skidding Particles==================//

//   Particle System   //
//=====================//
//Iterate Particle Animation Frames
if skid_animation_frame[0]!=-128 {skid_animation_frame[0]+=0.40; if skid_animation_frame[0] &gt; -1 skid_offset_y[0]-=0.35;}
if skid_animation_frame[1]!=-128 {skid_animation_frame[1]+=0.40; if skid_animation_frame[1] &gt; -1 skid_offset_y[1]-=0.35;}
if skid_animation_frame[2]!=-128 {skid_animation_frame[2]+=0.40; if skid_animation_frame[2] &gt; -1 skid_offset_y[2]-=0.35;}
if skid_animation_frame[3]!=-128 {skid_animation_frame[3]+=0.40; if skid_animation_frame[3] &gt; -1 skid_offset_y[3]-=0.35;}
if skid_animation_frame[4]!=-128 {skid_animation_frame[4]+=0.40; if skid_animation_frame[4] &gt; -1 skid_offset_y[4]-=0.35;}
//Spawning X/Y Positions
if skidding_override = 0
    {
        skid_spawn_x = px
        skid_spawn_y = py
    }

//Particle Animation Frames 1
var skid_count = 0;

while(skid_count &lt;= 9)
    {
        if skid_animation_frame[skid_count]&gt;6.8 or (skid_animation_frame[skid_count]&gt;-2 and skid_animation_frame[skid_count]&lt;0)
            {
                //Reset skid animation frames and x/y coordinates
                skid_animation_frame[skid_count] = 0; skid_offset_x[skid_count]=skid_spawn_x; skid_offset_y[skid_count]=skid_spawn_y;
                //If we have stopped skidding, or left the ground/started swimming, disable animation of particles
                if anim_current!=anim_skidding and skidding_override = 0
                or ground=0 and skidding_override = 0 skid_animation_frame[skid_count] = -128;
            }
        skid_count += 1
    }

//===============General Movement Systems===============//

//============Running============//

//Ladder check; disallow all horizontal movement if we are on a ladder, or using an attack that disables all
//horizontal movement
if gravity_ladder = 0 and active_attack = 0 and death[0] = 0 and milla_direction_override = 0
and gravity_rail_check = 0
    {
        //Check for double inputs, we can't let those pesky keyboard users have their fun :^P
        if (fling_timer=0 and anim_current!=anim_hurt) and not (joy_input[0,2] = 1 and joy_input[0,0] = 1)
            {
                //Reset acceleration timer after collisions with walls, so the player still has their
                //fair running start after jumping over walls
                if (wall_collision_left = 1 or wall_collision_right = 1 or tile_wall_trigger = 1 or tile_wall_trigger_l = 1) and bike = 0
                    acc_time = 0
                //Left Movement
                if  joy_input[0,2] = 1 and joy_input[0,0] = 0 and wall_collision_left = 0
                    {
                        //Setup Accleration Timer (Needed For FP's Unique Movement System)
                        if acc_time &lt; 5 acc_time+=1;
                        //Change Direction
                        xdir=-1
                        if acc_time&lt;=3 and hsp&gt;=-1.9911 and hsp &lt;=0 hsp-=0.6637; //Accelerate (Kickstart)
                        if (acc_time&gt;3 or hsp&lt;-1.9911) and hsp&gt;-hcap hsp-=acc;   //Accelerate (Ground)
                    }
                
                //Right Movement
                if joy_input[0,0] = 1 and joy_input[0,2] = 0 and wall_collision_right = 0
                    {
                        //Setup Accleration Timer (Needed For FP's Unique Movement System)
                        if acc_time &lt; 5 acc_time+=1;
                        //Change Direction
                        xdir=1
                        if acc_time&lt;=3 and hsp &gt;=0 and hsp&lt;=1.9911 hsp+=0.6637; //Accelerate (Kickstart)
                        if (acc_time&gt;3 or hsp&gt;1.9911) and hsp&lt;hcap hsp+=acc;    //Accelerate (Ground)
                    }
            }
        //Stop the player if they are pressing both directional inputs
        if (joy_input[0,2] = 1 and joy_input[0,0] = 1 and abs(hsp) &lt; dec and ground=1) hsp = 0;
        
        //============Braking============//
        
        //Left Braking
        if joy_input[0,2] = 1 and hsp&gt;0 and wall_collision_left = 0
            {
                hsp-=dec                //Decelerate
                acc_time=0
            }
        
        //Right Braking
        if joy_input[0,0] = 1 and hsp&lt;0 and wall_collision_right = 0
            {
                hsp+=dec                //Decelerate
                acc_time=0
            }

        //============Stopping============//
        
        //Apply Friction If We Are Not Pressing Any Buttons
        if (joy_input[0,0] = 0 and joy_input[0,2] = 0)
            {
                var friction_frc = frc;
                //Override Fiction Speed If Milla Is Recoiling From A Super Shield Burst
                if milla_special_attack != 0 friction_frc = 0.56875;
                //Left Friction On The Ground
                if hsp&lt;-friction_frc and (ground = 1 or joy_mouse_button_switch = 1) hsp += friction_frc;
                //Right Friction On The Ground
                if hsp&gt;friction_frc  and (ground = 1 or joy_mouse_button_switch = 1) hsp -= friction_frc;
                //Apply Slow Speed When We Are Slower Than Set Friction (Emulates The Original Game's Behavior)
                if ground = 0 and abs(hsp)&gt;0 and abs(hsp)&lt;friction_frc hsp = friction_frc * xdir;

                //Stop moving completely if we are slower than the base friction speed (Only on the ground, though.)
                if abs(hsp)&lt;=0.8 and ground = 1 and stagger_backwards = 0 hsp=0;

                //Reset acceleration timer
                acc_time=0;
            }
        //If we were moving below 5px/s, and we're not boosting on the bike, reduce speed to 5px/s speed cap
        if (abs(hsp) &gt;= 5 and gravity_speed &gt; -4 and gravity_speed &lt; 0 and user_turbo_mode = 0)
            gravity_friction = 1;
        if (bike = 1 and bike_boost_trigger &gt; 0 and bike_boost_trigger &lt;= 3)
        or spring_timer &gt; 0
            gravity_friction = 0;
        //Apply Friction If We Are In The Air And Have Jumped
        if gravity_friction = 1
            {
                //Setup friction rate based on whether or not we're riding the bike
                var drag_friction = 0
                if bike = 0 drag_friction = 4;
                else        drag_friction = 8;
                //Iterate drag timer
                drag_timer += 1
                if drag_rate &lt; 0 drag_rate = 0;
                if use_weather_conditions &lt; 3
                    {
                        //Left
                        if hsp &lt; -drag_friction {drag_rate -= drag_reduction; hsp += drag_rate;}
                        //Right
                        if hsp &gt; drag_friction {drag_rate -= drag_reduction; hsp -= drag_rate;}
                    }
                if use_weather_conditions = 3 and py &lt;= water_height and !instance_exists(water_ID)
                    {
                        //Left
                        if use_weather_direction = 0 {hsp -= drag_rate; drag_rate -= drag_reduction;}
                        //Right
                        if use_weather_direction = 1 {hsp += drag_rate; drag_rate -= drag_reduction;}
                    }
                //Stop applying friction if we are either no longer jumping upwards, or have landed
                if (gravity_speed &gt; 0) or (ground = 1 and drag_timer &gt; 8)
                    {
                        gravity_friction    = 0         //Player Air Speed Drag Trigger
                        drag_rate           = 0.375     //Player Air Speed Drag Rate
                        drag_reduction      = 0.0117    //Player Air Speed Drag Reduction Rate
                        drag_timer          = 0         //Reset Drag Timer
                    }
            }

        //Stop moving if we touch a wall
        if (wall_collision_left = 1 and joy_input[0,0] = 0) or (wall_collision_right = 1 and joy_input[0,2] = 0) hsp=0;
    }
    //End of Ladder Check

//          Gravity System          //
//----------------------------------//

//Do not apply gravity if we are on the wall or ceiling
if xcompass = 0
    {
        //Apply gravity to the player
        py+=gravity_speed
        
        //Produce a ground state based on floor collisions with various surface types
        if (tile_exists(tile_surface_id[2])
        or tile_exists(tile_companion_id[2,0])
        or tile_exists(tile_companion_id[2,1])
        or tile_exists(tile_surface_wall_id)
        or gravity_slope=1)
            {
                //Provide the landing conversion factor with our gravity speed before resetting it
                gravity_factor = gravity_speed
                //Set ground state
                ground = 1;
                //Reset spring timer
                spring_timer=-1;
            }
        else ground = 0;

        //Fall Animation
        if (gravity_speed &gt; -1.25 and py &lt;= water_height and !instance_exists(water_ID) and gravity_speed!=0 and anim_current!=anim_ladder_climbing)
            {
                if (anim_current&gt;=anim_standing and anim_current&lt;=anim_faster)
                or (anim_current=anim_jump)
                or (anim_current=anim_ladder_climbing)
                    anim_current=anim_falling;
                if audio_is_playing(snd_rail_loop)
                    {
                        anim_current=anim_falling
                        scr_set_rail_grinding_stop()
                    }
            }
        //Disable falling animation if we are on the ground
        if (gravity_speed=0 or ground = 1) and anim_current=anim_falling anim_current=anim_standing;
        //Push the player into the water, if they are standing at *exactly* the same Y height as the water's height,
        //and refusing to sink
        if gravity_speed = 0 and water_height = py and ground = 0
            {
                anim_current=anim_falling;
                py+=1
            }

        //If we are not at the speed cap, apply acceleration.
        if (gravity_speed&lt;15 and ground = 0 and gravity_ladder=0 and py &lt;= water_height and !instance_exists(water_ID) and gravity_override = 0)
            gravity_speed+=gravity_accel;

        //If we are on the ground, reset gravity speed.
        if (ground = 1 or gravity_ladder = 1) gravity_speed=0;

        //If we are on a flat surface, or we are falling, reset angle
        if (tile_exists(tile_surface_id[2]) and gravity_slope=0) or (gravity_ladder=1) or (ground = 0)
            tile_angle = 0;

    } //End of tile compass check

//          Actions System          //
//----------------------------------//

//============Jumping============//

//Jump Button Locking
if joy_input[1,2] = 1 joy_input[2,4]+= 1;
if joy_input[2,4] = 1 jump_lock = 1;
if joy_input[1,2] = 0 joy_input[2,4] = 0;
if gravity_speed  &gt; 0 or tile_collision_ceiling = 1 jump_lock = 0;

//If jump key is pressed, and we are on the ground, or a FOF, press jump.
if (jump_lock = 1 and gravity_speed = 0 and tile_collision_ceiling=0 and active_attack = 0 and jump_override = 0)
    {
        anim_current = anim_jump
        //Influence the jump speed based on angle
        if ground=1
            {
                //Declip from flat surface ceilings
                if tile_surface_wall_xcompass = 180 py += 15;
                //Determine the general direction of the jump by the player's X/Y coordinates
                var jump_length_x = lengthdir_x(gravity_jump,tile_angle+90)
                var jump_length_y = lengthdir_y(gravity_jump,tile_angle+90)
                //Determine the additional speed of the jump by another orbit
                var speed_length_y = lengthdir_y(hsp,tile_angle)
                //Apply horizontal and vertical speed to the player based on the difference
                hsp           = jump_length_x+hsp
                gravity_speed = jump_length_y+speed_length_y
                if potion_feather_timer &gt; 0
                    {
                        gravity_speed -= 1.4
                    }
                //Set fling timer to prevent the player from overriding their horizontal speed
                if xcompass != 0 and not (angle_a &lt;= 90 and xdir=-1) and not (angle_a &gt;= 270 and xdir=1)
                    {
                        hsp = jump_length_x;
                        fling_timer = 4;
                        fling_hsp=hsp;
                    }
                //Apply jump factor at non-zero angles
                if tile_angle!=0
                    {
                        //Multiply current speed by jump factor (0.0034)
                        var jump_factor = gravity_speed*jfactor

                        //Subtract resulting jump factor from the jump strength
                        hsp = hsp-jump_factor*-sign(hsp)
                        gravity_speed = gravity_speed-jump_factor

                        if potion_feather_timer &gt; 0
                            {
                                gravity_speed -= 1.4
                            }
                        if anim_current=anim_lilac_cyclone
                            gravity_speed = (gravity_speed/1.5)-jump_factor;
                    }
                //If Lilac is currently cycloning off of flat ground, reduce the height of the jump by nearly half
                if anim_current = anim_lilac_cyclone and ground = 1 and tile_angle = 0 gravity_speed = gravity_speed/1.5;
                //If we were jumping off of a flat wall, reset direction of gravity speed
                if (tile_angle = 270 and xdir = -1) or (tile_angle = 90 and xdir = 1)
                    {
                        fling_ver_timer = 4
                        fling_vsp = -abs(jump_length_y+speed_length_y)*lfactor
                    }
                if (tile_angle = 270 and xdir = 1 or tile_angle = 90 and xdir = -1)
                    {
                        fling_ver_timer = 4
                        fling_vsp = abs(jump_length_y+speed_length_y)*lfactor
                    }
                gravity_slope = 0                   //Override slope clipping for this one frame
                ladder_moving = 0
                xcompass = 0                        //Override current tile compass direction
                tile_check_slope_priority = 0       //Slope Priority For Flat Surface Running
                tile_surface_wall_xcompass = 0      //Tile Compass For Flat Surface Running
                scr_set_rail_grinding_stop()        //Stop rail grinding, if we were grinding on rails
                if skin = spr_carol
                    {
                        attack[0] = 0
                        joy_input[2,5] = 0
                    }
            }
        //Iterate Jump Sound Timer (Prevents Sound Bleeding)
        jump_sound+=1
        //Play Jump Sound
        if jump_sound = 1 and gravity_ladder != 2 audio_play_sound(snd_player_jump,50,false);
    }
//If the jump key is released, halve jump speed for variable jump height
if joy_input[1,2] = 0 and gravity_speed&lt;-3.25 and ground = 0 and (anim_current = anim_jump or anim_current = anim_hurt)
    gravity_speed=-3.25;
//Refresh jump sound interation timer
if gravity_speed &gt; 0 and jump_sound &gt; 0 jump_sound = 0;

//HACK DETECTION!!! Custom jump exclusively for jumping off of flat surfaces as Carol while she's rolling. (Her attack
//overrides prevent the normal jump code from executing) If it is placed anywhere in Carol's own code block,
//there's some latency in the jump, which doesn't feel nice; this is a temporary solution
if skin=spr_carol and (anim_current=anim_carol_rolling or anim_current=anim_carol_wildclaws)
    {
        //If we were on a flat surface, apply jump speed
        if (jump_lock = 1 and !tile_exists(tile_surface_id[1]) and tile_exists(tile_surface_id[2]))
        or (jump_lock = 1 and gravity_slope=1 and tile_angle=0)
        or (jump_lock = 1 and gravity_slope=1 and tile_angle=360)
            {
                carol_jump_lock  = 1
                carol_jump_timer = 0
            }
        if (carol_jump_lock = 1) and (gravity_slope = 0)
            {
                carol_jump_timer += 1
                if potion_feather_timer = 0
                    gravity_speed = -gravity_jump;
                if potion_feather_timer &gt; 0
                    gravity_speed = -gravity_jump-1.4
                //Disable jump, if we have reached the height of the jump, or released the button
                if carol_jump_timer &gt; 1.4
                or joy_input[1,2] = 0
                or tile_collision_ceiling = 1
                    {
                        carol_jump_lock  = 0
                        carol_jump_timer = 0
                    }
            }
    }

//============Swimming============//

//If we are below the waterline, allow swimming
if (py &gt; water_height or instance_exists(water_ID)) and death[0] = 0 and (anim_current!=anim_carol_wildclaws)
and not (py = water_height and ground = 1)
    {
        var sink_yes = 0;
        if instance_exists(water_ID)
            {
                if water_ID.object_index = obj_mud_cube
                or water_ID.object_index = obj_mud_water
                    {
                        sink_yes = 1;
                    }
            }
        if waterline_index = spr_mud_waterline
            sink_yes = 1;
        //For animations related to swimming, check the character's relevant code block
        //Physics modification for underwater movement
        acc=0.056875
        //Modify horizontal speed cap if we are not Carol on her bike
        var         water_cap = 4;
        //Increase the horizontal speed cap up to 8px/f if Carol is driving forward on her bike
        if bike = 1 and (joy_input[0,0] &gt; 0 and joy_input[0,2] = 0 or joy_input[0,0] = 0 and joy_input[0,2] &gt; 0) water_cap = 8;
        //Force the horizontal speed cap back to normal if Carol is driving up while on her bike, even if she is pressing forward
        if bike = 1 and (joy_input[0,3] &gt; 0 or joy_input[1,2] &gt; 0) water_cap = 4;
        //Increase or decrease the gravity cap based on Down inputs
        if joy_input[0,1] = 0 gravity_cap = 2; else gravity_cap = 3;
        //Ignore gravity cap completely if we're using a rock shield
        if (shield = spr_shield_rock and shield_active = 1)
            {
                water_cap = 15
                gravity_cap = 8
            }

        //If either Up or Jump is pressed, swim upwards
        if  (gravity_speed&gt;-2 and sink_yes = 0)
        and ((joy_input[0,3] = 1 and ground = 0 and active_attack = 0 and tile_collision_ceiling = 0)
        or   (joy_input[1,2] = 1 and ground = 0 and active_attack = 0 and tile_collision_ceiling = 0))

            gravity_speed -= gravity_accel;

        //Enforce lower gravity speed
        if gravity_speed &gt; gravity_cap  gravity_speed = gravity_cap;
        if gravity_speed &lt; -gravity_cap gravity_speed += gravity_accel;
        //Enforce lower horizontal speed, but only if the player is pressing directions
        //(allows the player to keep higher speeds attained via other means)
        if (joy_input[0,0] = 1 and joy_input[0,2] = 0 and ground=0 and hsp &gt; water_cap) hsp-=drag_rate;
        //Left
        if (joy_input[0,0] = 0 and joy_input[0,2] = 1 and ground=0 and hsp &lt; -water_cap) hsp+=drag_rate;
        //Reset swimming animations if the player has landed on the ground while underwater
        if ground = 1 and anim_current=anim_swimming
            {
                scr_set_rail_grinding_stop();
                if (hsp = 0)  anim_current=anim_standing;
                if (hsp != 0) anim_current=anim_walking;
            }
        if anim_current=anim_carol_wall_jump anim_current=anim_falling;

        //=========Friction=========//
        if (joy_input[1,2] = 1 or joy_input[0,3] = 1)
            {
                //If we are swimming, only apply friction when swimming up
                if gravity_speed!=0
                    {
                        if hsp&lt;-0.015 hsp += 0.015;   //Left
                        if hsp&gt;0.015  hsp -= 0.015;   //Right
                    }
                //If we are on the ground, apply normal friction
                if (joy_input[0,0] = 0 and joy_input[0,2] = 0 and gravity_speed = 0 and bike = 0)
                    {
                        if hsp&lt;-frc hsp += frc;    //Left
                        if hsp&gt;frc  hsp -= frc;    //Right
                        //Stop moving completely if we are slower than the base friction speed
                        if abs(hsp)&lt;frc hsp=0;
                    }
            }
        //Limit the player's acceleration while on the ground
        if (ground = 1 and abs(hsp) &gt; 4 and abs(hsp) &lt; 5 and bike = 0)
        and (water_cap != 15)
            {
                if hsp &lt; 0 hsp = -water_cap;
                if hsp &gt; 0 hsp = water_cap;
            }
        //If we are not at the speed cap, apply acceleration.
        if (gravity_speed&lt;gravity_cap and ground=0 and gravity_ladder=0
        and xcompass=0 and joy_input[0,3] = 0 and joy_input[1,2] = 0
        and active_attack = 0)
        or (sink_yes = 1)
            gravity_speed+=gravity_accel;
        //Leap from the water if we were holding the jump button to swim
        if instance_exists(water_ID)
            {
                if (py &lt; water_ID.y+8 and !instance_exists(water_ID.a) and gravity_speed&lt;0 and attack[0]=0 and tile_collision_ceiling = 0)
                    {
                        gravity_speed   = -6.5
                        acc             = 0.07375   //Player Acceleration (Ground)
                        gravity_cap     = 15        //Gravity Speed Cap
                        anim_current = anim_jump;   //Jump animation
                    }
            }
        else
            {
                if (py &lt; water_height+8 and gravity_speed&lt;0 and attack[0]=0 and tile_collision_ceiling = 0)
                    {
                        gravity_speed   = -6.5
                        acc             = 0.07375   //Player Acceleration (Ground)
                        gravity_cap     = 15        //Gravity Speed Cap
                        anim_current = anim_jump;   //Jump animation
                    }
            }

        //If the player is on the ground while swimming, return the player to their standing animation
        if (ground=1) and (anim_current=anim_falling or anim_current=anim_jump) anim_current=anim_standing;
    }

//          Ladders System          //
//----------------------------------//

//If we are on a ladder, allow the player to climb up or down
if (gravity_ladder = 1)
    {
        //Keep animation locked to ladder climbing animation
        anim_current = anim_ladder_climbing
        bike_jump_roll_speed = 0

        //Keep Horizontal Speed Locked At 0
        hsp = 0
        p_off[0,1] = -36
        fof_disable = 32

        //If We Are Not Swinging, Allow Ladder Climbing
        if ladder_state = 0
            {
                //Keep Ladder Sprites From Mirroring
                xdir=1
                //Climbing Up
                if joy_input[0,3] = 1 and joy_input[0,1] = 0
                    {
                        gravity_speed =-ladder_speed;
                        if ground = 1 py -= 1;
                    }
                //Climbing Down
                if joy_input[0,1] = 1 and joy_input[0,3] = 0 gravity_speed = ladder_speed;
                //Upward Leaping
                if joy_input[2,4] &gt; 0 and joy_input[2,4] &lt; 5 and joy_input[0,3] = 1
                    {
                        gravity_speed -=1
                        spring_timer = -1
                        audio_stop_sound(snd_player_jump)
                    }
                //Jumping Off The Ladder
                if joy_input[1,2] = 1 and joy_input[0,3] = 0 and joy_input[0,1] = 0
                    {
                        anim_current  = anim_jump
                        gravity_speed = -gravity_jump/2
                        gravity_ladder = 0
                        spring_timer = -1
                        ladder_moving = 0
                    }
                //Jumping Down The Ladder
                if joy_input[1,2] = 1 and joy_input[0,3] = 0 and joy_input[0,1] = 1
                    {
                        anim_current  = anim_falling
                        gravity_speed = 0
                        gravity_ladder = 0
                        spring_timer = -1
                        ladder_moving = 0
                        audio_stop_sound(snd_player_jump)
                    }
                //Getting Off Of The Ladder While On The Ground
                if tile_exists(tile_surface_id[2]) or (gravity_slope = 1 and tile_exists(tile_ramp_id))
                    {
                        anim_current  = anim_standing
                        gravity_speed = 0
                        gravity_ladder = 0
                        jump_lock = 0
                        spring_timer = -1
                        ladder_moving = 0
                    }
            }
        //Additional Exit Conditions
        var ladder_check_id_top = tile_layer_find(surface_slopes,px,py-17);
        var ladder_check_id_bottom = tile_layer_find(surface_slopes,px,py);
        var ladder_check_compare_top = 0;
        var ladder_check_compare_bottom = 0;
        if tile_exists(ladder_check_id_top)
            {
                var tile_bg = tile_get_background(ladder_check_id_top);
                if orig_clip[tile_bg+scr_local_s_type,0] = scr_ladder_surface
                    {
                        ladder_check_compare_top = 1
                    }
            }
        if tile_exists(ladder_check_id_bottom)
            {
                var tile_bg = tile_get_background(ladder_check_id_bottom);
                if orig_clip[tile_bg+scr_local_s_type,0] = scr_ladder_surface
                    {
                        ladder_check_compare_bottom = 1
                    }
            }
        //If there is no ladder above the ceiling collision sensor, stop climbing the ladder
        if (ladder_check_id_bottom = 0 and ladder_check_compare_top = 1
        and joy_input[0,3] = 0 and joy_input[0,1] = 1)
        or (death[0] = 1)
        
            {
                anim_current  = anim_falling
                gravity_speed = 0
                gravity_ladder = 0
                ladder_moving = 0
                audio_stop_sound(snd_player_jump)
            }
        if ladder_check_compare_bottom = 0 and ladder_check_compare_top = 0
            {
                anim_current  = anim_standing
                gravity_speed = 0
                gravity_ladder = 0
                ladder_moving = 0
            }
        
    }
else p_off[0,1] = -27;

//============================================================================//
//                     Tile-Based Surface Flat Collisions                     //
//============================================================================//

//         Flat Surface Sensors         //
//--------------------------------------//

//Check for Tiles on Layer 0. (Flat Surface Collisions)
tile_surface_id[1] = tile_layer_find(surface_flats,px+p_off[0,0],py+p_off[0,1])    //Top    Collision Sensor
tile_surface_id[2] = tile_layer_find(surface_flats,px+p_off[1,0],py+p_off[1,1])    //Bottom Collision Sensor
tile_surface_id[3] = tile_layer_find(surface_flats,px+p_off[2,0],py+p_off[2,1])    //Left   Collision Sensor
tile_surface_id[4] = tile_layer_find(surface_flats,px+p_off[3,0],py+p_off[3,1])    //Right  Collision Sensor

//Tile Collision Companions For Flat Surface Collisions (Floors)
tile_companion_id[2,0] = tile_layer_find(surface_flats,px-8,py)
tile_companion_id[2,1] = tile_layer_find(surface_flats,px+8,py)

//Clear Tile Collision Companions' Values If We Are Touching A Slope
if tile_exists(tile_ramp_id)
    {
        tile_companion_id[2,0] = -1
        tile_companion_id[2,1] = -1
    }

//Flat Wall Running Sensors
if tile_angle!=0
    {
        //Because Our Angle Has Changed, Clear Flat Tile Collision Sensors
        tile_surface_id[3] = -1
        tile_surface_id[4] = -1
        tile_companion_id[2,0] = -1
        tile_companion_id[2,1] = -1

        //Also Clear Top And Bottom Collision Sensor If Our Angle Has Changed Dramatically
        if tile_angle &gt; 45 and tile_angle &lt;= 315
            {
                tile_surface_id[1] = -1
                tile_surface_id[2] = -1
            }
    }
else
    {
        tile_surface_wall_id=-1
        tile_surface_wall_id_forward=-1
    }

//Clear Flat Surface Sensors If We Have Fallen From The Ceiling
if tile_surface_ceiling_disable &gt; 0
    {
        tile_surface_ceiling_disable -=1
        tile_surface_id[2] = -1
        tile_surface_id[3] = -1
        tile_surface_id[4] = -1
    }

//Prevent the camera from following the player too early upon executing an upppercut as Lilac
if (anim_current = anim_lilac_uppercut and frame &gt; 149)
    view_clip = 0;

//        Flat Surface Collisions        //
//---------------------------------------//

//Clip to Tiles on Layer 0.

//Check for the ceiling.
if (tile_exists(tile_surface_id[1]) and flat_surface_lag = 0)
    {
        if bike_fling_speed &lt; 0 bike_fling_speed = 0;
        if py &lt;= py=abs(tile_get_y(tile_surface_id[1])+tile_get_height(tile_surface_id[1])+p_off[0,1])
        py=floor(tile_get_y(tile_surface_id[1])+tile_get_height(tile_surface_id[1])+p_off[0,1]);
        //Clear Gravity Speed Variable Upon Contact With Ceiling
        if gravity_speed&lt;0 gravity_speed=0;
        if lilac_dragon_boost_taper = 1
            {
                lilac_dragon_boost_taper = 0
                lilac_draogn_boost_taper_mod = 0
                gravity_speed = 2
            }
        bike_gravity_speed = 0
        //Disable spring timer (Prevents tunneling before the spring code has a chance to disable it)
        spring_timer=-1
        //Disable movement if we are running into the ceiling from the wall
        if xcompass = 90 or xcompass = 270 hsp = 0;
        //Make sure invulnerability frames have refreshed before scanning for sources of damage
        if hurt[0] = 0 and hurt_invuln = 39 and shield_invuln = 32 and invuln_hud_acti = 0
            {
                //---------Spikes---------//
                
                //Collect Background ID To Search For Spikes (Don't do this if we have a spike shield)
                if (shield_active = 0)
                or (shield_active = 1 and shield!=spr_shield_metal)
                    {
                        hurt[2] = tile_get_background(tile_surface_id[1])
                        var yes = 0;
                        //If We Are Touching Spikes, Register A Hit
                        switch(hurt[2])
                            {
                                case spr_spikes_3: {yes = 1; break;}
                                case spr_spikes_9: {yes = 1; break;}
                                case spr_spikes_13: {yes = 1; break;}
                                case spr_spikes_17: {yes = 1; break;}
                                case spr_spikes_20: {yes = 1; break;}
                            }
                        if yes = 1
                            scr_enemy_deal_damage(0.4,1,2);
                    }
                //If we are no longer on the ground, clear the background ID
                //(Otherwise, there will be a damage loop while in mid-air)
                else hurt[2] = 0;
            }
    }
    
//Check for the floor.
if (tile_exists(tile_surface_id[2]) and flat_surface_lag = 0)
    {
        if py &gt;= tile_get_y(tile_surface_id[2]) py=floor(tile_get_y(tile_surface_id[2]));
        //Reset gravity speed, if it was already above 0
        if gravity_speed&gt;0 gravity_speed=0;
        //Disable spring timer (Prevents tunneling before the spring code has a chance to disable it)
        spring_timer=-1
        gravity_slope=0
        var tile_surface_flat_bg_id = tile_get_background(tile_surface_id[2]);

        //Make sure invulnerability frames have refreshed before scanning for sources of damage
        if hurt[0] = 0 and hurt_invuln = 39 and shield_invuln = 32 and invuln_hud_acti = 0
            {    
                //---------Spikes---------//
                
                //Collect Background ID To Search For Spikes (Don't do this if we have a spike shield)
                if (shield_active = 0)
                or (shield_active = 1 and shield!=spr_shield_metal)
                    {
                        var yes = 0;
                        //If We Are Touching Spikes, Register A Hit
                        switch(tile_surface_flat_bg_id)
                            {
                                case spr_spikes_0: {yes = 1; break;}
                                case spr_spikes_1: {yes = 1; break;}
                                case spr_spikes_2: {yes = 1; break;}
                                case spr_spikes_4: {yes = 1; break;}
                                case spr_spikes_10: {yes = 1; break;}
                                case spr_spikes_14: {yes = 1; break;}
                            }
                        if yes = 1
                            scr_enemy_deal_damage(0.4,1,2);
                    }
                hurt[2] = 0
            }
        //Rail-Grinding Check
        if scr_get_flat_rail_check(tile_surface_flat_bg_id) = 1
            gravity_rail_check = 1;
        if gravity_rail_check = 1
            {
                gravity_rail_timer += 1
                if gravity_rail_timer = 1
                    {
                        gravity_rail_xdir = xdir
                        audio_play_sound(snd_rail_land,50,false)
                        audio_play_sound(snd_rail_loop,50,true)
                    }
                xdir = gravity_rail_xdir
                spring_timer = -1
                if abs(hsp) &lt; 5
                    hsp += slope_factor_running*xdir;
                if anim_current = anim_jump
                or anim_current = anim_falling
                    scr_set_rail_grinding_stop();
                //Exit condition
                if scr_get_flat_rail_check(tile_surface_flat_bg_id) = 0
                or (above_water = 0 and ground = 0)
                    scr_set_rail_grinding_stop();
            }
    }

//Check for the wall. (Left)
if tile_exists(tile_surface_id[3])
    {
        if px &lt;= tile_get_x(tile_surface_id[3])+tile_get_width(tile_surface_id[3])+15
        px=floor(tile_get_x(tile_surface_id[3])+tile_get_width(tile_surface_id[3])+15)
        //Override tile companion sensor's readings (Prevents tunneling before the tile companion sensor's code executes)
        tile_companion_id[2,0]=-1
        //Make sure invulnerability frames have refreshed before scanning for sources of damage
        if hurt[0] = 0 and hurt_invuln = 39 and shield_invuln = 32 and invuln_hud_acti = 0
            {    
                //---------Spikes---------//
                
                //Collect Background ID To Search For Spikes (Don't do this if we have a spike shield)
                if (shield_active = 0)
                or (shield_active = 1 and shield!=spr_shield_metal)
                    {
                        hurt[2] = tile_get_background(tile_surface_id[3])
                        var yes = 0;
                        //If We Are Touching Spikes, Register A Hit
                        switch(hurt[2])
                            {
                                case spr_spikes_5: {yes = 1; break;}
                                case spr_spikes_7: {yes = 1; break;}
                                case spr_spikes_11: {yes = 1; break;}
                                case spr_spikes_15: {yes = 1; break;}
                                case spr_spikes_18: {yes = 1; break;}
                            }
                        if yes = 1
                            scr_enemy_deal_damage(0.4,1,2);
                    }
                //If we are no longer on the ground, clear the background ID
                //(Otherwise, there will be a damage loop while in mid-air)
                else hurt[2] = 0;
            }
    }

//Check for the wall. (Right)
if tile_exists(tile_surface_id[4])
    {
        if px &gt;= tile_get_x(tile_surface_id[4])-15
        px=floor(tile_get_x(tile_surface_id[4])-15)
        //Override tile companion sensor's readings (Prevents tunneling before the tile companion sensor's code executes)
        tile_companion_id[2,1]=-1
        //Make sure invulnerability frames have refreshed before scanning for sources of damage
        if hurt[0] = 0 and hurt_invuln = 39 and shield_invuln = 32 and invuln_hud_acti = 0
            {    
                //---------Spikes---------//
                
                //Collect Background ID To Search For Spikes (Don't do this if we have a spike shield)
                if (shield_active = 0)
                or (shield_active = 1 and shield!=spr_shield_metal)
                    {
                        hurt[2] = tile_get_background(tile_surface_id[4])
                        var yes = 0;
                        //If We Are Touching Spikes, Register A Hit
                        switch(hurt[2])
                            {
                                case spr_spikes_6: {yes = 1; break;}
                                case spr_spikes_8: {yes = 1; break;}
                                case spr_spikes_12: {yes = 1; break;}
                                case spr_spikes_16: {yes = 1; break;}
                                case spr_spikes_19: {yes = 1; break;}
                            }
                        if yes = 1
                            scr_enemy_deal_damage(0.4,1,2);
                    }
                //If we are no longer on the ground, clear the background ID
                //(Otherwise, there will be a damage loop while in mid-air)
                else hurt[2] = 0;
            }
    }

//Check For Collisions With Tile Collision Sensor Companions (Left)
if (tile_exists(tile_companion_id[2,0]) and !tile_exists(tile_companion_id[2,1]) and !tile_exists(tile_surface_id[2]) and gravity_slope=0)
    {
        if py &gt;= tile_get_y(tile_companion_id[2,0]) py=floor(tile_get_y(tile_companion_id[2,0]));
        //Reset gravity speed, if it was already above 0
        if gravity_speed&gt;0 gravity_speed=0;
        //Disable spring timer (Prevents tunneling before the spring code has a chance to disable it)
        spring_timer=-1
        //Make sure invulnerability frames have refreshed before scanning for sources of damage
        if hurt[0] = 0 and hurt_invuln = 39 and shield_invuln = 32 and invuln_hud_acti = 0
            {    
                //---------Spikes---------//
                
                //Collect Background ID To Search For Spikes (Don't do this if we have a spike shield)
                if (shield_active = 0)
                or (shield_active = 1 and shield!=spr_shield_metal)
                    {
                        hurt[2] = tile_get_background(tile_companion_id[2,0])
                        var yes = 0;
                        //If We Are Touching Spikes, Register A Hit
                        switch(hurt[2])
                            {
                                case spr_spikes_0: {yes = 1; break;}
                                case spr_spikes_1: {yes = 1; break;}
                                case spr_spikes_2: {yes = 1; break;}
                                case spr_spikes_4: {yes = 1; break;}
                                case spr_spikes_10: {yes = 1; break;}
                                case spr_spikes_14: {yes = 1; break;}
                            }
                        if yes = 1
                            scr_enemy_deal_damage(0.4,1,2);
                    }
                //If we are no longer on the ground, clear the background ID
                //(Otherwise, there will be a damage loop while in mid-air)
                else hurt[2] = 0;
            }
    }

//Check For Collisions With Tile Collision Sensor Companions (Right)
if (!tile_exists(tile_companion_id[2,0]) and tile_exists(tile_companion_id[2,1]) and !tile_exists(tile_surface_id[2]) and gravity_slope=0)
    {
        if py &gt;= tile_get_y(tile_companion_id[2,1]) py=floor(tile_get_y(tile_companion_id[2,1]));
        //Reset gravity speed, if it was already above 0
        if gravity_speed&gt;0 gravity_speed=0;
        //Disable spring timer (Prevents tunneling before the spring code has a chance to disable it)
        spring_timer=-1
        //Make sure invulnerability frames have refreshed before scanning for sources of damage
        if hurt[0] = 0 and hurt_invuln = 39 and shield_invuln = 32 and invuln_hud_acti = 0
            {
                //---------Spikes---------//
                
                //Collect Background ID To Search For Spikes (Don't do this if we have a spike shield)
                if (shield_active = 0)
                or (shield_active = 1 and shield!=spr_shield_metal)
                    {
                        hurt[2] = tile_get_background(tile_companion_id[2,1])
                        var yes = 0;
                        //If We Are Touching Spikes, Register A Hit
                        switch(hurt[2])
                            {
                                case spr_spikes_0: {yes = 1; break;}
                                case spr_spikes_1: {yes = 1; break;}
                                case spr_spikes_2: {yes = 1; break;}
                                case spr_spikes_4: {yes = 1; break;}
                                case spr_spikes_10: {yes = 1; break;}
                                case spr_spikes_14: {yes = 1; break;}
                            }
                        if yes = 1
                            scr_enemy_deal_damage(0.4,1,2);
                    }
                //If we are no longer on the ground, clear the background ID
                //(Otherwise, there will be a damage loop while in mid-air)
                else hurt[2] = 0;
            }
    }

//============================================================================//
//                    Tile-Based Surface Sloped Collisions                    //
//============================================================================//

//       Sloped Surface Collisions       //
//---------------------------------------//

//  Layer 0 = Flat Surface
//  Layer 1 = Sloped Surface and FOF Collisions
//  Layer 2 = Platform Modifier Flags
//
//  Any other layer above or below these three can be used however you like!
//  If you would like to change these layer values without looking through the entire source,
//  simply modify these variables in the Tile Layers section of the Create Event:
//  surface_flats; surface_slopes; surface_modifiers

//=============================================================================//
//                  Tile-Based Sloped Wall Surface Collisions                  //
//=============================================================================//

//Copy the currently read angle of the slope for the slope wall and slope ceiling sensors, if we are on the ground
if gravity_speed = 0 angle_c = tile_angle;
//Otherwise, copy the current angle from the player's sprite, so the slope wall and slope ceiling sensors don't instantly clip
//against slope tile pieces
else                 angle_c = angle_a;

//    Sloped Wall Collisions (Left)    //
//-------------------------------------//

//Define Left Slope Collision Sensor's Position
slope_wall_left_x = px+lengthdir_x(27,angle_c+122)
slope_wall_left_y = py+lengthdir_y(27,angle_c+122)

//Left Slope Collision Sensor
slope_wall_left_id = tile_layer_find(surface_slopes,slope_wall_left_x,slope_wall_left_y)

//If we are colliding with a slope tile, halt speed on its surface based on X position
if (tile_exists(slope_wall_left_id))
    {
        //Collect Background ID of the Tile
        slope_wall_left_bg=tile_get_background(slope_wall_left_id)

        //Only allow execution/further reading of the tile if its collision mask exists
        if orig_clip[slope_wall_left_bg,0] != -8
            {
                //Get Player Coordinates Relative to the Tile's Origins
                slope_wall_left_pos_0=abs(tile_get_x(slope_wall_left_id)-slope_wall_left_x)   //Get X
                slope_wall_left_pos_1=abs(tile_get_y(slope_wall_left_id)-slope_wall_left_y)   //Get Y
        
                //Get Angle Data Based on Player Coordinates Relative to the Tile's Origins
                slope_wall_left_ang=orig_clip[slope_wall_left_bg+scr_local_angles,slope_wall_left_pos_0]
        
                //Halt on the walls of certain sloped tiles if we are not on the ground
                if  (orig_clip[slope_wall_left_bg+scr_local_s_type,0]=scr_bottom_right_outside_loop
                or   orig_clip[slope_wall_left_bg+scr_local_s_type,0]=scr_top_left_inside_loop)
                    {
                        //If safety checks for smoothly declipping from slopes are to be implemented, here is a good spot for that
                        if slope_wall_left_pos_0 &lt;= orig_clip[slope_wall_left_bg+scr_local_height,slope_wall_left_pos_1]
                            {
                                //Clip onto the ceiling if we are hitting the desired angles
                                if (slope_wall_left_ang &gt; 190 and slope_wall_left_ang &lt; 225)
                                and gravity_speed &lt; 0 and gravity_ceiling = 0 and hsp &lt;= 0 and anim_current != anim_milla_flutter
                                //Do not clip onto the ceiling if we are underwater
                                and py &lt;= water_height and !instance_exists(water_ID)
                                and tile_angle = 0
                                //Clip if we are Carol driving up the wall on her bike
                                or (bike = 1 and anim_current=anim_carol_wall_jump)
                                    {
                                        gravity_ceiling = 1
                                        //Raise the player's feet to the slope's ceiling
                                        py-=23
                                    }
                                //Otherwise, clip to the wall
                                if (gravity_ceiling = 0 and gravity_speed &gt; 0 or ground=1)
                                or (gravity_speed &lt; 0 and (slope_wall_left_ang &lt;= 190 or slope_wall_left_ang &gt;= 225))
                                //And check if Milla is fluttering. She is the only character who isn't allowed to clip onto
                                //ceilings via her jump action, so we need a character-specific plug here, unfortunately :^(
                                or (anim_current = anim_milla_flutter and slope_wall_left_ang &gt; 190 and slope_wall_left_ang &lt; 225)
                                //And an unfortunate extra character-specific plug here for Lilac's dragon boost :^(
                                or (anim_current=anim_lilac_dragon_boost_2)
                                    {
                                        tile_wall_left_trig = 1
                                        //Set X Position Of Player Along the Slope
                                        px = floor(tile_get_x(slope_wall_left_id))+orig_clip[slope_wall_left_bg+scr_local_height,slope_wall_left_pos_1]+14
                                    }
                                //If we were on the ground during the collision, reset collision detection
                                if ground = 1 tile_wall_left_trig = 0;
                            }
                        //If we are below the wall's surface, disable collision trigger
                        if slope_wall_left_pos_1 &gt; orig_clip[slope_wall_left_bg,slope_wall_left_pos_0] tile_wall_left_trig = 0;
                    }
                //Halt on the walls of certain sloped tiles if we are not on the ground
                if  (orig_clip[slope_wall_left_bg+scr_local_s_type,0]=scr_bottom_left_inside_loop
                or   orig_clip[slope_wall_left_bg+scr_local_s_type,0]=scr_top_right_outside_loop)
                    {
                        if slope_wall_left_pos_0 &lt;= orig_clip[slope_wall_left_bg+scr_local_height,slope_wall_left_pos_1]
                            {
                                tile_wall_left_trig = 0
                                if ground = 0 tile_wall_left_trig = 1;
                                //Trigger wall collisions if we are on the ground
                                if ground = 1 and hsp &lt; 0 {tile_wall_left_trig = 1; hsp = 0;}
                                //Set X Position Of Player Along the Slope
                                px = floor(tile_get_x(slope_wall_left_id))+orig_clip[slope_wall_left_bg+scr_local_height,slope_wall_left_pos_1]+14
                            }
                        //Release wall trigger if we are not on the ground
                        if slope_wall_left_pos_0 &gt; orig_clip[slope_wall_left_bg+scr_local_height,slope_wall_left_pos_1] tile_wall_left_trig = 0;
                    }
                if orig_clip[slope_wall_left_bg+scr_local_s_type,0]=scr_ladder_surface
                    {
                        tile_wall_left_trig = 0
                    }
                if orig_clip[slope_wall_left_bg+scr_local_s_type,0]=scr_hang_bar_surface
                    {
                        //Clip To The Tile
                        if (gravity_ladder = 0 and gravity_speed &gt; 0 and py+p_off[0,1] &gt; tile_get_y(slope_wall_left_id)+tile_get_height(slope_wall_left_id)-4)
                        //Ignore clipping if the player is pressing down
                        and joy_input[0,1] = 0
                        and slope_wall_left_bg != spr_hangbar_ignore
                            {
                                //Get hangbar coordinates
                                gravity_x = tile_get_x(slope_wall_left_id)+tile_get_width(slope_wall_left_id)/2
                                gravity_y = tile_get_y(slope_wall_left_id)+tile_get_height(slope_wall_left_id)+32
                                //Clip to the center of the hangbar
                                px = gravity_x
                                py = gravity_y
                                //Enable hangbar state
                                gravity_ladder = 2;
                                scr_set_rail_grinding_stop()
                                //Enable hangbar input state
                                gravity_hang = 1;
                                //Play sound
                                audio_play_sound(snd_hangbar,50,false)
                            }
                        tile_wall_left_trig = 0
                    }
            }
        else
            {
                if !audio_is_playing(character_parry)
                    scr_set_message("Warning: This tile lacks a collision mask!");
            }
    }
else
    {
        tile_wall_left_trig = 0;
        slope_wall_left_id = -1;
    }

//    Sloped Wall Collisions (Right)    //
//--------------------------------------//

//Define Right Slope Collision Sensor's Position
slope_wall_right_x = px+lengthdir_x(27,angle_c+57)
slope_wall_right_y = py+lengthdir_y(27,angle_c+57)

//Right Slope Collision Sensor
slope_wall_right_id = tile_layer_find(surface_slopes,slope_wall_right_x,slope_wall_right_y)

//If we are colliding with a slope tile, halt speed on its surface based on X position
if tile_exists(slope_wall_right_id)
    {
        //Collect Background ID of the Tile
        slope_wall_right_bg=tile_get_background(slope_wall_right_id)

        //Only allow execution/further reading of the tile if its collision mask exists
        if orig_clip[slope_wall_right_bg,0] != -8
            {
                //Get Player Coordinates Relative to the Tile's Origins
                slope_wall_right_pos_0=abs(tile_get_x(slope_wall_right_id)-slope_wall_right_x)   //Get X
                slope_wall_right_pos_1=abs(tile_get_y(slope_wall_right_id)-slope_wall_right_y)   //Get Y
        
                //Get Angle Data Based on Player Coordinates Relative to the Tile's Origins
                slope_wall_right_ang=orig_clip[slope_wall_right_bg+scr_local_angles,slope_wall_right_pos_0]
        
                //Halt on the walls of certain sloped tiles if we are not on the ground
                if  (orig_clip[slope_wall_right_bg+scr_local_s_type,0]=scr_bottom_left_outside_loop
                or   orig_clip[slope_wall_right_bg+scr_local_s_type,0]=scr_top_right_inside_loop)
                and orig_clip[slope_wall_right_bg+scr_local_height,slope_wall_right_pos_1] &gt;= 0
                    {
                        if slope_wall_right_pos_0 &gt;= orig_clip[slope_wall_right_bg+scr_local_height,slope_wall_right_pos_1]
                            {
                                //Clip onto the ceiling if we are hitting the desired angles
                                if (slope_wall_right_ang &gt; 135 and slope_wall_right_ang &lt; 170
                                and gravity_speed &lt; 0 and gravity_ceiling = 0 and hsp &gt;= 0 and anim_current != anim_milla_flutter)
                                //Do not clip onto the ceiling if we are underwater
                                and py &lt;= water_height and !instance_exists(water_ID)
                                and tile_angle = 0
                                //Clip if we are Carol driving up the wall on her bike
                                or (bike = 1 and anim_current=anim_carol_wall_jump)
                                    {
                                        gravity_ceiling = 1
                                        //Raise the player's feet to the slope's ceiling
                                        py-=23
                                    }
                                //Otherwise, clip to the wall
                                if (gravity_ceiling = 0 and gravity_speed &gt; 0 or ground=1)
                                or (gravity_speed &lt; 0 and (slope_wall_right_ang &lt;= 135 or slope_wall_right_ang &gt;= 170))
                                //And check if Milla is fluttering. She is the only character who isn't allowed to clip onto
                                //ceilings via her jump action, so we need a character-specific plug here, unfortunately :^(
                                or (anim_current = anim_milla_flutter and slope_wall_right_ang &gt; 135 and slope_wall_right_ang &lt; 170)
                                //And an unfortunate extra character-specific plug here for Lilac's dragon boost :^(
                                or (anim_current=anim_lilac_dragon_boost_2)
                                    {
                                        tile_wall_right_trig = 1
                                        //Set X Position Of Player Along the Slope
                                        px = floor(tile_get_x(slope_wall_right_id))+orig_clip[slope_wall_right_bg+scr_local_height,slope_wall_right_pos_1]-14
                                    }
                                //If we were on the ground during the collision, reset collision detection
                                if ground = 1 tile_wall_right_trig = 0;
                            }
                        //If we are below the wall's surface, disable collision trigger
                        if slope_wall_right_pos_1 &gt; orig_clip[slope_wall_right_bg,slope_wall_right_pos_0] tile_wall_right_trig = 0;
                    }
                //Halt on the walls of certain sloped tiles if we are not on the ground
                if  (orig_clip[slope_wall_right_bg+scr_local_s_type,0]=scr_bottom_right_inside_loop
                or   orig_clip[slope_wall_right_bg+scr_local_s_type,0]=scr_top_left_outside_loop)
                and orig_clip[slope_wall_right_bg+scr_local_height,slope_wall_right_pos_1] &gt;= 0
                    {
                        if slope_wall_right_pos_0 &gt;= orig_clip[slope_wall_right_bg+scr_local_height,slope_wall_right_pos_1]
                            {
                                tile_wall_right_trig = 0
                                if ground = 0 tile_wall_right_trig = 1;
                                //Trigger wall collisions if we are on the ground
                                if ground = 1 and hsp &gt; 0 {tile_wall_right_trig = 1; hsp = 0;}
                                //Set X Position Of Player Along the Slope
                                px = floor(tile_get_x(slope_wall_right_id))+orig_clip[slope_wall_right_bg+scr_local_height,slope_wall_right_pos_1]-14
                            }
                        //Release wall trigger if we are trailing backwards
                        if slope_wall_right_pos_0 &lt; orig_clip[slope_wall_right_bg+scr_local_height,slope_wall_right_pos_1] tile_wall_right_trig = 0;
                    }
                if orig_clip[slope_wall_right_bg+scr_local_s_type,0]=scr_ladder_surface
                    {
                        tile_wall_right_trig = 0
                    }
                if orig_clip[slope_wall_right_bg+scr_local_s_type,0]=scr_hang_bar_surface
                    {
                        //Clip To The Tile
                        if (gravity_ladder = 0 and gravity_speed &gt; 0 and py+p_off[0,1] &gt; tile_get_y(slope_wall_right_id)+tile_get_height(slope_wall_right_id)-4)
                        //Ignore clipping if the player is pressing down
                        and joy_input[0,1] = 0
                        and slope_wall_right_bg != spr_hangbar_ignore
                            {
                                //Get hangbar coordinates
                                gravity_x = tile_get_x(slope_wall_right_id)+tile_get_width(slope_wall_right_id)/2
                                gravity_y = tile_get_y(slope_wall_right_id)+tile_get_height(slope_wall_right_id)+32
                                //Clip to the center of the hangbar
                                px = gravity_x
                                py = gravity_y
                                //Enable hangbar state
                                gravity_ladder = 2;
                                scr_set_rail_grinding_stop()
                                //Enable hangbar input state
                                gravity_hang = 1;
                                //Play sound
                                audio_play_sound(snd_hangbar,50,false)
                            }
                        tile_wall_right_trig = 0
                    }
            }
        else
            {
                if !audio_is_playing(character_parry)
                    scr_set_message("Warning: This tile lacks a collision mask!");
            }
    }
//Disable Wall Detection And Tile-Collision Data Switching
else
    {
        tile_wall_right_trig = 0;
        slope_wall_right_id = -1;
    }

//=============================================================================//
//                     Tile-Based Slope Ceiling Collisions                     //
//=============================================================================//

//      Sloped Ceiling Collisions      //
//-------------------------------------//

//  Layer 0 = Flat Surface
//  Layer 1 = Sloped Surface and FOF Collisions
//  Layer 2 = Platform Modifier Flags

//Define Slope Ceiling Collision Sensor's Position
slope_ceiling_x = px+lengthdir_x(27,tile_angle+90)
slope_ceiling_y = py+lengthdir_y(27,tile_angle+90)

//Ceiling Slope Collision Sensor
tile_ceiling_id = tile_layer_find(surface_slopes,slope_ceiling_x,slope_ceiling_y)

//If we are colliding with a slope tile, halt speed on its surface based on X position
if (tile_exists(tile_ceiling_id) and xcompass = 0)
    {
        //Collect Background ID of the Tile
        tile_ceiling_bg=tile_get_background(tile_ceiling_id)

        //Only allow execution/further reading of the tile if its collision mask exists
        if orig_clip[tile_ceiling_bg,0] != -8
            {
                //Get Player Coordinates Relative to the Tile's Origins
                tile_ceiling_pos_0=abs(tile_get_x(tile_ceiling_id)-slope_ceiling_x)   //Get X
                tile_ceiling_pos_1=abs(tile_get_y(tile_ceiling_id)-slope_ceiling_y)   //Get Y
        
                //Get Angle Data Based on Player Coordinates Relative to the Tile's Origins
                slope_ceiling_ang=orig_clip[tile_ceiling_bg+scr_local_angles,tile_ceiling_pos_0]
        
                //Halt on the ceilings of certain sloped tiles
                if (orig_clip[tile_ceiling_bg+scr_local_s_type,0]!=-1)
                    {
                        //Halt on the walls of certain sloped tiles if we are not on the ground
                        if  (orig_clip[tile_ceiling_bg+scr_local_s_type,0]=scr_bottom_left_outside_loop
                        or   orig_clip[tile_ceiling_bg+scr_local_s_type,0]=scr_bottom_right_outside_loop
                        or   orig_clip[tile_ceiling_bg+scr_local_s_type,0]=scr_top_left_inside_loop
                        or   orig_clip[tile_ceiling_bg+scr_local_s_type,0]=scr_top_right_inside_loop)
                        and (floor(tile_ceiling_pos_1) &lt;= orig_clip[tile_ceiling_bg,tile_ceiling_pos_0]
                        and gravity_speed &lt; 0 and gravity_ceiling = 0)
                            {
                                //Clip onto the ceiling if we are hitting the desired angles while dragon boosting
                                if (((slope_ceiling_ang &gt; 135 and slope_ceiling_ang &lt; 170)
                                or (anim_current=anim_lilac_dragon_boost_2 and
                                (orig_clip[tile_ceiling_bg+scr_local_s_type,0]=scr_top_left_inside_loop or orig_clip[tile_ceiling_bg+scr_local_s_type,0]=scr_top_right_inside_loop)))
                                and gravity_speed &lt; 0 and gravity_ceiling = 0 and anim_current=anim_lilac_dragon_boost_2)
                                //Do not clip onto the ceiling if we are underwater
                                and py &lt;= water_height and !instance_exists(water_ID)
                                and tile_angle = 0
                                and anim_current != anim_milla_flutter
                                //Clip if we are Carol driving up the wall on her bike
                                or bike = 1 and anim_current=anim_carol_wall_jump
                                    {
                                        gravity_ceiling = 1
                                        //Raise the player's feet to the slope's ceiling
                                        py-=23
                                    }
                                else
                                    {
                                        //Bump the player's head against the ceiling
                                        py = floor(tile_get_y(tile_ceiling_id))+orig_clip[tile_ceiling_bg,tile_ceiling_pos_0]+27
                                        gravity_speed=0
                                        tile_collision_ceiling_trigger = 1
                                    }
                             }
                        else tile_collision_ceiling_trigger = 0;
                        //Bump the player's head against the ceiling
                        if  (orig_clip[tile_ceiling_bg+scr_local_s_type,0]=scr_slope_ceiling)
                        and (tile_ceiling_pos_1 &lt; orig_clip[tile_ceiling_bg,tile_ceiling_pos_0])
                            {
                                py = floor(tile_get_y(tile_ceiling_id))+orig_clip[tile_ceiling_bg,tile_ceiling_pos_0]+27
                                gravity_speed = 2
                                tile_collision_ceiling_trigger = 1
                            }
                        if orig_clip[tile_ceiling_bg+scr_local_s_type,0]=scr_ladder_surface
                            {
                                //If the player is pressing up, enable ladder climbing
                                if joy_input[0,3] = 1 and joy_input[0,1] = 0
                                and gravity_ladder = 0
                                and xcompass != 180 and xcompass != 360
                                    {
                                        //Set ladder swinging animation state
                                        //if abs(hsp) &gt; 4 {ladder_state = 1}
                                        //Enable ladder climbing
                                        gravity_ladder = 1;
                                        scr_set_rail_grinding_stop();
                                        anim_current = anim_ladder_climbing;
                                        //Clip to the center of the ladder
                                        if xcompass = 0 px = tile_get_x(tile_ceiling_id)+20;
                                        py-=1
                                        if tile_surface_wall_xcompass = 90
                                        or tile_surface_wall_xcompass = 270
                                            {
                                                tile_ramp_pos[0]    = 0
                                                tile_ramp_pos[1]    = 0
                                                gravity_slope       = 0
                                                tile_angle          = 0
                                                xcompass            = 0
                                                tile_check_slope_priority = 0
                                                tile_surface_wall_xcompass = 0
                                                gravity_speed = 0
                                                px = tile_get_x(tile_ceiling_id)+20
                                            }
                                        if xcompass = 90 or xcompass = 270
                                            {
                                                gravity_slope = 0                   //Override slope clipping for this one frame
                                                xcompass = 0                        //Override current tile compass direction
                                                tile_check_slope_priority = 0       //Slope Priority For Flat Surface Running
                                                tile_surface_wall_xcompass = 0      //Tile Compass For Flat Surface Running
                                            }
                                    }
                                tile_collision_ceiling_trigger = 0
                            }
                        if orig_clip[tile_ceiling_bg+scr_local_s_type,0]=scr_hang_bar_surface
                            {
                                //Clip To The Tile
                                if (gravity_ladder = 0 and gravity_speed &gt; 0 and py+p_off[0,1] &gt; tile_get_y(tile_ceiling_id)+tile_get_height(tile_ceiling_id)-4)
                                //Ignore clipping if the player is pressing down
                                and joy_input[0,1] = 0
                                and tile_ceiling_bg != spr_hangbar_ignore
                                    {
                                        //Get hangbar coordinates
                                        gravity_x = tile_get_x(tile_ceiling_id)+tile_get_width(tile_ceiling_id)/2
                                        gravity_y = tile_get_y(tile_ceiling_id)+tile_get_height(tile_ceiling_id)+32
                                        //Clip to the center of the hangbar
                                        px = gravity_x
                                        py = gravity_y
                                        //Enable hangbar state
                                        gravity_ladder = 2;
                                        //Enable hangbar input state
                                        gravity_hang = 1;
                                        //Play sound
                                        audio_play_sound(snd_hangbar,50,false)
                                    }
                                tile_collision_ceiling_trigger = 0
                            }
                    }
            }
        else
            {
                if !audio_is_playing(character_parry)
                    scr_set_message("Warning: This tile lacks a collision mask!");
            }
    }
//Disable ceiling collisions otherwise
else
    {
        tile_collision_ceiling_trigger = 0;
        tile_ceiling_id = -1;
    }

if tile_surface_ceiling_override = 1
    {
        if hsp &lt; tile_surface_hor_speed tile_surface_hor_speed = abs(tile_surface_hor_speed);
        if hsp &gt; tile_surface_hor_speed tile_surface_hor_speed = -tile_surface_hor_speed;
        tile_surface_ceiling_override = 0
    }

//============================================================================//
//                 Tile-Based Sloped Floor Surface Collisions                 //
//============================================================================//

//Slope Collision Sensor
tile_ramp_id = tile_layer_find(surface_slopes,px,py)

//If we are colliding with a slope tile, clip to its surface based on X position
if tile_exists(tile_ramp_id)
    {
        //Collect Background ID of the Tile
        tile_ramp_id_debug=tile_get_background(tile_ramp_id)

        //Only allow execution/further reading of the tile if its collision mask exists
        if orig_clip[tile_ramp_id_debug,0] != -8
            {
                //Get Player Coordinates Relative to the Tile's Origins
                tile_ramp_pos[0]=abs(tile_get_x(tile_ramp_id)-px)   //Get X
                tile_ramp_pos[1]=abs(tile_get_y(tile_ramp_id)-py)   //Get Y
        
                //Check For Negative Values
                if tile_ramp_pos[0] &lt; 0 tile_ramp_pos[0] = 0;
                if tile_ramp_pos[1] &lt; 0 tile_ramp_pos[1] = 0;
        
                //Increment Flat Wall Running State
                if tile_check_slope_priority = 1 tile_check_slope_priority = 2;
                //Reset Flat Wall Running State If We Are In Floor Mode
                if (tile_angle &lt;= 45 or tile_angle &gt; 315)
                    {
                        tile_check_slope_priority = 0
                        tile_surface_wall_xcompass = 0
                    }
                //Or Ceiling Mode
                if (tile_angle &gt; 180 and tile_angle &lt;= 225 or tile_angle &gt;= 135 and tile_angle &lt; 180)
                    tile_check_slope_priority = 0;

                gravity_fof_validation = 0

                //Rail-Grinding Check
                gravity_rail_check = scr_get_rail_check(tile_ramp_id_debug)

                //if bike = 1
                //    gravity_rail_check = 0;
                if gravity_rail_check = 1
                    {
                        if gravity_slope = 1
                            {
                                gravity_rail_timer += 1
                                if gravity_rail_timer = 1
                                    {
                                        gravity_rail_xdir = xdir
                                        audio_play_sound(snd_rail_land,50,false)
                                        audio_play_sound(snd_rail_loop,50,true)
                                    }
                                xdir = gravity_rail_xdir
                                if abs(hsp) &lt; 5 and tile_angle = 0
                                    hsp += slope_factor_running*xdir;
                                if abs(hsp) &lt; 8 and tile_angle != 0
                                    hsp += slope_factor_running*xdir;
                                spring_timer = -1
                            }
                        if (tile_ramp_pos[1] &gt; orig_clip[tile_ramp_id_debug,tile_ramp_pos[0]]+16 and xcompass = 0)
                        or ground = 0
                        or gravity_speed &gt; 0
                        or anim_current = anim_jump
                        or anim_current = anim_falling
                        //or orig_clip[tile_ramp_id_debug+scr_local_s_type,0] != scr_floor_over_floor
                            scr_set_rail_grinding_stop();
                    }

                //=========Ground Collisions=========//
                if (xcompass = 0)
                    {
                        //Check If Player Y is Greater Than Slope's Current Height
                        if tile_ramp_pos[1] &gt;= orig_clip[tile_ramp_id_debug,tile_ramp_pos[0]] gravity_slope=1;
                        //If Player Y is Above the Slope, Reset Angle
                        if tile_ramp_pos[1] &lt;  orig_clip[tile_ramp_id_debug,tile_ramp_pos[0]] tile_angle = 0;
        
                        //Also check if we are walking by a slope launching point
                        //Errors with collisions seem to occur more frequently with this code block; leave it be for now
                        //if orig_clip[tile_ramp_id_debug+scr_local_launch,0]!=-1
                        //    {
                        //        if  floor(px)  &gt;= tile_get_x(tile_ramp_id)+orig_clip[tile_ramp_id_debug+scr_local_launch,0] -4
                        //        and floor(px)  &lt;= tile_get_x(tile_ramp_id)+orig_clip[tile_ramp_id_debug+scr_local_launch,0] +4
                        //        and abs(hsp) &gt; 1 and tile_angle = 0;
                        //            gravity_slope = 0;
                        //    }
                        //But wait! Before allowing clipping, check the slope's surface type to determine if we
                        //should collide with it in floor mode, and if we shouldn't, overrule collision triggers
                        switch(orig_clip[tile_ramp_id_debug+scr_local_s_type,0])
                            {
                                //Clip to outside loops under the right conditions. We will use a script to keep variable resets consistent.
                                //Scripts are okay in relation to our performance budget, as long as they're only executed for a sub-frame at a time,
                                //and aren't doing any heavy lifting. :^P
                                case scr_bottom_left_outside_loop:
                                    {
                                        gravity_slope=0
                                        ladder_moving = 0
                                        if gravity_ceiling = 1 {tile_wall_speed_copy = tile_wall_speed_copy; scr_set_ceiling_clipping();}
                                        break;
                                    }
                                case scr_bottom_right_outside_loop:
                                    {
                                        gravity_slope=0
                                        ladder_moving = 0
                                        if gravity_ceiling = 1 {tile_wall_speed_copy = -tile_wall_speed_copy; scr_set_ceiling_clipping();}
                                        break;
                                    }
                                //Clip to inside loops under the right conditions
                                case scr_top_left_inside_loop:
                                    {
                                        gravity_slope=0
                                        ladder_moving = 0
                                        if gravity_ceiling = 1 {tile_wall_speed_copy = -tile_wall_speed_copy; scr_set_ceiling_clipping();}
                                        break;
                                    }
                                case scr_top_right_inside_loop:
                                    {
                                        gravity_slope=0
                                        ladder_moving = 0
                                        if gravity_ceiling = 1 {tile_wall_speed_copy = tile_wall_speed_copy; scr_set_ceiling_clipping();}
                                        break;
                                    }
                                //And while we're at it, let's check to see if and when we should be
                                //colliding with floating platforms!
                                case scr_floor_over_floor:
                                    {
                                        //Pan camera pre-emptively, ahead of landing on a platform, the height of which we've already cleared
                                        //if  tile_ramp_pos[1] &lt; orig_clip[tile_ramp_id_debug,tile_ramp_pos[0]]
                                        //and view_clip=0
                                        //    view_yview[view_port]-=view_panspeed;
                                        //If we're making contact with the slope tile, and are currently falling, trigger a collision
                                        if  tile_ramp_pos[1] &gt;= orig_clip[tile_ramp_id_debug,tile_ramp_pos[0]]
                                        and gravity_speed &gt;= 0 gravity_slope = 1;
                                        //Otherwise, allow the player to pass through it
                                        if gravity_speed &lt; 0 gravity_slope = 0;
                                        //Check if we should be performing pixel-perfect clipping with this fof tile
                                        gravity_fof_validation = scr_get_fof_check(tile_ramp_id_debug)
                                        if tile_ramp_pos[1] &gt; orig_clip[tile_ramp_id_debug,tile_ramp_pos[0]]+32
                                            {
                                                gravity_fof_validation = 0
                                                gravity_slope = 0
                                            }
                                        break;
                                    }
                                //Let go of the ceiling when the player has slowed down
                                case scr_slope_ceiling:
                                    {
                                        gravity_slope=0
                                        ladder_moving = 0
                                        break;
                                    }
                                case scr_hang_bar_surface:
                                    {
                                        gravity_slope=0;
                                        //Clip To The Tile
                                        if (gravity_ladder = 0 and gravity_speed &gt; 0 and py+p_off[0,1] &gt; tile_get_y(tile_ramp_id)+tile_get_height(tile_ramp_id)-4)
                                        //Ignore clipping if the player is pressing down
                                        and joy_input[0,1] = 0
                                        and tile_ramp_id_debug != spr_hangbar_ignore
                                            {
                                                //Get hangbar coordinates
                                                gravity_x = tile_get_x(tile_ramp_id)+tile_get_width(tile_ramp_id)/2
                                                gravity_y = tile_get_y(tile_ramp_id)+tile_get_height(tile_ramp_id)+32
                                                //Clip to the center of the hangbar
                                                px = gravity_x
                                                py = gravity_y
                                                //Enable hangbar state
                                                gravity_ladder = 2;
                                                //Enable hangbar input state
                                                gravity_hang = 1;
                                                //Play sound
                                                audio_play_sound(snd_hangbar,50,false)
                                            }
                                        break;
                                    }
                                case scr_ladder_surface:
                                    {
                                        var flat_id   = tile_layer_find(surface_flats,px,py-16);
                                        var ladder_id = tile_layer_find(surface_slopes,px,py-16);
                                        if !tile_exists(ladder_id) and gravity_ladder = 0
                                            {
                                                if gravity_speed &gt;= 0 and flat_id = -1 and gravity_ladder = 0 gravity_slope = 1;
                                                //If the player is pressing down, enable ladder climbing
                                                if joy_input[0,1] = 1 and joy_input[0,3] = 0 and gravity_slope = 1
                                                and abs(hsp) &lt; 2 and joy_input[1,2] = 0
                                                    {
                                                        //Clip to the center of the ladder
                                                        px = tile_get_x(tile_ramp_id)+tile_get_width(tile_ramp_id)/2
                                                        //Enable ladder climbing
                                                        gravity_ladder = 1
                                                        anim_current = anim_ladder_climbing;
                                                        gravity_slope = 0
                                                        scr_set_rail_grinding_stop()
                                                    }
                                                fof_disable = 32
                                            }
                                        if gravity_ladder = 1 gravity_slope = 0;
                                        //Ignore Collisions Otherwise
                                        if tile_exists(ladder_id)
                                            {
                                                if orig_clip[tile_ramp_id_debug+scr_local_s_type,0]=scr_ladder_surface
                                                    {
                                                        gravity_slope = 0;
                                                        //If the player is pressing up, enable ladder climbing
                                                        if joy_input[0,3] = 1 and joy_input[0,1] = 0
                                                            {
                                                                //Set ladder swinging animation state
                                                                //if abs(hsp) &gt; 4 {ladder_state = 1}
                                                                //Enable ladder climbing
                                                                gravity_ladder = 1;
                                                                scr_set_rail_grinding_stop()
                                                                anim_current = anim_ladder_climbing
                                                                //Clip to the center of the ladder
                                                                px = tile_get_x(tile_ramp_id)+20
                                                            }
                                                    }
                                            }
                                        break;
                                    }
                                default:
                                    {
                                        gravity_fofset = py
                                        ladder_moving = 0
                                        break;
                                    }
                            }
                        //Also check if floor collisions are allowed on this tile
                        if orig_clip[tile_ramp_id_debug,tile_ramp_pos[0]] = -1 gravity_slope = 0;
        
                        //Because the inside loop pieces have collision data beyond their loops, so players can
                        //stand on them when used as ramps, it's possible for players to "squeeze through" the
                        //connected loop pieces by as little as one pixel
                        if (orig_clip[tile_ramp_id_debug+scr_local_s_type,0]!=-1 and orig_clip[tile_ramp_id_debug+scr_local_launch,0]!=-1)
                            {
                                //Slope Collision Sensor
                                var tile_check_ceiling_id = tile_layer_find(surface_slopes,px,py-16)
        
                                if (tile_check_ceiling_id != -1)
                                    {
                                        //Collect Background ID of the Tile
                                        tile_check_ceiling_bg=tile_get_background(tile_check_ceiling_id)
                
                                        //If We Are Sandwiched Between Two Loop Pieces, Push The Player Away
                                        if  (orig_clip[tile_check_ceiling_bg+scr_local_s_type,0]=scr_top_right_inside_loop
                                        and tile_ramp_pos[0] &gt;= orig_clip[tile_ramp_id_debug+scr_local_launch,0]-1)
                                            {
                                                px = tile_get_x(tile_ramp_id)+orig_clip[tile_ramp_id_debug+scr_local_launch,0]-14;
                                                hsp = 0
                                                gravity_slope = 0
                                            }
                                        if (orig_clip[tile_check_ceiling_bg+scr_local_s_type,0]=scr_top_left_inside_loop
                                        and tile_ramp_pos[0] &lt;= orig_clip[tile_ramp_id_debug+scr_local_launch,0]+1)
                                            {
                                                px = tile_get_x(tile_ramp_id)+orig_clip[tile_ramp_id_debug+scr_local_launch,0]+14;
                                                hsp = 0
                                                gravity_slope = 0
                                            }
                                    }
                            }
        
                        //If Player is Colliding with Slope, Clip to its Y Coordinates
                        if gravity_slope=1
                            {
                                //Set Y Position Of Player Along the Slope
                                py = floor(tile_get_y(tile_ramp_id))+orig_clip[tile_ramp_id_debug,tile_ramp_pos[0]]
                                //Set Angle Position Along the Slope
                                tile_angle = orig_clip[tile_ramp_id_debug+scr_local_angles,tile_ramp_pos[0]]
                            }
                    }
        
                //Do not clip or change compass directions if the slope tile has no length map data
                if (orig_clip[tile_ramp_id_debug+scr_local_height,0]!=-1) and (gravity_slope=1 and gravity_speed=0 or tile_check_slope_priority &gt;= 2)
                    {
                        //=========Sloped Wall Collisions=========//
                        if (xcompass = 90 or xcompass = 270)
                            {
                                //=========Flat Wall Collisions=========//

                                var tile_surface_wall_direction = abs(hsp)
                                var tile_surface_wall_vertical  = -abs(hsp)
        
                                //Search for flat wall surfaces towards the left
                                if xcompass = 270 tile_surface_wall_direction = -abs(hsp);
        
                                //Search for flat wall surfaces towards the floor
                                if (xcompass = 270 and hsp &gt;= 0) or (xcompass = 90 and hsp &lt;= 0) tile_surface_wall_vertical = abs(hsp);
        
                                //Check for Tiles on Layer 0. (Flat Surface Collisions)
                                tile_surface_wall_id = tile_layer_find(surface_flats,px+tile_surface_wall_direction,py+tile_surface_wall_vertical)
        
                                //Override the sensor's reading if we are on a slope piece
                                if tile_check_slope_priority &gt;= 2 or (tile_angle &lt;= 45 or tile_angle &gt; 315) tile_surface_wall_id=-1;
        
                                //HACK DETECTION!!! Comprehension of Slope Factor in this engine is incomplete
                                //The math falls apart at the extreme compass directions
                                //This prevents the player from building up speed perpetually
                                //while running towards the left on a donut loop
                                if tile_angle = 270 and hsp &lt; 0
                                and orig_clip[tile_ramp_id_debug+scr_local_s_type,0] = scr_top_right_outside_loop
                                    hsp+=slope_factor_running*2;
                        
                                //if tile_angle = 180 hsp+=slope_factor_running*xdir;
        
                                //If We Are Touching a Flat Surface Tile, Interact With It As If It Were A Floor
                                if tile_exists(tile_surface_wall_id)
                                    {
                                        tile_check_wall_id_hold = tile_surface_wall_id
                                        tile_check_wall_id_dir = tile_surface_wall_direction
                                    }
                                //Reset tile compass for flat wall running
                                if !tile_exists(tile_surface_wall_id) and tile_surface_wall_xcompass = 180
                                    {
                                        tile_surface_ceiling_disable = 0
                                        tile_surface_wall_xcompass = 0
                                        tile_surface_ceiling_timer = 0
                                        tile_surface_hor_speed = 0
                                        tile_check_wall_id_hold = -1
                                        tile_check_wall_id_dir = 1
                                    }
                                //Check if we are at the launching point along a slope
                                if orig_clip[tile_ramp_id_debug+scr_local_launch,0] &gt; 0
                                    {
                                        //Determine the direction of the player's movement based on their speed and angle
                                        var speed_length_x = lengthdir_x(hsp,tile_angle)
                                        var speed_length_y = lengthdir_y(hsp,tile_angle)
                                        //Check if there's a slope tile connected to the one above us. Doesn't matter which! You shouldn't
                                        //have another slope tile in the way of the one you'd like for the player to launch from :^P
                                        var tile_check_ramp_middle_id = tile_layer_find(surface_slopes,px,py-24)
                                        var tile_check_ramp_left_id   = tile_layer_find(surface_slopes,px-27,py-24)
                                        var tile_check_ramp_right_id  = tile_layer_find(surface_slopes,px+27,py-24)
                                        //If we are, set the stage for slope launching; the player will release the slope once they
                                        //are no longer colliding with it
                                        if  floor(px)  &gt;= tile_get_x(tile_ramp_id)+orig_clip[tile_ramp_id_debug+scr_local_launch,0] -4
                                        and floor(px)  &lt;= tile_get_x(tile_ramp_id)+orig_clip[tile_ramp_id_debug+scr_local_launch,0] +4
                                        and !tile_exists(tile_check_ramp_middle_id)
                                        and !tile_exists(tile_check_ramp_left_id)
                                        and !tile_exists(tile_check_ramp_right_id)
                                        //Also check if we are going up the slope first
                                        and ((speed_length_x &gt; 0 and speed_length_y &lt; 0)
                                        or (speed_length_x &lt; 0 and speed_length_y &lt; 0))
                                            {
                                                gravity_launch = 1;
                                                if anim_current=anim_lilac_dragon_boost_2
                                                or anim_current=anim_lilac_dragon_boost_r
                                                    lilac_boost_launch = 1;
                                            }
                                        //Override launch conditions if we have lost too much speed before reaching the launcher point,
                                        //or running down the slope
                                        if abs(hsp) &lt; 3
                                        or (speed_length_x &gt; 0 and speed_length_y &gt; 0
                                        or  speed_length_x &lt; 0 and speed_length_y &gt; 0)
                                            gravity_launch = 0;
                                    }
                                if tile_exists(tile_check_wall_id_hold) gravity_launch = 0;
                                //Launch player from slope if they are "walking" beyond the intended range of the slope's length map
                                //if orig_clip[tile_ramp_id_debug+scr_local_height,tile_ramp_pos[1]] = -2 gravity_launch = 1;
                                //If we were running up a flat wall before connecting to the slope piece, iterate wall running state
                                //and clear its separate tile compass
                                if tile_check_slope_priority = 2
                                    {
                                        gravity_slope = 1;
                                        gravity_speed = 0;
                                        gravity_launch = 0;
                                        tile_check_slope_priority = 3
                                        tile_surface_wall_xcompass = 0
                                    }
                                //If the player has not been launched on a slope, clip to its surface
                                if gravity_ceiling &lt;= 2
                                //Check if the player was "walking" beyond the intended range of the slope's length map
                                and orig_clip[tile_ramp_id_debug+scr_local_height,tile_ramp_pos[1]] != -2
                                    {
                                        //Set X Position Of Player Along the Slope
                                        px = floor(tile_get_x(tile_ramp_id))+orig_clip[tile_ramp_id_debug+scr_local_height,tile_ramp_pos[1]]
                                        //Set Angle Position Along the Slope
                                        tile_angle = orig_clip[tile_ramp_id_debug+scr_local_angles,tile_ramp_pos[0]]
                                    }
                                if (orig_clip[tile_ramp_id_debug+scr_local_s_type,0]!=-1 and ground = 1)
                                    {
                                        var enable_security = 0;
                                        var bottom_right_inside_x = 104;
                                        var bottom_left_inside_x = 35;
                                        var bottom_left_outside_x = 12;
                                        var bottom_right_outside_x = 127;

                                        var top_right_inside_x = 104;
                                        var top_left_inside_x = 35;
                                        var top_left_outside_x = 12;
                                        var top_right_outside_x = 127;
                                        var boundary_top_x = 16;
                                        var boundary_bottom_x = 123;

                                        switch(tile_ramp_id_debug)
                                            {
                                                //Shang Mu Academy
                                                case mu_slope_2:  {enable_security = 1; break;}
                                                case mu_slope_3:  {enable_security = 1; break;}
                                                case mu_slope_4:  {enable_security = 1; break;}
                                                case mu_slope_5:  {enable_security = 1; break;}
                                                case mu_slope_6:  {enable_security = 1; break;}
                                                case mu_slope_7:  {enable_security = 1; break;}
                                                case mu_slope_8:  {enable_security = 1; break;}
                                                case mu_slope_9:  {enable_security = 1; break;}
                                                case mu_slope_10: {enable_security = 1; break;}
                                                case mu_slope_11: {enable_security = 1; break;}
                                                case mu_slope_12: {enable_security = 1; break;}
                                                case mu_slope_13: {enable_security = 1; break;}
                                                case mu_slope_14: {enable_security = 1; break;}
                                                case mu_slope_15: {enable_security = 1; break;}
                                                case mu_slope_16: {enable_security = 1; break;}
                                                case mu_slope_17: {enable_security = 1; break;}
                                                case mu_slope_20: {enable_security = 1; break;}
                                                case mu_slope_21: {enable_security = 1; break;}
                                                case mu_slope_22: {enable_security = 1; break;}
                                                case mu_slope_23: {enable_security = 1; break;}
                                                case mu_slope_24: {enable_security = 1; break;}
                                                case mu_slope_25: {enable_security = 1; break;}
                                                case mu_slope_26: {enable_security = 1; break;}
                                                case mu_slope_27: {enable_security = 1; break;}
                                                //West District
                                                case wd_slope_0:  {enable_security = 2; break;}
                                                case wd_slope_1:  {enable_security = 2; break;}
                                                case wd_slope_2:  {enable_security = 2; break;}
                                                case wd_slope_3:  {enable_security = 2; break;}
                                                case wd_slope_4:  {enable_security = 3; break;}
                                                case wd_slope_5:  {enable_security = 3; break;}
                                                case wd_slope_6:  {enable_security = 3; break;}
                                                case wd_slope_7:  {enable_security = 3; break;}
                                                case wd_slope_8:  {enable_security = 2; break;}
                                                case wd_slope_9:  {enable_security = 2; break;}
                                                case wd_slope_10: {enable_security = 2; break;}
                                                case wd_slope_11: {enable_security = 2; break;}
                                                case wd_slope_12: {enable_security = 3; break;}
                                                case wd_slope_13: {enable_security = 3; break;}
                                                case wd_slope_14: {enable_security = 3; break;}
                                                case wd_slope_15: {enable_security = 3; break;}
                                                case wd_slope_16: {enable_security = 4; break;}
                                                case wd_slope_17: {enable_security = 4; break;}
                                                case wd_slope_18: {enable_security = 4; break;}
                                                case wd_slope_19: {enable_security = 4; break;}
                                                case wd_slope_20: {enable_security = 4; break;}
                                                case wd_slope_21: {enable_security = 4; break;}
                                                case wd_slope_22: {enable_security = 4; break;}
                                                case wd_slope_23: {enable_security = 4; break;}
                                                case wd_slope_24: {enable_security = 2; break;}
                                                case wd_slope_25: {enable_security = 2; break;}
                                                case wd_slope_26: {enable_security = 2; break;}
                                                case wd_slope_27: {enable_security = 2; break;}
                                                //Mountain
                                                case mnt_slope_0: {enable_security = 1; break;}
                                                case mnt_slope_1: {enable_security = 1; break;}
                                                case mnt_slope_2: {enable_security = 1; break;}
                                                case mnt_slope_3: {enable_security = 1; break;}
                                                case mnt_slope_4: {enable_security = 1; break;}
                                                case mnt_slope_5: {enable_security = 1; break;}
                                                case mnt_slope_6: {enable_security = 1; break;}
                                                case mnt_slope_7: {enable_security = 1; break;}
                                                case mnt_slope_16: {enable_security = 1; break;}
                                                case mnt_slope_17: {enable_security = 1; break;}
                                                case mnt_slope_18: {enable_security = 1; break;}
                                                case mnt_slope_19: {enable_security = 1; break;}
                                                case mnt_slope_20: {enable_security = 1; break;}
                                                case mnt_slope_21: {enable_security = 1; break;}
                                                case mnt_slope_22: {enable_security = 1; break;}
                                                case mnt_slope_23: {enable_security = 1; break;}
                                                case mnt_slope_24: {enable_security = 1; break;}
                                                case mnt_slope_25: {enable_security = 1; break;}
                                                case mnt_slope_26: {enable_security = 1; break;}
                                                case mnt_slope_27: {enable_security = 1; break;}
                                                case mnt_slope_28: {enable_security = 1; break;}
                                                case mnt_slope_29: {enable_security = 1; break;}
                                                case mnt_slope_30: {enable_security = 1; break;}
                                                case mnt_slope_31: {enable_security = 1; break;}
                                                //Lagoon
                                                case ll_slope_16: {enable_security = 2; break;}
                                                case ll_slope_17: {enable_security = 2; break;}
                                                case ll_slope_18: {enable_security = 2; break;}
                                                case ll_slope_19: {enable_security = 2; break;}
                                                case ll_slope_20: {enable_security = 2; break;}
                                                case ll_slope_21: {enable_security = 2; break;}
                                                case ll_slope_22: {enable_security = 2; break;}
                                                case ll_slope_23: {enable_security = 2; break;}
                                                case ll_slope_4:  {enable_security = 4; break;}
                                                case ll_slope_5:  {enable_security = 4; break;}
                                                case ll_slope_6:  {enable_security = 4; break;}
                                                case ll_slope_7:  {enable_security = 4; break;}
                                                case ll_slope_10: {enable_security = 4; break;}
                                                case ll_slope_8:  {enable_security = 4; break;}
                                                case ll_slope_9:  {enable_security = 4; break;}
                                                case ll_slope_14: {enable_security = 4; break;}
                                                case ll_slope_15: {enable_security = 4; break;}
                                                case ll_slope_11: {enable_security = 4; break;}
                                                case ll_slope_12: {enable_security = 4; break;}
                                                case ll_slope_13: {enable_security = 4; break;}
                                            }
                                        switch(enable_security)
                                            {
                                                case 0: {break;}
                                                case 1: {break;}
                                                //Donut Loops
                                                case 2:
                                                    {
                                                        boundary_top_x = 4
                                                        boundary_bottom_x = 137
                                                        bottom_right_inside_x = 96;
                                                        bottom_left_inside_x = 55;
                                                        bottom_left_outside_x = 16;
                                                        bottom_right_outside_x = 135;
                
                                                        top_right_inside_x = 96;
                                                        top_left_inside_x = 55;
                                                        top_left_outside_x = 16;
                                                        top_right_outside_x = 135;
                                                        break;
                                                    }
                                                //Skinny Loops
                                                case 3:
                                                    {
                                                        boundary_top_x = 13
                                                        boundary_bottom_x = 115
                                                        bottom_right_inside_x = 48;
                                                        bottom_left_inside_x = 32;
                                                        bottom_left_outside_x = 16;
                                                        bottom_right_outside_x = 63;

                                                        top_right_inside_x = 48;
                                                        top_left_inside_x = 32;
                                                        top_left_outside_x = 16;
                                                        top_right_outside_x = 63;
                                                        break;
                                                    }
                                                //Road Loops
                                                case 4:
                                                    {
                                                        boundary_top_x = 6
                                                        boundary_bottom_x = 138
                                                        bottom_right_inside_x = 92;
                                                        bottom_left_inside_x = 59;
                                                        bottom_left_outside_x = 16;
                                                        bottom_right_outside_x = 135;

                                                        top_right_inside_x = 92;
                                                        top_left_inside_x = 59;
                                                        top_left_outside_x = 16;
                                                        top_right_outside_x = 135;
                                                        break;
                                                    }
                                            }
                                        if enable_security &gt; 0
                                            {
                                                if (floor(tile_ramp_pos[1]) &lt; boundary_top_x)
                                                    {
                                                        if orig_clip[tile_ramp_id_debug+scr_local_s_type,0]=scr_bottom_right_inside_loop
                                                        px = floor(tile_get_x(tile_ramp_id))+bottom_right_inside_x;
                                                        if orig_clip[tile_ramp_id_debug+scr_local_s_type,0]=scr_bottom_left_inside_loop
                                                        px = floor(tile_get_x(tile_ramp_id))+bottom_left_inside_x;
                                                        if orig_clip[tile_ramp_id_debug+scr_local_s_type,0]=scr_bottom_left_outside_loop
                                                        px = floor(tile_get_x(tile_ramp_id))+bottom_left_outside_x;
                                                        if orig_clip[tile_ramp_id_debug+scr_local_s_type,0]=scr_bottom_right_outside_loop
                                                        px = floor(tile_get_x(tile_ramp_id))+bottom_right_outside_x;
                                                    }
                                                if (floor(tile_ramp_pos[1]) &gt; boundary_bottom_x)
                                                    {
                                                        if orig_clip[tile_ramp_id_debug+scr_local_s_type,0]=scr_top_left_outside_loop
                                                        px = floor(tile_get_x(tile_ramp_id))+top_left_outside_x;
                                                        if orig_clip[tile_ramp_id_debug+scr_local_s_type,0]=scr_top_right_outside_loop
                                                        px = floor(tile_get_x(tile_ramp_id))+top_right_outside_x;
                                                        if orig_clip[tile_ramp_id_debug+scr_local_s_type,0]=scr_top_left_inside_loop
                                                        px = floor(tile_get_x(tile_ramp_id))+top_left_inside_x;
                                                        if orig_clip[tile_ramp_id_debug+scr_local_s_type,0]=scr_top_right_inside_loop
                                                        px = floor(tile_get_x(tile_ramp_id))+top_right_inside_x;
                                                    }
                                            }
                                    }
                            }
        
                        //========Ceiling Collisions========//
                        if (xcompass = 180 or gravity_ceiling = 2 or tile_surface_ceiling_override &gt; 0)
                            {
                                //Set Y Position Of Player Along the Slope
                                py = floor(tile_get_y(tile_ramp_id))+orig_clip[tile_ramp_id_debug,tile_ramp_pos[0]]
                                //Set Angle Position Along the Slope
                                tile_angle = orig_clip[tile_ramp_id_debug+scr_local_angles,tile_ramp_pos[0]]
        
                                //=========Flat Wall Collisions=========//
        
                                var tile_surface_wall_direction = -16
        
                                if hsp &lt; 0 tile_surface_wall_direction = 16;
        
                                //Check for Tiles on Layer 0. (Flat Surface Collisions)
                                tile_surface_wall_id = tile_layer_find(surface_flats,px+tile_surface_wall_direction,py-16)
        
                                //If We Are Touching a Flat Surface Tile, Interact With It As If It Were A Floor
                                if tile_exists(tile_surface_wall_id)
                                    {
                                        gravity_launch = 0
                                        //Reset Slope Clipping Priority
                                        tile_check_slope_priority = 0
                                        //Set Wall Running Compass
                                        tile_surface_wall_xcompass = 180
                                        //Set Speed
                                        tile_surface_hor_speed = abs(hsp)
                                        //Set Direction Of Running
                                        tile_surface_hor_direction = xdir
                                        //Set Disable Trigger To Clip The Player To The Ceiling After Declipping From This Slope
                                        tile_surface_ceiling_disable = -1
                                    }
                                //Bonk the player's head against flat surface ceilings
                                var tile_flat_wall_id = tile_layer_find(surface_flats,px+tile_surface_wall_direction,py+8);
                                if tile_flat_wall_id != -1
                                    {
                                        gravity_slope = 0                   //Override slope clipping for this one frame
                                        xcompass = 0                        //Override current tile compass direction
                                        tile_check_slope_priority = 0       //Slope Priority For Flat Surface Running
                                        tile_surface_wall_xcompass = 0      //Tile Compass For Flat Surface Running
                                        hsp = 0
                                    }
                            }
        
                        //        Tile Compass Directions        //
                        //---------------------------------------//
                        if (tile_angle &gt; 45  and tile_angle &lt;= 135) xcompass = 90;    //East  (Ceiling Mode)
                        if (tile_angle &gt; 135 and tile_angle &lt;= 225) xcompass = 180;   //North (Right Wall Mode)
                        if (tile_angle &gt; 225 and tile_angle &lt; 315)  xcompass = 270;   //West  (Left Wall Mode)
                        if (tile_angle &gt;= 315 or  tile_angle &lt;= 45) xcompass = 0;     //South (Floor Mode)
        
                        //Change Tile Compass Directions Sooner At Higher Speeds
                        if (hsp &gt;= 9.5 and tile_angle &gt; 305) or (hsp &lt;= -9.5 and tile_angle &lt;= 65) xcompass = 0;
                        if (hsp &gt;= 9.5 and tile_angle &gt; 125 and xcompass = 90)
                        or (hsp &lt;= -9.5 and tile_angle &lt;= 235 and xcompass = 270) xcompass = 180;
        
                        //Change Tile Compass Directions Sooner On Smaller Loop Pieces
                        if tile_ramp_id_debug = mu_ramp_0
                        or tile_ramp_id_debug = mu_ramp_1
                        or tile_ramp_id_debug = mu_ramp_2
                        or tile_ramp_id_debug = mu_ramp_3
                            {
                                //Set our tile compass direction to ceiling mode, effectively disabling length maps,
                                //if we are moving so fast on such a small tile
                                //When moving so fast on such small tiles, the player is zooming right past the parts of the tile
                                //where the length maps were relevant anyway
                                if (hsp &lt;= -9.5 and tile_angle &lt;= 270 and xcompass = 270
                                and orig_clip[tile_ramp_id_debug+scr_local_s_type,0]=scr_top_left_inside_loop)
                                or (hsp &gt;= 9.5  and tile_angle &gt;= 90  and xcompass = 90
                                and orig_clip[tile_ramp_id_debug+scr_local_s_type,0]=scr_top_right_inside_loop)
                                    xcompass = 180;
                            }
                        //Override Tile Compass Direction For Slope Ceiling Surface Types
                        if orig_clip[tile_ramp_id_debug+scr_local_s_type,0]=scr_slope_ceiling and gravity_slope = 1 and gravity_speed = 0
                        and (xcompass = 90 or xcompass = 270)
                            xcompass = 180;
                    }
            }
        else
            {
                if !audio_is_playing(character_parry)
                    scr_set_message("Warning: This tile lacks a collision mask!");
            }
    }

//Clean slope tile variables when collisions are done
if !tile_exists(tile_ramp_id)
    {
        //Fling the player off of a slope, if the slope piece was not connected to anything
        switch(xcompass)
            {
                case   0: {break;}
                case  90:
                    {
                        if hsp &gt; 0 {fling_vsp = -hsp;}
                        if hsp &lt; 0 {fling_vsp = abs(hsp);}
                        if anim_current=anim_lilac_dragon_boost_2
                            {
                                lilac_boost_fling_dir = lilac_dragon_boost_angle;
                                if hsp &lt; 0 lilac_boost_fling_dir = 270;
                                lilac_boost_fling_timer = 4
                            }
                        gravity_speed=fling_vsp;
                        fling_ver_timer=4;
                        break;
                    }
                case 270:
                    {
                        if hsp &gt; 0 {fling_vsp = abs(hsp);}
                        if hsp &lt; 0 {fling_vsp = hsp;}
                        if anim_current=anim_lilac_dragon_boost_2
                            {
                                lilac_boost_fling_dir = lilac_dragon_boost_angle;
                                lilac_boost_fling_timer = 4
                            }
                        gravity_speed=fling_vsp;
                        fling_ver_timer=4;
                        break;}
                case 180:
                    {
                        if anim_current=anim_lilac_dragon_boost_2
                            {
                                lilac_boost_fling_dir = lilac_dragon_boost_angle;
                                if xdir = -1 and tile_surface_wall_xcompass != 180
                                    {
                                        lilac_boost_fling_dir = 0.000000000001;
                                        xdir = 1
                                    }
                                lilac_boost_fling_timer = 4
                                fling_hsp = 0;
                                fling_timer = 0;
                            }
                        else
                            {
                                fling_hsp = abs(hsp)*-xdir;
                                hsp=fling_hsp;
                                fling_timer=4;
                            }
                        break;
                    }
                default:  {break;}
            }
        //Clip onto the wall if we detected a flat surface while on a slope piece
        if tile_exists(tile_check_wall_id_hold) and xcompass!=0
            {
                gravity_launch = 0
                tile_surface_wall_xcompass = xcompass
                //Clear the timer for checking for ceiling surfaces, if it was not cleared previously
                tile_surface_ceiling_timer = 0
                tile_surface_ceiling_disable = 0
                //Clip onto the wall based on direction
                if tile_check_wall_id_dir &gt; 0 px = tile_get_x(tile_check_wall_id_hold);
                if tile_check_wall_id_dir &lt; 0 px = tile_get_x(tile_check_wall_id_hold)+tile_get_width(tile_check_wall_id_hold);
                //Clear clip hold ID
                tile_check_wall_id_hold = -1
                lilac_boost_fling_timer = 0
            }

        //Clip the player's feet to the ground, after unclipping from a slope tile
        if gravity_slope = 1 and xcompass = 0
            {
                //Search for any flat tiles to clip to
                var tile_surface_floor = tile_layer_find(surface_flats,px,py+2)

                //If we have found a flat surface tile, clip to it
                if tile_exists(tile_surface_floor)
                    {
                        ground = 1
                        gravity_speed = 0
                        py = tile_get_y(tile_surface_floor)
                    }
            }

        //Clean slope tile variables
        tile_ramp_pos[0]    = 0
        tile_ramp_pos[1]    = 0
        gravity_slope       = 0
        tile_angle          = 0
        xcompass            = 0
        gravity_fof_validation = 0
        //gravity_rail_check = 0
        //gravity_rail_timer = 0
        tile_ramp_id = -1
        //Clear slope tile priority for flat wall running, if it wasn't already reset
        if tile_check_slope_priority  &gt;= 2 tile_check_slope_priority  = 0;
        //If the player was set to launch off of a slope,
        //convert the launch force to their horizontal speed, then reset their speed
        if gravity_launch = 1
            {
                launch_force = abs(hsp)*0.975
                hsp = 1.25 * xdir
                gravity_launch = 2
            }
        //Clip onto the ceiling if we detected a flat surface while on a slope piece
        if tile_surface_ceiling_disable = -1 and tile_exists(tile_surface_wall_id)
            {
                py=floor(tile_get_y(tile_surface_wall_id)+tile_get_height(tile_surface_wall_id))
                tile_surface_ceiling_disable = 0
            }
    }

//If the player is trying to jump off a slope, and they're stuck to it, let them jump
if (gravity_slope=1 and gravity_speed&lt;0) or (gravity_slope = 1 and anim_current=anim_jump)
    gravity_slope=0;

//===========Ground, Wall, and Ceiling Checks===========//

//Check for collisions with walls of all surface types

//Wall Collisions (Left)
if (tile_exists(tile_surface_id[3]) or tile_wall_left_trig  = 1) wall_collision_left = 1; else wall_collision_left = 0;

//Wall Collisions (Right)
if (tile_exists(tile_surface_id[4]) or tile_wall_right_trig = 1) wall_collision_right = 1; else wall_collision_right = 0;

//Ceiling Collisions
if (xcompass = 0) and (tile_exists(tile_surface_id[1]) or tile_collision_ceiling_trigger = 1)
    {
        tile_collision_ceiling = 1
        fof_disable = 16
    }
else
    tile_collision_ceiling = 0;

//Stop Players From Entering Shallower Corners or Angled Tunnels
if tile_collision_ceiling_trigger = 1 and ground = 1
    {
        fling_hsp = abs(2)*-xdir;
        hsp=fling_hsp;
        fling_timer=4
    }

//Warn Players If They Are Entering Implausibly Tight Spaces
if wall_collision_left = 1 and wall_collision_right = 1 and room = rm_editor
    {
        if !audio_is_playing(character_parry) scr_set_message("Cannot Resolve Spaces Smaller than 32 pixels!");
    }

//================Slope Ceiling Clipping================//

//Enforce slope ceiling clipping
if gravity_ceiling = 2
    {
        wall_collision_left = 0
        wall_collision_right = 0
        angle_a = tile_angle
        tile_collision_ceiling = 0
        ground = 1
        gravity_slope = 1
        spring_timer=-1
        hsp = tile_wall_speed_copy
        spring_frames=0
        spring_tile_frames=0
        jump_sound=0
        if anim_current != anim_running
            anim_current = anim_running;
        //Modify direction of movement based on angle
        switch(xcompass)
            {
                case 0:   {px+=hsp; break;} //Default: "Ground"; Forward Horizontal Speed
                case 90:  {py-=hsp; break;} //Default: "Right"; Upward Gravity Speed
                case 180: {px-=hsp; break;} //Default: "Ceiling"; Backward Horizontal Speed
                case 270: {py+=hsp; break;} //Default: "Left"; Downward Y Speed
            }
        gravity_ceiling = 0
    }

//====================Stagger Factor====================//

//Stagger the player backwards, if no input is provided on a slope piece
if  (gravity_slope=1 and joy_input[0,0] = 0 and joy_input[0,2] = 0)
and (anim_current!=anim_carol_rolling)
    {
        var stagger_rate = stagger_speed;
        if (use_weather_conditions &gt; 0 and (py &lt; water_height and !instance_exists(water_ID)))
            stagger_rate = 0.60;
        switch(xcompass)
            {
                case   0: {stagger_backwards = 0;                    break;}
                case  90: {hsp-=stagger_rate; stagger_backwards = 1; break;}
                case 180: {stagger_backwards = 0;                    break;}
                case 270: {hsp+=stagger_rate; stagger_backwards = 1; break;}
            }
    }
else stagger_backwards = 0;

//=====================Fling Factor=====================//

//Fling the player off of a slope, if the slope piece was not connected to anything
if fling_timer &gt; 0
    {
        fling_timer-=1
        hsp=fling_hsp
    }
if fling_ver_timer &gt; 0
    {
        fling_ver_timer-=1
        gravity_speed=fling_vsp
        if ground = 0
            scr_set_rail_grinding_stop();
    }

//=====================Slope Factor=====================//

//Apply slope factor if we are running
if (tile_angle &gt;= 35 and tile_angle &lt;= 325)
or (anim_current=anim_carol_rolling)
    {
        //Determine the direction of the player's movement based on their speed and angle
        var speed_length_x = lengthdir_x(hsp,tile_angle)
        var speed_length_y = lengthdir_y(hsp,tile_angle)
        var speed_rate = 0;
        var speed_multiplier = 0;

        //Determine the direction the player is pushed forward or pulled backwards
        if speed_length_x &gt; 0 and speed_length_y &lt; 0 //Running Up Slope   (Right)
        or speed_length_x &lt; 0 and speed_length_y &gt; 0 //Running Down Slope (Left)
            slope_direction = -1;
        if speed_length_x &gt; 0 and speed_length_y &gt; 0 //Running Down Slope (Right)
        or speed_length_x &lt; 0 and speed_length_y &lt; 0 //Running Up Slope   (Left)
            slope_direction = 1;

        //Determine slope factor value based on speed and direction
        if anim_current!=anim_carol_rolling
            {
                if abs(hsp) &lt;= 5
                    {
                        if (speed_length_x &gt; 0 and speed_length_y &lt; 0) speed_rate = slope_factor_walking_uphill;    //Walking Up Slope   (Right)
                        if (speed_length_x &gt; 0 and speed_length_y &gt; 0) speed_rate = slope_factor_walking_downhill;  //Walking Down Slope (Right)
                        if (speed_length_x &lt; 0 and speed_length_y &lt; 0) speed_rate = slope_factor_walking_uphill;    //Walking Up Slope   (Left)
                        if (speed_length_x &lt; 0 and speed_length_y &gt; 0) speed_rate = slope_factor_walking_downhill;  //Walking Down Slope (Left)
                    }
                if abs(hsp) &gt; 5 speed_rate = slope_factor_running;

                //Apply slope factor
                hsp+=(lengthdir_x(slope_direction,tile_angle)*speed_rate)
            }
        //If we are rolling as Carol, introduce slower acceleration speeds uphill *and* downhill
        else
            {
                if (speed_length_x &gt; 0 and speed_length_y &lt; 0) speed_rate = 0.0333; //Walking Up Slope   (Right)
                if (speed_length_x &gt; 0 and speed_length_y &gt; 0) speed_rate = 0.2166; //Walking Down Slope (Right)
                if (speed_length_x &lt; 0 and speed_length_y &lt; 0) speed_rate = 0.0333; //Walking Up Slope   (Left)
                if (speed_length_x &lt; 0 and speed_length_y &gt; 0) speed_rate = 0.2166; //Walking Down Slope (Left)

                //Apply slope factor
                hsp+=lengthdir_x(slope_direction,tile_angle)*speed_rate*0.80
            }
    }

//==============Landing Factor Conversions==============//

//Directly convert our previous vertical speed to our horizontal speed, with some tradeoff
if (ground = 1) and (tile_angle &gt;= 12 and tile_angle &lt;= 56 or tile_angle &gt;= 300 and tile_angle &lt;= 348)
and gravity_factor != 0
    {
        //Determine the direction of the player's movement based on their speed and angle
        var convert_length_x = lengthdir_x(hsp,tile_angle)
        var convert_length_y = lengthdir_y(hsp,tile_angle)

        if   gravity_factor != 0
        and (convert_length_x &gt; 0 and convert_length_y &gt; 0  //Walking Down Slope (Right)
        or   convert_length_x &lt; 0 and convert_length_y &gt; 0) //Walking Down Slope (Left)
            {
                var rfactor = lfactor;
                if use_weather_conditions &gt; 0 and py &lt;= water_height and !instance_exists(water_ID)
                    {
                        rfactor = 1.1;
                        audio_play_sound(character_water_foot_step,50,false);
                    }
                if hsp &lt; 0 hsp = -gravity_factor * rfactor    //Left
                if hsp &gt; 0 hsp =  gravity_factor * rfactor    //Right
                gravity_factor = 0
            }
    }

//===================Slope Launching===================//

//Launch the player into the air
if gravity_launch = 2
    {
        //Only set the player's animation to the falling animation if no attacks or special attacks are active
        if Animations_Override = 0 and active_attack = 0 and attack[0] = 0 anim_current=anim_falling;
        //Apply gravity speed to player
        gravity_speed = -abs(launch_force)
        //Decrease speed until it is no longer sending the player upward
        launch_force -= gravity_accel
        //Disable gravity launch once the player is falling
        if launch_force &lt;= 0 or tile_collision_ceiling = 1
            {
                gravity_launch = 0
                launch_force = 0
            }
    }

//If we have collided with a ceiling, while standing on a floating platform,
//temporarily disable collisions with floating platforms
if fof_disable &gt; 0
    {
        fof_disable -= 1
        relative_x = -1
    }

//============================================================================//
//                     Tile-Based Flat Surface Collisions                     //
//============================================================================//

//==================Flat Wall Running==================//

//This code block allows the player to seamlessly run from loop pieces to flat wall surfaces,
//and visa versa. It looks a little backwards and unintuitive, I know :^P

//Interact with Flat Walls As Floors While Running Along Their Surfaces
switch(tile_surface_wall_xcompass)
    {
        //Floor Mode
        case 0:
            {
                //Reset Wall Runnings Sensors At This Tile Compass Direction
                tile_surface_wall_id=-1;
                tile_check_wall_id=-1;

                //Wall Sensors
                tile_check_wall_id_forward = tile_layer_find(surface_flats,px+15,py-32)
                var tile_check_wall_id_backward = tile_layer_find(surface_flats,px-15,py-32);

                //If We Are At An Angle In Floor Mode, Scan For Walls To Collide With
                if tile_angle!=0 and (tile_angle &lt;= 45 or tile_angle &gt;= 315)
                    {
                        if tile_exists(tile_check_wall_id_forward)
                            {
                                if px &gt;= tile_get_x(tile_check_wall_id_forward)-15 and hsp &gt; 0
                                    {
                                        px=floor(tile_get_x(tile_check_wall_id_forward)-15)
                                        hsp = 0
                                    }
                            }
                        if tile_exists(tile_check_wall_id_backward)
                            {
                                if px &lt;= tile_get_x(tile_check_wall_id_backward)+tile_get_width(tile_check_wall_id_backward)+14 and hsp &lt; 0
                                    {
                                        px=floor(tile_get_x(tile_check_wall_id_backward)+tile_get_width(tile_check_wall_id_backward))+14
                                        hsp = 0
                                    }
                            }
                    }
                break;
            }
        //Wall Mode (Right)
        case 90:
            {
                //Floor Sensors
                tile_check_wall_id   = tile_layer_find(surface_slopes,px,py)    //Bottom Collision Sensor
                tile_surface_wall_id = tile_layer_find(surface_flats,px+4,py-8) //Top Collision Sensor

                //Increment our wall running state if we are now running on a flat surface
                if tile_check_slope_priority = 0 and gravity_slope = 0 tile_check_slope_priority = 1;

                //Clear surface wall sensors if we are currently on a slope piece
                if tile_check_slope_priority = 1
                    tile_surface_wall_id = tile_layer_find(surface_flats,px+4,py);

                //Clear surface wall sensors if we are currently on a slope piece
                if tile_check_slope_priority = 3 {tile_surface_wall_id=-1; tile_check_wall_id=-1;}

                //Run along the wall
                if tile_exists(tile_surface_wall_id)
                    {
                        //Set Angle
                        tile_angle=90
                        xcompass=90
                        gravity_speed=0
                        //Slope Factor
                        if anim_current = anim_lilac_dragon_boost_2
                            hsp = 12*xdir;
                        else
                            {
                                if (abs(hsp) &gt; 5)          hsp-=slope_factor_running;
                                if (hsp &gt; 0 and hsp &lt;= 5)  hsp-=slope_factor_walking_uphill;
                                if (hsp &lt; 0 and hsp &gt;= -5) hsp-=slope_factor_walking_downhill;
                            }
                        //Clip To The Wall
                        if px &gt;= tile_get_x(tile_surface_wall_id) px=floor(tile_get_x(tile_surface_wall_id))
                    }

                //Clip To Downwards Slopes
                tile_wall_slope_id = tile_layer_find(surface_slopes,px+8,py+16)

                var declip_yes = 0;
                var declip_id = tile_layer_find(surface_slopes,px-8,py-16);
                if tile_exists(declip_id)
                    {
                        var declip_bg = tile_get_background(declip_id);
                        if orig_clip[declip_bg+scr_local_s_type,0] = scr_slope_ceiling
                        and hsp &gt; 0
                            declip_yes = 1;
                        else
                            declip_yes = 0;
                    }

                if (tile_exists(tile_wall_slope_id) and hsp &lt; 0) tile_surface_ceiling_override = 1;

                //Wall Sensors
                tile_check_wall_id_forward = tile_layer_find(surface_flats,px-15,py-15)
                var tile_check_wall_id_backward = tile_layer_find(surface_flats,px-15,py+15)

                //Declip From The Wall
                if (tile_exists(tile_check_wall_id_forward) or declip_yes = 1)
                    {
                        px-=15
                        if declip_yes = 0 py=floor(tile_get_y(tile_check_wall_id_forward)+tile_get_height(tile_check_wall_id_forward)+29);
                        tile_check_slope_priority = 0
                        tile_surface_wall_xcompass = 0
                        tile_surface_wall_id = -1
                        tile_check_wall_id = -1
                        gravity_launch = 4
                        gravity_speed = 0
                        launch_force = 0
                        xcompass = 0
                        hsp = 0
                        scr_set_lilac_clear_dragon_boost()
                    }
                //Land On The Floor
                if (tile_exists(tile_check_wall_id_backward) and !tile_exists(tile_check_wall_id))
                    {
                        px-=15
                        gravity_launch = 3
                        py=floor(tile_get_y(tile_check_wall_id_backward))
                        scr_set_lilac_clear_dragon_boost()
                    }
                break;
            }
        //Ceiling Mode
        case 180:
            {
                var tile_ceiling_slope_id = tile_layer_find(surface_slopes,px,py-8);  //Bottom Collision Sensor
                var tile_ceiling_flat_id  = tile_layer_find(surface_flats,px,py-8);   //Top Collision Sensor

                tile_surface_ceiling_timer += 1

                //Set Angle
                tile_angle=180
                //Wait Until We Are No Longer On the Slope To Set The Direction Of Movement
                if tile_surface_ceiling_disable = 0 xcompass=360;
                if tile_surface_ceiling_timer &lt;= 4
                    {
                        if tile_surface_hor_speed &lt;= dec
                            {
                                py+=15;
                                tile_check_slope_priority = 0
                                tile_surface_wall_compass = 0
                                xcompass = 0
                                tile_angle = 0
                                tile_surface_hor_speed = 0
                                tile_surface_ceiling_timer = 0
                                tile_surface_ceiling_disable = 16
                            }
                    }
                gravity_speed=0
                //Set Acceleration
                if tile_surface_hor_speed &lt; hcap tile_surface_hor_speed += acc;
                //Set Deceleration
                if joy_input[0,0] = 0 and joy_input[0,2] = 0 tile_surface_hor_speed -= dec;
                //Set Speed
                if anim_current=anim_lilac_dragon_boost_2
                    tile_surface_hor_speed = 12;
                if xdir = 1  hsp = tile_surface_hor_speed;
                if xdir = -1 hsp = -tile_surface_hor_speed;

                //Release The Player From The Ceiling
                if (!tile_exists(tile_ceiling_slope_id) and tile_surface_ceiling_timer &gt; 4)
                and (
                           (tile_surface_hor_speed &lt;= dec)
                        or (gravity_speed != 0)
                        or (joy_input[0,0] = 1 and tile_surface_hor_direction = -1)
                        or (joy_input[0,2] = 1 and tile_surface_hor_direction = 1)
                    )
                    {
                        tile_surface_wall_compass = 0
                        xcompass = 0
                        tile_angle = 0
                        tile_surface_hor_speed = 0
                        tile_surface_ceiling_timer = 0
                        tile_surface_ceiling_disable = 16
                    }
                //Fling The Player From The Ceiling If We Are No Longer Standing On The Ceiling
                if (!tile_exists(tile_ceiling_slope_id)  and !tile_exists(tile_ceiling_flat_id) and tile_surface_ceiling_timer &gt; 4)
                    {
                        tile_surface_wall_compass = 0
                        xcompass = 0
                        tile_angle = 0
                        fling_hsp = abs(tile_surface_hor_speed)*-xdir
                        hsp=fling_hsp
                        fling_timer=4
                        tile_surface_ceiling_timer = 0
                        tile_surface_ceiling_disable = 16
                    }

                //Wall Sensors
                tile_check_wall_id_forward = tile_layer_find(surface_flats,px-15,py+8)
                var tile_check_wall_id_backward = tile_layer_find(surface_flats,px+15,py+8)

                //Declip From The Wall
                if (tile_exists(tile_check_wall_id_forward) and hsp &gt; 0 and tile_surface_ceiling_timer &gt; 4)
                    {
                        px+=15
                        tile_check_slope_priority = 0
                        tile_surface_wall_xcompass = 0
                        tile_surface_wall_id = -1
                        tile_check_wall_id = -1
                        xcompass = 0
                        hsp = 0
                        tile_angle = 0
                        tile_surface_hor_speed = 0
                        tile_surface_ceiling_timer = 0
                        tile_surface_ceiling_disable = 16
                        scr_set_lilac_clear_dragon_boost()
                    }
                if (tile_exists(tile_check_wall_id_backward) and hsp &lt; 0 and tile_surface_ceiling_timer &gt; 4)
                    {
                        px-=15
                        tile_check_slope_priority = 0
                        tile_surface_wall_xcompass = 0
                        tile_surface_wall_id = -1
                        tile_check_wall_id = -1
                        xcompass = 0
                        hsp = 0
                        tile_angle = 0
                        tile_surface_hor_speed = 0
                        tile_surface_ceiling_timer = 0
                        tile_surface_ceiling_disable = 16
                        scr_set_lilac_clear_dragon_boost()
                    }

                //Clip To Slopes
                if tile_exists(tile_ceiling_slope_id) and tile_surface_ceiling_timer &gt; 8
                    {
                        //Collect Background ID of the Tile
                        var tile_check_wall_bg=tile_get_background(tile_ceiling_slope_id)
        
                        //Get Player Coordinates Relative to the Tile's Origins
                        var tile_check_pos_x=abs(tile_get_x(tile_ceiling_slope_id)-px)   //Get X
        
                        //Safety check! Be sure our tile has length map data before attempting to read its surface type
                        if orig_clip[tile_check_wall_bg+scr_local_height,0]!=-1
                            {
                                if orig_clip[tile_check_wall_bg+scr_local_s_type,0] = scr_bottom_left_outside_loop
                                or orig_clip[tile_check_wall_bg+scr_local_s_type,0] = scr_bottom_right_outside_loop
                                or orig_clip[tile_check_wall_bg+scr_local_s_type,0] = scr_top_left_inside_loop
                                or orig_clip[tile_check_wall_bg+scr_local_s_type,0] = scr_top_right_inside_loop
                                or orig_clip[tile_check_wall_bg+scr_local_s_type,0] = scr_slope_ceiling
                                    {
                                        //Set Y Position Of Player Along the Slope
                                        py = floor(tile_get_y(tile_ceiling_slope_id))+orig_clip[tile_check_wall_bg,tile_check_pos_x]
                                        tile_angle = orig_clip[tile_check_wall_bg+scr_local_angles,tile_check_pos_x]
                                        gravity_slope = 1
                                        xcompass = 180
                                        tile_check_wall_trigger = 0
                                        tile_check_slope_priority = 0
                                        tile_surface_wall_xcompass = 0
                                        tile_surface_ceiling_timer = 0
                                        tile_surface_ceiling_disable = 0
                                    }
                                else
                                    {
                                        tile_surface_wall_xcompass = 0
                                        xcompass = 0
                                        tile_angle = 0
                                        tile_surface_hor_speed = 0
                                        tile_surface_ceiling_timer = 0
                                        tile_surface_ceiling_disable = 16
                                    }
                            }
                    }
                break;
            }
        //Wall Mode (Left)
        case 270:
            {

                tile_check_wall_id   = tile_layer_find(surface_slopes,px,py)    //Bottom Collision Sensor
                tile_surface_wall_id = tile_layer_find(surface_flats,px-4,py-8) //Top Collision Sensor

                //Increment our wall running state if we are now running on a flat surface
                if tile_check_slope_priority = 0 and gravity_slope = 0 tile_check_slope_priority = 1;

                //Clear surface wall sensors if we are currently on a slope piece
                if tile_check_slope_priority = 1 tile_surface_wall_id = tile_layer_find(surface_flats,px-4,py);

                //Clear surface wall sensors if we are currently on a slope piece
                if tile_check_slope_priority = 3 {tile_surface_wall_id=-1; tile_check_wall_id=-1;}

                //Run along the wall
                if tile_exists(tile_surface_wall_id)
                    {
                        //Set Angle
                        tile_angle=270
                        xcompass=270
                        gravity_speed=0
                        //Slope Factor
                        if anim_current = anim_lilac_dragon_boost_2
                            hsp = 12*xdir;
                        else
                            {
                                if (abs(hsp) &gt; 5)          hsp+=slope_factor_running;
                                if (hsp &gt; 0 and hsp &lt;= 5)  hsp+=slope_factor_walking_downhill;
                                if (hsp &lt; 0 and hsp &gt;= -5) hsp+=slope_factor_walking_uphill;
                            }
                        //Clip To The Wall
                        if px &lt;= tile_get_x(tile_surface_wall_id)+tile_get_width(tile_surface_wall_id)
                        px=floor(tile_get_x(tile_surface_wall_id)+tile_get_width(tile_surface_wall_id))
                    }

                //Clip To Downwards Slopes
                tile_wall_slope_id = tile_layer_find(surface_slopes,px-15,py+16)

                if (tile_exists(tile_wall_slope_id) and hsp &gt; 0) tile_surface_ceiling_override = 1;

                //Wall Sensors
                tile_check_wall_id_forward = tile_layer_find(surface_flats,px+15,py-15)
                var tile_check_wall_id_backward = tile_layer_find(surface_flats,px+15,py+15)

                var declip_yes = 0;
                var declip_id = tile_layer_find(surface_slopes,px+8,py-16);
                if tile_exists(declip_id)
                    {
                        var declip_bg = tile_get_background(declip_id);
                        if orig_clip[declip_bg+scr_local_s_type,0] = scr_slope_ceiling
                        and hsp &lt; 0
                            declip_yes = 1;
                        else
                            declip_yes = 0;
                    }

                //Declip From The Wall
                if (tile_exists(tile_check_wall_id_forward) or declip_yes = 1)
                    {
                        px+=15
                        if declip_yes = 0 py=floor(tile_get_y(tile_check_wall_id_forward)+tile_get_height(tile_check_wall_id_forward)+29);
                        tile_check_slope_priority = 0
                        tile_surface_wall_xcompass = 0
                        tile_surface_wall_id = -1
                        tile_check_wall_id = -1
                        tile_check_wall_id_forward = -1
                        tile_check_wall_id_backward = -1
                        gravity_launch = 4
                        launch_force = 0
                        xcompass = 0
                        hsp = 0
                        scr_set_lilac_clear_dragon_boost()
                    }
                //Land On The Floor
                if (tile_exists(tile_check_wall_id_backward) and !tile_exists(tile_check_wall_id))
                    {
                        px+=15
                        gravity_launch = 3
                        py=floor(tile_get_y(tile_check_wall_id_backward))
                        scr_set_lilac_clear_dragon_boost()
                    }
                break;
            }
    }
//Fall off of the wall if we have lost too much speed, or jumped off of the wall
if (abs(hsp) &lt; 0.40) or (tile_check_slope_priority &gt;= 1 and ground=0)
    {
        tile_check_slope_priority = 0
        tile_surface_wall_xcompass = 0
    }
//Launch off of the wall if we are above it
if !tile_exists(tile_surface_wall_id) and !tile_exists(tile_check_wall_id) and (tile_check_slope_priority = 1 or tile_surface_ceiling_override = 1)
    {
        //Check for outside loop pieces before launching, because those loop pieces don't have any padding in their
        //collision masks that the default slope sensor can read :^P
        tile_check_wall_id = tile_layer_find(surface_slopes,px+4*xdir,py-2)
        tile_surface_wall_id = tile_layer_find(surface_flats,px+4*xdir,py-8)

        //Scan below our feet if we detected a loop piece underneath us
        if tile_surface_ceiling_override = 1
            {
                tile_check_wall_id = tile_layer_find(surface_slopes,px+16*-xdir,py+16)
                tile_surface_wall_id = tile_layer_find(surface_flats,px+16*-xdir,py+16)
                tile_surface_ceiling_override = 0
            }

        //If we found a slope tile, check and see if it's an outside loop piece first
        if tile_exists(tile_check_wall_id)
            {
                //Collect Background ID of the Tile
                var tile_check_wall_bg=tile_get_background(tile_check_wall_id)

                //Get Player Coordinates Relative to the Tile's Origins
                var tile_check_pos_y=abs(tile_get_y(tile_check_wall_id)-py)   //Get Y

                //Safety check! Be sure our tile has length map data before attempting to read its surface type
                if orig_clip[tile_check_wall_bg+scr_local_height,0]!=-1
                    {
                        //Check the slope tile's surface type
                        switch(orig_clip[tile_check_wall_bg+scr_local_s_type,0])
                            {
                                //Outside Loops
                                case scr_top_left_outside_loop:
                                    {
                                        //Set X Position Of Player Along the Slope
                                        px = floor(tile_get_x(tile_check_wall_id))+orig_clip[tile_check_wall_bg+scr_local_height,tile_check_pos_y]
                                        gravity_slope = 1
                                        xcompass = 90
                                        tile_angle = 90
                                        tile_check_wall_trigger = 0
                                        tile_check_slope_priority = 2
                                        tile_surface_wall_xcompass = 0
                                        gravity_launch = 4
                                        if anim_current=anim_lilac_dragon_boost_2
                                            px = floor(tile_get_x(tile_check_wall_id))+orig_clip[tile_check_wall_bg+scr_local_height,tile_check_pos_y];
                                        break;
                                    }
                                case scr_top_right_outside_loop:
                                    {
                                        //Set X Position Of Player Along the Slope
                                        px = floor(tile_get_x(tile_check_wall_id))+orig_clip[tile_check_wall_bg+scr_local_height,tile_check_pos_y]
                                        gravity_slope = 1
                                        gravity_speed = 0
                                        xcompass = 270
                                        tile_angle = 270
                                        tile_check_wall_trigger = 0
                                        tile_check_slope_priority = 2
                                        tile_surface_wall_xcompass = 0
                                        gravity_launch = 4
                                        break;
                                    }
                                case scr_bottom_right_outside_loop:
                                    {
                                        //Set Y Position Of Player Along the Slope
                                        px = floor(tile_get_x(tile_check_wall_id))+orig_clip[tile_check_wall_bg+scr_local_height,tile_check_pos_y]
                                        tile_angle = 270
                                        gravity_slope = 1
                                        gravity_speed = 0
                                        xcompass = 270
                                        tile_check_wall_trigger = 0
                                        tile_check_slope_priority = 2
                                        tile_surface_wall_xcompass = 0
                                        gravity_launch = 4
                                        break;
                                    }
                                case scr_bottom_left_outside_loop:
                                    {
                                        //Set Y Position Of Player Along the Slope
                                        px = floor(tile_get_x(tile_check_wall_id))+orig_clip[tile_check_wall_bg+scr_local_height,tile_check_pos_y]
                                        tile_angle = 90
                                        gravity_slope = 1
                                        gravity_speed = 0
                                        xcompass = 90
                                        tile_check_wall_trigger = 0
                                        tile_check_slope_priority = 2
                                        tile_surface_wall_xcompass = 0
                                        gravity_launch = 4
                                        break;
                                    }
                                case scr_slope_ceiling:
                                    {
                                        //Set X Position Of Player Along the Slope
                                        px = floor(tile_get_x(tile_check_wall_id))+orig_clip[tile_check_wall_bg+scr_local_height,tile_check_pos_y]
                                        gravity_slope = 1
                                        xcompass = 180
                                        tile_angle = 180
                                        tile_check_wall_trigger = 0
                                        tile_check_slope_priority = 2
                                        tile_surface_wall_xcompass = 0
                                        gravity_launch = 4
                                        break;
                                    }
                            }
                    }
            }

        //Disable gravity launching if we have touched a ceiling while running up a flat surface wall
        if gravity_launch = 4 gravity_launch = 0;

        //Otherwise, launch off of the wall
        if tile_check_wall_id = -1 and tile_surface_wall_id = -1 and gravity_launch != 4
        and (hsp &gt; 0 and tile_surface_wall_xcompass = 90 or hsp &lt; 0 and tile_surface_wall_xcompass = 270)
            {
                launch_force = abs(hsp)*0.975
                hsp = 1.25 * xdir
                gravity_launch = 2
                tile_check_slope_priority = 0
                tile_surface_wall_xcompass = 0
            }
        if tile_check_wall_id = -1 and tile_surface_wall_id = -1 and gravity_launch != 4
        and (hsp &lt; 0 and tile_surface_wall_xcompass = 90 or hsp &gt; 0 and tile_surface_wall_xcompass = 270)
            {
                tile_check_slope_priority = 0
                tile_surface_wall_xcompass = 0
                //Only set the player's animation to the falling animation if no attacks or special attacks are active
                if Animations_Override = 0 and active_attack = 0 and attack[0] = 0 anim_current=anim_falling;
                //Apply gravity speed to player
                gravity_speed = 0
                gravity_launch = 0
                launch_force = 0
                fling_hsp = 0
                fling_vsp = abs(hsp)*0.975
                fling_timer = 4
                fling_ver_timer = 4
                hsp = 0
            }
    }
//Reset tile compass for flat wall running
if tile_surface_wall_id = -1 and tile_surface_wall_xcompass = 180
    {
        tile_surface_ceiling_disable = 0
        tile_surface_wall_xcompass = 0
    }
//Override launch force if we are on a loop piece
if tile_check_slope_priority &gt;= 2
    {
        gravity_speed=0
        launch_force=0
    }
//Set the player down on the ground, if they were running down
//a wall that touches the ground
if gravity_launch &gt;= 3
    {
        hsp = 0
        gravity_speed = 0
        launch_force = 0
        xcompass = 0
        tile_surface_wall_xcompass = 0
        tile_check_slope_priority = 0
        tile_angle = 0
        angle_a = 0
        anim_current=anim_standing
        //Iterate clamp timer
        gravity_launch += 1
        //Disable clamp timer after three frames
        if gravity_launch &gt; 6 gravity_launch = 0;
    }

//===============Sprite Rotation Lag===============//

//If we are jumping, rotate player sprite back to zero
if (anim_current=anim_jump and angle_a!=0)
    {
        //Prevent angle from falling to negative values.
        if angle_a&lt;0 or angle_a&gt;360 angle_a=tile_angle;
        //Rotation logic.
        if angle_a&lt;180 and angle_a!=tile_angle     angle_a-=4;
        if angle_a&gt;180 and angle_a!=tile_angle     angle_a+=4;
    }
//Reset angle if we are not jumping
else
    {
        //Measure angular difference between the sprite's rotation,
        //and the terrain's angle
        angle_b = angle_difference(angle_a,tile_angle+180);
        //If the differences in angles are no longer somewhat similar,
        //rotate the player's sprite to match the tile_angle
        if abs(angle_b)&lt; 175 or abs(angle_b) &gt; 180
            {
                //Rotate the player's sprite
                var rotation_speed = 6.5;
                if ground = 0 rotation_speed = 3.5;
                angle_a += min(abs(angle_b), rotation_speed) * sign(angle_b);
            }
        //When the differences in angles are 90% similar, allow the
        //player sprite's angle to mirror the tile_angle
        else angle_a = tile_angle;
        if anim_current = anim_faster angle_a = lerp(angle_a,tile_angle,1);
    }
//If we have fallen off of the ceiling, initialize rotation lag
if angle_a=180 and (gravity_speed!=0 or ground = 0) angle_a+=4*-xdir;

//=========================================================================//
//                         Damage and Death States                         //
//=========================================================================//

//Reset Hurt State If We Are Invincible
if invuln_hud_acti = 1
    {
        hurt[0] = 0
        hurt[1] = 0
        hurt[3] = 0
    }

//Check If We Are Not Dead (And Don't Have A Shield)
if (death[0] = 0 and shield_active = 0 and shield_flash&lt;=-2 and shield_invuln = 32 and invuln_hud_acti = 0)
    {
        //=========Damage Timer=========//
        if hurt[0] = 1 and hurt_invuln = 39
            {
                //Lock animation to hurt animation
                anim_current = anim_hurt
                gravity_ladder = 0
                sit = 0
                sit_timer = 0
                scr_set_rail_grinding_stop()
                //Advance Timer
                hurt[1] += 1
                //If our sheild has just popped, skip further ahead in the timer,
                //so invulnerability lag saves the player from receiving damage
                //as soon as our shield pops
                if shield_flash&gt;-2 hurt[1]+=8;
                //Refresh randomized rotation of health petal particles, and X/Y
                //positions
                if hurt[1] = 1
                    {
                        petal_hurt_dir[0] = random_range(0,359)
                        petal_hurt_dir[1] = random_range(0,359)
                        petal_hurt_dir[2] = random_range(0,359)
                        petal_hurt_dir[3] = random_range(0,359)
                        petal_hurt_dir[4] = random_range(0,359)
                        //Petal Rotation Angle
                        petal_hurt_ang[0] = random_range(0,359)
                        petal_hurt_ang[1] = random_range(0,359)
                        petal_hurt_ang[2] = random_range(0,359)
                        petal_hurt_ang[3] = random_range(0,359)
                        petal_hurt_ang[4] = random_range(0,359)
                        //Start from player's X/Y coordinates
                        petal_offset_x[0] = px
                        petal_offset_y[0] = py
                        petal_offset_x[1] = px
                        petal_offset_y[1] = py
                        petal_offset_x[2] = px
                        petal_offset_y[2] = py
                        petal_offset_x[3] = px
                        petal_offset_y[3] = py
                        petal_offset_x[4] = px
                        petal_offset_y[4] = py
                        //Reset X/Y coordinates
                        petal_hurt_x[0] = 0
                        petal_hurt_y[0] = 0
                        petal_hurt_x[1] = 0
                        petal_hurt_y[1] = 0
                        petal_hurt_x[2] = 0
                        petal_hurt_y[2] = 0
                        petal_hurt_x[3] = 0
                        petal_hurt_y[3] = 0
                        petal_hurt_x[4] = 0
                        petal_hurt_y[4] = 0
                    }
                //If We Have Reached the End of the Timer, Reset Its Value
                if hurt[1] &gt; hurt[4] {hurt[1] = 0; hurt[0] = 0; hurt_invuln = 0;}
            }
        //If the Damager Timer is Disabled, Reset Its Values
        else hurt[1] = 0;

        //Clear hurt variables before refreshing hurt cycle
        if hurt_invuln=38
            {
                hurt[0] = 0
                hurt[1] = 0
                hurt[2] = 0
                hurt[3] = 0
            }

        //End hurt animation after 22 frames of invulnerability
        if hurt_invuln&lt;22 and anim_current=anim_hurt anim_current=anim_falling;

        //Do not allow continuous damage during the invulnerability frames
        if hurt_invuln=39
            {        
                //=========Accept Damage=========//
        
                /*If the Hurt Timer Is Valued At 1, Accept Damage
                (This prevents the player from receiving damage
                in each frame, instead of only one)*/
        
                if hurt[0] = 1 and hurt[1] &lt; 4
                    {
                        //Reset Attack Variables/Parameters
                        attack[0] = 0                 //Reset Attack State
                        attack[1] = 0                 //Reset Attack State
                        attack[2] = 0                 //Reset Attack State
                        attack[3] = 0                 //Reset Attack State
                        //Bounce Upward Slightly
                        if tile_collision_ceiling = 0 and gravity_speed &gt;= -4.2
                            gravity_speed = (gravity_speed * 0.75) - 4.2;
                        //Declip From Slopes
                        gravity_slope = 0
                        xcompass = 0
                        scr_set_rail_grinding_stop()
                        //Bounce Backwards Slightly If We Had No Speed Prior To The Hurt State
                        //Formula: SpeedX after taking damage = SpeedX * 0.75 +- 2.2
                        if hurt[1] = 2
                            {
                                if abs(hsp) &lt; 5
                                    {
                                        if xdir = -1 hsp = 2.2;
                                        if xdir = 1 hsp = -2.2;
                                    }
                                if abs(hsp) &gt;= 5
                                    {
                                        if hsp &gt; 0 hsp -= (hsp * 0.75) - 2.2;
                                        if hsp &lt; 0 hsp += (abs(hsp) * 0.75) - 2.2;
                                    }
                            }
                        //Subtract health or lives as needed, if we don't have a shield
                        if hurt[1] = 1
                            {
                                //Remove Petals From Health Bar
                                petals -= hurt[3]
                                //Do not play sound effects if we are about to die
                                if accident_forgiveness &gt;= 0
                                    {
                                        //Play Hurt Sound
                                        audio_play_sound(character_hurt,50,false)
                                        //Play Voice Sample
                                        var voice_sample = random_range(0,1.9)
                                        switch(floor(voice_sample))
                                            {
                                                case 0: {audio_play_sound(snd_player_hurt_0,50,false); break;}
                                                case 1: {audio_play_sound(snd_player_hurt_1,50,false); break;}
                                            }
                                    }
                                

                                //=========Character Death=========//

                                if petals &gt; 0
                                    accident_forgiveness = 1;
                                //If we have no more health petals, prepare to die
                                if petals &lt;= 0
                                    {
                                        accident_forgiveness -= 1
                                        if accident_forgiveness = 0
                                            {
                                                hurt_invuln = -20;
                                                //Explode if the game's difficulty is set to level 5
                                                if user_enemy_level &gt;= 4
                                                    {
                                                        var bomb_ID = instance_create(px,py,obj_bomb);
                                                        bomb_ID.detonate_for_milla = 1;
                                                        bomb_ID.dont_leave_decorations = 1;
                                                    }
                                            }
                                        if accident_forgiveness &lt; 0
                                            {
                                                if room != rm_editor
                                                    {
                                                        //Activate death trigger
                                                        death[0] = 1
                                                        //Subtract one life from the lives counter
                                                        lives -= 1
                                                        accident_forgiveness = 1
                                                        death_not_really = 0
                                                        //Reset transition timer's variable if it wasn't reset previously
                                                        transition_timer = 0
                                                        //Reset transition color's transparency if it wasn't reset previously
                                                        transition_alpha = 0
                                                        //Play character death sound
                                                        audio_play_sound(snd_player_death,50,false)
                                                        scr_set_rail_grinding_stop()
                                                    }
                                                //If we are in editor mode, reset health bar instead of dying
                                                else
                                                    {
                                                        //Refill health petal meter based on which character we're playing as
                                                        petals = 14
                                                        petalsmax = 14
                                                        accident_forgiveness = 1
                                                        death_not_really = 0
                                                        if skin = spr_milla {petals = 10; petalsmax = 10;}
                                                        //Play character death sound
                                                        audio_play_sound(snd_player_death,50,false)
                                                    }
                                            }
                                    }
                            }
                    }
            }
    }
//End of Shield Safety Check

//=========Search For Damage=========//

//If we have fallen below the bottom of the stage, reset our vertical position
if py &gt; camera_boundary_bottom+48
    {
        if room = rm_editor py = camera_boundary_bottom-128;
        else
            {
                if death[0] = 0 
                    {
                        death_not_really = 1
                        petals -= 1
                        if petals &lt; 0
                            death_not_really = 0;
                        scr_set_death();
                    }
            }
    }

//If the top and bottom collision sensors have detected tiles, (the player is crushed) die
if targets_ready != 3
    {
        if (tile_exists(tile_surface_id[1]) and tile_exists(tile_surface_id[2])
        and tile_exists(tile_surface_id[3]) and tile_exists(tile_surface_id[4]))
            {
                var yes = 1;
                //Top
                var instance_ID = collision_point(px+p_off[0,0],py+p_off[0,1],obj_destructible,false,true);
                if instance_exists(instance_ID)
                    {
                        instance_ID.attacked = 1
                        yes = 0
                    }
                //Bottom
                var instance_ID = collision_point(px+p_off[1,0],py+p_off[1,1],obj_destructible,false,true);
                if instance_exists(instance_ID)
                    {
                        instance_ID.attacked = 1
                        yes = 0
                    }
                //Left
                var instance_ID = collision_point(+p_off[2,0],py+p_off[2,1],obj_destructible,false,true);
                if instance_exists(instance_ID)
                    {
                        instance_ID.attacked = 1
                        yes = 0
                    }
                //Right
                var instance_ID = collision_point(px+p_off[3,0],py+p_off[3,1],obj_destructible,false,true);
                if instance_exists(instance_ID)
                    {
                        instance_ID.attacked = 1
                        yes = 0
                    }
                if yes = 1 and room != rm_editor
                    {
                        if death[0] = 0 
                            {
                                //Assume that we were crushed or had fallen down a pit, first
                                death_not_really = 1
                                petals -= 1
                                //If neither is the case, then die properly
                                if petals &lt; 0
                                    death_not_really = 0;
                                scr_set_death();
                            }
                    }
            }
    }

        //===========Shield Damage===========//
        
        //If we have a shield, subtract health from the shield instead
        if shield_active = 1 and shield_invuln = 32 and hurt[0] = 1 and invuln_hud_acti = 0
            {
                //If our shield has run out of health, break the shield
                if shield_health &lt;= 0
                    {
                        shield_flash = 1
                        audio_play_sound(shield_end,50,false)
                        shield_active = 0
                    }
                //Play Sound
                audio_play_sound(shield_damage,50,false)
                //Remove one health from our shield
                shield_health-=1
                //Set shield invulnerability timer to 0
                shield_invuln = 0
                //Reset hurt state variables
                hurt[0]         = 0         //Are We Hurt?
                hurt[1]         = 0         //Invulnerability Timer
                hurt[3]         = 0         //How Much Damage Should We Apply To The Player?
            }
        
        //If the shield's invulnerability timer has been set to 0, slowly refill it for 32 frames
        if shield_invuln &lt; 32 shield_invuln += 1;
        
        //Slowly refill the invulnerability timer (Allows the player 40 frames of invulnerability after receiving damage)
        if hurt_invuln&lt;39 and death[0] = 0 hurt_invuln += 1;

}//End of Pause Safety Check
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Attack Code and Spring Interactions

//===========================================================================//
//                     Collectable Item Tile Interaction                     //
//===========================================================================//

//Do not execute code if we are paused, dead, or using an alternative play mode
if pause = 0 and death[0] = 0 and user_cursor_mode = 0

{

//          Tile Attack Sensor          //
//--------------------------------------//

//Set positions of hitboxes
if milla_cube_override = 0 {attack_x = px; attack_y = py;}

//Set angular references based on the ground state
if ground = 1 var attack_tile_angle = tile_angle;
if ground = 0 var attack_tile_angle = angle_a;

//Reset reading position if a new attack is performed
if (attack[0] = 1 and active_frame=1 and attack_tile[2] = 0)
//Also check if Carol's bike is attacking
or (attack[3] = 1 and attack_tile[2] = 0)
    attack_tile[2] = 1;
var attack_line_ID = noone;
var attack_item_ID = noone;
var attack_cube_ID = noone;
//Scan for tiles inside the hitbox
while (attack_tile[2] = 1)
    {
        //Iterations for Rectangular hitboxes
        if attack_shape = 1
            {
                //Y axis of the hitbox
                travel_x_1 = px+lengthdir_x(travel_height,attack_tile_angle+90)
                travel_y_1 = py+lengthdir_y(travel_height,attack_tile_angle+90)
                //Modify direction if we are Milla
                var travel_direction = xdir
                if skin = spr_milla travel_direction = milla_xdir;
                //X axis of the hitbox
                travel_x_2 = travel_x_1+lengthdir_x(travel_length * travel_direction,attack_tile_angle+milla_special_shield_angle) //Accommodate Milla's adjustable shield angle
                travel_y_2 = travel_y_1+lengthdir_y(travel_length * travel_direction,attack_tile_angle+milla_special_shield_angle) //Accommodate Milla's adjustable shield angle
        
                //Iterate through the hitbox horizontally
                travel_length += 12

                //Search for interactable enemies
                attack_line_ID = collision_line(travel_x_1,travel_y_1,travel_x_2,travel_y_2,obj_enemy_parent,false,true);
                attack_item_ID = collision_line(travel_x_1,travel_y_1,travel_x_2,travel_y_2,obj_destructible,false,true);
                attack_cube_ID = collision_line(travel_x_1,travel_y_1,travel_x_2,travel_y_2,obj_player_cube_alt,false,true);
            }
        //Iterations for Elliptical hitboxes
        else
            {   
                //Iterate through positions inside the hitbox based on direction
                x_travel = attack_x+lengthdir_x(x_traveling,attack_tile_angle+travel_length)
                y_travel = attack_y-attack_offset+lengthdir_y(y_traveling,attack_tile_angle+travel_length)
                x_traveling += 12 * xdir
                y_traveling += 12 * xdir
                //Search for interactable enemy hurtboxes
                attack_line_ID = collision_point(x_travel,y_travel,obj_enemy_parent,false,true);
                attack_item_ID = collision_point(x_travel,y_travel,obj_destructible,false,true);
                attack_cube_ID = collision_point(x_travel,y_travel,obj_player_cube_alt,false,true);
            }

        if attack_line_ID != noone and pause_logic = 0 and pause_logic_gap = 0 and milla_pause_logic = 0
            {
                if attack_line_ID.heart &gt;= 0 and attack_line_ID.alpha &lt; 0.7 and attack_line_ID.unkillable = 0
                    {
                        attack_line_ID.attacked = 1
                        attack_line_ID.attacked_damage = attack_damage
                        if (user_freeze_frames = 1) pause_logic = 5;
                        if (user_freeze_frames = 0 or skin = spr_milla) milla_pause_logic = 5;
                        carol_speed_up = 30;
                    }
            }
        if attack_item_ID != noone
            attack_item_ID.attacked = 1;
        if attack_cube_ID != noone
            {
                if attack_cube_ID.cube_jiggle_timer = 0
                    {
                        attack_cube_ID.cube_jiggle_timer = 10
                        attack_cube_ID.cube_health += 0.25
                    }
            }

        //Rectangular hitboxes
        if attack_shape = 1
            {
                //Iterate upwards through the hitbox if we have reached the hitbox's horizontal edge
                if travel_length &gt;  attack_width and travel_height &lt;= attack_range {travel_length  = 0; travel_height += 8}
                //Reset hitbox scanner if we have reached the hitbox's top edge
                if travel_length &gt;= attack_width and travel_height &gt;  attack_range
                    {
                        travel_length  = 0;
                        travel_height  = 0;
                        attack_tile[2] = 0;
                    }
            }
        //Elliptical hitboxes
        else
            {
                //If we are at the end of the hitbox, move down one pixel and keep reading
                if x_traveling &gt;= attack_range or x_traveling &lt;= -attack_range
                    {
                            x_traveling = 0
                            y_traveling = 0
                            travel_length += 8 * xdir
                        //If we have reached the end of the hitbox, reset values and stop reading
                        if travel_length &gt; attack_width or travel_length &lt;-attack_width
                            {
                                x_traveling = 0
                                y_traveling = 0
                                travel_length  = 0
                                attack_tile[2] = 0
                            }
                    }
            }
    }

//===========================================================================//
//                       Spring Animation and Movement                       //
//===========================================================================//

if spring_timer&gt;=0 and pause_logic = 0
    {
        //Decrement Timer
        spring_timer-=1
        //Apply Static Speed During Trajectory
        if (spring_timer&gt;0)
            {
                //Apply speed based on the parameter passed to us, as long as flat surface sensors aren't detecting anything,
                //and decrease the spring's strength over time (Since normal gravity is overridden in spring mode)
                switch(spring_rotate)
                    {
                        case   0: {if wall_collision_right=1 or tile_wall_trigger = 1 spring_x_speed_hold = 1; if spring_x_speed_hold = 0 hsp=spring_speed_x;}
                        case  45: {gravity_speed=-spring_speed; if wall_collision_right=1 or tile_wall_trigger = 1 spring_x_speed_hold = 1; if spring_x_speed_hold = 0 hsp=spring_speed_x; spring_speed-=gravity_accel; break;}
                        case  90: {gravity_speed=-spring_speed; spring_speed-=gravity_accel; break;}
                        case 135: {gravity_speed=-spring_speed; spring_speed-=gravity_accel; if wall_collision_left=1 or tile_wall_trigger_l = 1 spring_x_speed_hold = 1; if spring_x_speed_hold = 0 hsp=-spring_speed_x; break;}
                        case 180: {if wall_collision_right=1 or tile_wall_trigger = 1 spring_x_speed_hold = 1; if spring_x_speed_hold = 0 hsp=-spring_speed_x;}
                        case 225: {gravity_speed=spring_speed;  if wall_collision_left=1 or tile_wall_trigger_l = 1 spring_x_speed_hold = 1; if spring_x_speed_hold = 0 hsp=-spring_speed_x; break;}
                        case 270: {gravity_speed=spring_speed;  break;}
                        case 315: {gravity_speed=spring_speed;  if wall_collision_right=1 or tile_wall_trigger = 1 spring_x_speed_hold = 1; if spring_x_speed_hold = 0 hsp=spring_speed_x; break;}
                        default:  {break;}
                    }
            }
        //Stop against walls
        if (wall_collision_right = 1 and (spring_rotate = 45 or spring_rotate = 315))
        or (wall_collision_left = 1 and (spring_rotate = 135 or spring_rotate = 225))
            spring_speed_x = 0;
    }

if  spring_ceiling_timer &gt; 0 and pause_logic = 0
and wall_collision_right = 0 and wall_collision_left = 0
    {
        hsp=spring_ceiling_speed;
        spring_ceiling_timer -= 1;
    }

//Reset Spring State Upon Exiting
if (spring_timer &gt; 0 and (ground = 1 or tile_collision_ceiling = 1))
or (spring_timer = 0)
    {
        if  spring_rotate != 90
        and spring_rotate != 270
        and spring_speed_x != 0
            {
                fling_hsp = spring_speed_x
                if spring_rotate = 135
                or spring_rotate = 225
                    fling_hsp = -spring_speed_x;
                fling_timer = 4
                hsp = fling_hsp
            }
        spring_state = 0
        spring_timer = -1
        spring_x_speed_hold = 0
        spring_rotate = -1
        //Fall Animation
        anim_current=anim_falling
    }
if spring_timer &lt;= 0 spring_rotate = -1;
}
//End of Pause Check
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Camera System

//===========================================================================//
//                         Tile-Based Camera Systems                         //
//===========================================================================//

//Do not follow the player if we are paused, or the player has died
if pause = 0 and death[0] = 0 and user_cursor_mode = 0
    {
        //Create an orbital point above the player's feet for the camera to center itself onto
        if xcompass != 0 and view_scroll_h &lt; 24 view_scroll_h += 0.5;
        if xcompass  = 0 and view_scroll_h &gt; 0  view_scroll_h -= 0.5;

        //Camera Zoom Effect
        if use_zoom_multiplier != use_zoom_scale_factor and room != rm_editor
            {
                use_zoom_counter += 0.001
                clamp(use_zoom_counter,0.03,0.08)
                view_wview[view_port] = lerp(view_wview[view_port],use_zoom_x_view,use_zoom_counter)
                view_hview[view_port] = lerp(view_hview[view_port],use_zoom_y_view,use_zoom_counter)
                if pause = 0 use_zoom_multiplier = lerp(use_zoom_multiplier,use_zoom_scale_factor,use_zoom_counter);
            }
        //Clamp Resolution
        clamp(view_wview[view_port],426,2130)
        clamp(view_hview[view_port],240,1200)

        var camera_x = px+lengthdir_x(view_scroll_h,angle_a+90);
        var camera_y = py+lengthdir_y(24,angle_a+90);
        var camera_wcenter = view_wview[view_port]/2;
        var camera_hcenter = view_hview[view_port]/2;
        var camera_border = view_hview[view_port]*0.2916666666666667;

        //Change Camera Angle Based On Tile Angle; Only Enable For Recording Memes!
        //view_angle[view_port] = -angle_a

        //     Vertical Camera Actions     //
        //---------------------------------//

        //Do not allow vertical camera functions while the player is looking up or down
        if view_pan_on = 0
            {
                //Follow the player's Y position
                if  (camera_y&gt;=camera_hcenter) and (gravity_speed &gt;= 0 and view_clip = 1)
                    view_yview[view_port] = camera_y-camera_hcenter;
                //If we are jumping, disable strict Y clipping
                if  (gravity_speed&lt;0) view_clip=0;
                //If we are jumping near the boundary of the HUD on the screen, clip to the border of the HUD.
                if (camera_y&lt;view_yview[view_port]+camera_border and gravity_ladder=0)
                    view_yview[view_port] = camera_y-camera_border;
                //Keep camera centered while climbing a ladder
                if (camera_y&lt;=view_yview[view_port]+camera_hcenter and gravity_speed&lt;0 and gravity_ladder=1)
                    {
                        //If the camera is currently not centered, follow the player up
                        if (view_yview[view_port] &gt;  camera_y-camera_hcenter) view_yview[view_port] -= view_panspeed;
                        //Once the view is re-centered, keep it that way
                        if (view_yview[view_port] &lt;= camera_y-camera_hcenter) view_yview[view_port] = camera_y-camera_hcenter;
                    }
                //If we have fallen below the center of the screen, return to normal player Y clipping.
                if  (camera_y&gt;=view_yview[view_port]+camera_hcenter and view_clip=0)
                    view_clip=1;
                //If we have landed and the camera has not returned to normal, move camera upwards until this is true
                if (tile_collision_ceiling = 0 and gravity_speed=0 and view_clip=0)
                    view_yview[view_port]-=view_panspeed
                    //Lerp Equivalent If Desired
                    //view_yview[view_port]= lerp(view_yview[view_port],camera_y-view_center[1],0.15)
            }
        
        //    Horizontal Camera Actions    //
        //---------------------------------//
        
        //If we are not touching the left or right boundary lines of the view,
        //follow the player's X position
        if camera_x &gt;= view_xview[view_port]+camera_wcenter+view_offset

            view_xview[view_port] = camera_x-camera_wcenter-view_offset;

        if camera_x &lt;= view_xview[view_port]+camera_wcenter+view_offset-view_margin
        
            view_xview[view_port] = camera_x-camera_wcenter-view_offset+view_margin;

        //Enable or disable camera panning based on our speed and ground state
        if (abs(hsp) &gt;= 5  and ground = 1)      view_pan_forward = 1;
        if (hsp &gt;= -3 and hsp &lt;= 3) or (ground = 0) view_pan_forward = 0;
        //Pan camera forward if we are running
        if view_pan_forward = 1 and xcompass = 0
            {
                if view_offset &gt;-65 and hsp &gt; 0 view_offset-=2.5;
                if view_offset &lt; 65 and hsp &lt; 0 view_offset+=2.5;
            }
        //Pan camera back if we are no longer running
        if view_pan_forward = 0 and xcompass = 0
            {
                if view_offset &gt; 0 view_offset-=1;
                if view_offset &lt; 0 view_offset+=1;
            }
        //Snap the camera to its boundaries, if we have reached them
        if view_offset &lt;-65 view_offset = -65;
        if view_offset &gt; 65 view_offset =  65;
        //If we are standing still, and the dragon boost is not active, pan the camera backwards
        if lilac_dragon_boost_timer=30
            {
                if (abs(hsp) &lt; 5 and ground = 1 and view_offset != 0)
                or (ground = 0   and view_offset != 0)
                    {
                        if view_offset&lt;0 view_offset+=2.5;
                        if view_offset&gt;0 view_offset-=2.5;
                    }
            }

        //      Camera Shaking Actions      //
        //----------------------------------//
        
        if view_shake &gt;= 0 and user_camera_shake = 1
            {
                //Decrement camera shake length timer
                view_shake-=1
                //Increment camera shake iteration timer
                view_shake_iterations += 1
                //Lessen camera shake over time
                if view_shake_mod &gt; 0.1 view_shake_mod -= 0.1;
                //Reset camera shake iteration timer
                if view_shake_iterations &gt; 3 view_shake_iterations = 0;
                //Camera x shake
                switch(view_shake_iterations)
                    {
                        case 0: {view_xview[view_port]+=view_shake_mod;  view_yview[view_port]+=view_shake_mod;  break;}
                        case 1: {view_xview[view_port]-=view_shake_mod;  view_yview[view_port]-=view_shake_mod;  break;}
                        case 2: {view_xview[view_port]-=view_shake_mod;  view_yview[view_port]-=view_shake_mod;  break;}
                        case 3: {view_xview[view_port]+=view_shake_mod;  view_yview[view_port]+=view_shake_mod;  break;}
                    }
                //If the timer has ended, stop camera shake
                if view_shake=0
                    {
                        view_shake_iterations =  0
                        view_shake            = -1
                        view_shake_mod        =  3
                    }
            }

        //      Camera Panning Actions      //
        //----------------------------------//

        //Pan the camera upwards or downwards, if we are looking up or down
        if (anim_current = anim_looking_up or anim_current = anim_ducking) and (view_pan_on &lt; 2)
            {
                switch(anim_current)
                    {
                        //Looking up
                        case anim_looking_up:
                            {
                                if view_scrolling &lt; 48 view_timer += 1;
                                view_pan_on = 1
                
                                if view_timer &gt;= 32 and view_scrolling &lt; 48
                                    {
                                        view_scroll-=2
                                        view_scrolling += 1
                                    }
                                //Override the camera's vertical position
                                view_yview[view_port] = camera_y-camera_hcenter+view_scroll;
                                break;
                            }
                        //Looking down
                        case anim_ducking:
                            {
                                if view_scrolling &lt; 48 view_timer += 1;
                                view_pan_on = 1
                
                                if view_timer &gt;= 106 and view_scrolling &lt; 48
                                    {
                                        view_scroll+=2
                                        view_scrolling += 1
                                    }
                                //Override the camera's vertical position
                                view_yview[view_port] = camera_y-camera_hcenter+view_scroll;
                                break;
                            }
                    }
            }
        //Set the trigger for panning back to the normal view, if looking has either ended or been interrupted
        if not (anim_current = anim_looking_up or anim_current = anim_ducking) and (view_pan_on = 1)
            {
                view_pan_on = 2
                view_timer = 0
            }
        //Panning back to the normal view
        if view_pan_on &gt;= 2
            {
                //Pan up
                if view_scroll &lt; 0
                    {
                        view_scroll+=2
                        view_scrolling -= 1
                        //Override the camera's vertical position
                        view_yview[view_port] = camera_y-camera_hcenter+view_scroll
                    }
                //Pan down
                if view_scroll &gt; 0
                    {
                        view_scroll-=2
                        view_scrolling -= 1
                        //Override the camera's vertical position
                        view_yview[view_port] = camera_y-camera_hcenter+view_scroll
                    }
                //Return the view to normal
                if view_scrolling &lt;= 0
                    {
                        view_timer = 0
                        view_scrolling = 0
                        view_scroll = 0
                        view_pan_on = 0
                    }
            }

        //     Camera Snapping Systems     //
        //---------------------------------//

        //Override any previous decisions made by the camera, if the camera is touching the borders of the room
        var current_camera_boundary_left   = camera_boundary_left;
        var current_camera_boundary_top    = camera_boundary_top;
        var current_camera_boundary_right  = camera_boundary_right;
        var current_camera_boundary_bottom = camera_boundary_bottom;

        //If the boss's camera boundary has been implemented at all for a map's stage, its bottom-most boundary
        //probably won't be in the negatives, so- let's just check for that :^P
        if boss_boundary_bottom != -10000
            {
                if point_in_rectangle(px,py,boss_boundary_left,boss_boundary_top,boss_boundary_right,boss_boundary_bottom+8)
                //Increase horizontal range while transitioning to another map file
                or (transition_timer &gt; 0 and
                point_in_rectangle(px,py,boss_boundary_left-500,boss_boundary_top,boss_boundary_right+500,boss_boundary_bottom+8))
                    {
                        current_camera_boundary_left   = boss_boundary_left;
                        current_camera_boundary_top    = boss_boundary_top;
                        current_camera_boundary_right  = boss_boundary_right;
                        current_camera_boundary_bottom = boss_boundary_bottom;
                    }
            }
        if lock_boundary_bottom != -10000
            {
                if point_in_rectangle(px,py,lock_boundary_left,lock_boundary_top,lock_boundary_right,lock_boundary_bottom+8)
                //Increase horizontal range while transitioning to another map file
                or (transition_timer &gt; 0 and
                point_in_rectangle(px,py,lock_boundary_left-500,lock_boundary_top,lock_boundary_right+500,lock_boundary_bottom+8))
                    {
                        current_camera_boundary_left   = lock_boundary_left;
                        current_camera_boundary_top    = lock_boundary_top;
                        current_camera_boundary_right  = lock_boundary_right;
                        current_camera_boundary_bottom = lock_boundary_bottom;
                    }
            }

        //Prevent camera from panning beyond the beginning of the room
        if view_xview[view_port] &lt; current_camera_boundary_left view_xview[view_port] = current_camera_boundary_left;
        //As well as the end of the room
        if view_xview[view_port] &gt; current_camera_boundary_right-view_wview[view_port]
            view_xview[view_port] = current_camera_boundary_right-view_wview[view_port];
        //Prevent camera from panning above the room
        if view_yview[view_port] &lt;= current_camera_boundary_top view_yview[view_port] = current_camera_boundary_top;
        //As well as below the room
        if view_yview[view_port] &gt;= current_camera_boundary_bottom-view_hview[view_port]
            view_yview[view_port] = current_camera_boundary_bottom-view_hview[view_port];

        var current_camera_id = collision_rectangle(view_xview[view_port],view_yview[view_port],view_xview[view_port]+view_wview[view_port],view_yview[view_port]+8,obj_camera_stop_plane,false,true)
        if instance_exists(current_camera_id)
            {
                if view_yview[view_port] &lt; current_camera_id.y
                    {
                        view_yview[view_port] = current_camera_id.y
                        view_top_lock = current_camera_id.y
                    }
            }
        if view_top_lock != 0
            {
                view_yview[view_port] = view_top_lock

                if py &gt; view_yview[view_port] + (view_hview[view_port]/2)
                    view_top_lock = 0;
            }

    } //End of Pause Safety Check
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Shields and Passive Effects

//Check For The Shield's Existence
if pause = 0 and user_cursor_mode = 0 and pause_logic = 0

{

//Shield Flash Effect For Flowers
if shield_flash_trigger = 1
    {
        //Iterate Flash Timer
        shield_flash_frame -= 0.45
        //Disable Flash After Animations Have Completed
        if shield_flash_frame &lt; 0
            {
                shield_flash_trigger = 0
                shield_flash_frame = 8
            }
    }

//Destroy shield if we have an active shield and have landed in the water, or are getting rained on,
//on the hardest difficulty settings
if  (user_enemy_level &gt;= 3 and shield_active = 1) and
    (above_water = 0 or obj_game_logic.use_weather_conditions &gt; 0) and
    (shield != spr_shield_water)
    {
        shield_health = 0
        shield_flash = 1
        audio_play_sound(shield_end,50,false)
        shield_active = 0
    }

//Iterate Shield Timer
if shield_timer &gt;= 0 shield_timer-=1;
//After Defined Duration, Activate Shield
if shield_timer &gt;=-1 and shield_timer &lt; 0
    {
        //Play Shield Sound
        switch(shield_hold)
            {
                case spr_shield_earth:
                    {
                        shield_speed=0.12;   //Shield Animation Speed
                        shield_framemax=8;   //Shield Maximum Frames of Animation
                        audio_play_sound(shield_earth,50,false);
                        break;
                    }
                case spr_shield_fire_front:
                    {
                        shield_speed=0.24;   //Shield Animation Speed
                        shield_framemax=8;   //Shield Maximum Frames of Animation
                        audio_play_sound(shield_fire,50,false);
                        break;
                    }
                case spr_shield_metal:
                    {
                        shield_speed=0.75;   //Shield Animation Speed
                        shield_framemax=17;  //Shield Maximum Frames of Animation
                        audio_play_sound(shield_metal,50,false);
                        break;
                    }
                case spr_shield_water:
                    {
                        shield_speed=0.24;   //Shield Animation Speed
                        shield_framemax=7;  //Shield Maximum Frames of Animation
                        audio_play_sound(shield_water,50,false);
                        break;
                    }
                case spr_shield_wood:
                    {
                        shield_speed=0.24;   //Shield Animation Speed
                        shield_framemax=10;  //Shield Maximum Frames of Animation
                        audio_play_sound(shield_wood,50,false);
                        break;
                    }
                case spr_shield_rock:
                    {
                        shield_speed=0.24;   //Shield Animation Speed
                        shield_framemax=0;   //Shield Maximum Frames of Animation
                        audio_play_sound(shield_rock,50,false);
                        break;
                    }
            }
        //Set Shield Graphic To Our Held Shield In The Queue
        shield=shield_hold;
        //Set Shield Health, or Restore It If Was Previously Emptied
        shield_health = 1
        shield_rotate_speed = 0
        shield_rotate_target = 16
        shield_rotate_timer = 0
        //Give the Puppy An Extra Health Point
        if skin=spr_milla shield_health = 2;
        //Reset Water Shield Rotation
        obj_game_logic.shield_rotate = 0
        //Reset Animation Frame, If It Was Not Previously
        obj_game_logic.shield_frame = 0  
        //If We Had A Shield Prior, Only Flash One Frame
        if shield_active = 1 shield_flash=1;
        //Set Shield As Active
        if shield_active = 0
            {
                shield_active = 1
                //Reset Shield Flash Timer
                shield_flash  = 8
                //Reset Gem Counter
                petals_count = 0
            }
        //Reset Shield Timer
        shield_timer  = -8
    }

//=========Shield Petal Counter=========//

if (shield_active = 1 and shield = spr_shield_wood)
    {
        //If we have collected 15 gems since the wood shield was active,
        //give the player a life petal and reset the counter
        if petals_count &gt; 14
            {
                //Play whistle sound
                audio_play_sound(petal_grab,50,false)
                //Spawn a petal flower
                petal_counted = instance_create(px,py-32,obj_petal)
                //Apply gravity to the petal flower
                petal_counted.is_floating = 0
                //Reset counter
                petals_count = 0
            }
        
    }

//      Shield Animation System      //
//-----------------------------------//

//Iterate through flash frames, even if a shield is not active
if shield_flash &gt;=-2 shield_flash -= 1;

if (shield_active = 1)
    {
        //Iterate Through Frames
        shield_frame += shield_speed
        
        //Set Rotation Axis
        shield_rotate_x = px + lengthdir_x(24,angle_a+90)
        shield_rotate_y = py + lengthdir_y(24,angle_a+90)
        
        //If we are the fire shield, instantly break it when underwater
        if py &gt; water_height and shield=spr_shield_fire_front
            {
                //Restart shield flash animation
                shield_flash = 1
                //Play sound
                audio_play_sound(shield_end,50,false)
                //Disable shield
                shield_active=0
            }

        //Restart Shield Animations Once We Have Reached The Maximum Number of Frames
        if shield_frame &gt; shield_framemax
            {
                shield_frame = 0
                if shield=spr_shield_water shield_rotate += 90;
            }

        //      Shield Particles System      //
        //-----------------------------------//

        //Water Shield Bubbles
        if (shield = spr_shield_water)
            {
                //Raise Both Bubbles, and Diminish Their Alpha Values Over Time
                bubble_y+=1 bubble_alpha+=0.025
                //Once Alpha Has Reached 0, Reset Y Positions and Randomize X Positions
                if bubble_alpha&gt;1
                    {
                        bubble_x = random_range(-24,24)
                        bubble_y = 0
                        bubble_alpha = 0
                        bubble_x2 = random_range(-24,24)
                    }
            }
        //Rock Shield
        if (shield = spr_shield_rock)
            {
                if hsp = 0
                    {
                        shield_rotate_speed = lerp(shield_rotate_speed,shield_rotate_target,0.25);
                        shield_rotate -= shield_rotate_speed;
                        shield_rotate_timer += 1
                        if shield_rotate_timer = 64
                            shield_rotate_target = 16;
                        if shield_rotate_timer &gt;= 128
                            {
                                shield_rotate_target = 2
                                shield_rotate_timer = 0
                            }
                    }
                shield_rotate += abs(hsp)*-xdir
            }
        //Wood Shield Petals
        if (shield = spr_shield_wood)
            {
                //Lower All Petals, and Diminish Their Alpha Values Over Time
                petal_y[0]-=0.5
                petal_y[1]-=0.5
                petal_y[2]-=0.5
                petal_y[3]-=0.5
                petal_y[4]-=0.5
                petal_y[5]-=0.5
                petal_y[6]-=0.5
                petal_y[7]-=0.5
                petal_y[8]-=0.5
                petal_y[9]-=0.5
                if petal_y[0]&lt;38 petal_alpha[0]+=0.015;
                if petal_y[1]&lt;38 petal_alpha[1]+=0.015;
                if petal_y[2]&lt;38 petal_alpha[2]+=0.015;
                if petal_y[3]&lt;38 petal_alpha[3]+=0.015;
                if petal_y[4]&lt;38 petal_alpha[4]+=0.015;
                if petal_y[5]&lt;38 petal_alpha[5]+=0.015;
                if petal_y[6]&lt;38 petal_alpha[6]+=0.015;
                if petal_y[7]&lt;38 petal_alpha[7]+=0.015;
                if petal_y[8]&lt;38 petal_alpha[8]+=0.015;
                if petal_y[9]&lt;38 petal_alpha[9]+=0.015;
                //Set Our Petal Speed
                petal_x[0] += petal_speed
                petal_x[1] -= petal_speed
                petal_x[2] += petal_speed
                petal_x[3] -= petal_speed
                petal_x[4] += petal_speed
                petal_x[5] -= petal_speed
                petal_x[6] += petal_speed
                petal_x[7] -= petal_speed
                petal_x[8] += petal_speed
                petal_x[9] -= petal_speed
                //Sway Petals Back And Forth
                if petal_speed &lt; 2 and petal_timer = 0 petal_speed+=0.15;
                if petal_speed &gt; 2 {petal_timer=1}
                //
                if petal_speed &gt;-2 and petal_timer = 1 petal_speed-=0.15;
                if petal_speed &lt;-2 petal_timer=0;
                //Rotate Petals
                petal_angle[0]+=6
                petal_angle[1]-=6
                petal_angle[2]+=6
                petal_angle[3]-=6
                petal_angle[4]+=6
                petal_angle[5]-=6
                petal_angle[6]+=6
                petal_angle[7]-=6
                petal_angle[8]+=6
                petal_angle[9]-=6
                //Once Y Has Reached 0, Reset Y Positions, Angles, And Alpha Values
                if petal_y[0]&lt;0
                    {
                        petal_x[0] = random_range(-12,-4) //Petal X 1
                        petal_y[0] = random_range(40,48)  //Petal Y 1
                        petal_alpha[0]    = 0             //Petal 1 Alpha
                        petal_angle[0]    = 0             //Petal 1 Angle
                    }
                //Petal 2
                if petal_y[1]&lt;0
                    {
                        petal_x[1] = random_range(-16,-8) //Petal X 2
                        petal_y[1] = random_range(32,48)  //Petal Y 2
                        petal_alpha[1]    = 0             //Petal 2 Alpha
                        petal_angle[1]    = 16            //Petal 2 Angle
                    }
                //Petal 3
                if petal_y[2]&lt;0
                    {
                        petal_x[2] = random_range(-16,-8) //Petal X 3
                        petal_y[2] = random_range(32,48)  //Petal Y 3
                        petal_alpha[2]    = 0             //Petal 3 Alpha
                        petal_angle[2]    = 32            //Petal 3 Angle
                    }
                //Petal 4
                if petal_y[3]&lt;0
                    {
                        petal_x[3] = random_range(-24,-8) //Petal X 4
                        petal_y[3] = random_range(32,40)  //Petal Y 4
                        petal_alpha[3]    = 0             //Petal 4 Alpha
                        petal_angle[3]    = 48            //Petal 4 Angle
                    }
                //Petal 5
                if petal_y[4]&lt;0
                    {
                        petal_x[4] = random_range(-24,-8) //Petal X 5
                        petal_y[4] = random_range(32,40)  //Petal Y 5
                        petal_alpha[4]    = 0             //Petal 5 Alpha
                        petal_angle[4]    = 64            //Petal 5 Angle
                    }
                //Petal 6
                if petal_y[5]&lt;0
                    {
                        petal_x[5] = random_range(8,16)  //Petal X 6
                        petal_y[5] = random_range(32,48) //Petal Y 6
                        petal_alpha[5]    = 0            //Petal 6 Alpha
                        petal_angle[5]    = 80           //Petal 6 Angle
                    }
                //Petal 7
                if petal_y[6]&lt;0
                    {
                        petal_x[6] = random_range(8,16)  //Petal X 7
                        petal_y[6] = random_range(32,48) //Petal Y 7
                        petal_alpha[6]    = 0            //Petal 7 Alpha
                        petal_angle[6]    = 80           //Petal 7 Angle
                    }
                //Petal 8
                if petal_y[7]&lt;0
                    {
                        petal_x[7] = random_range(8,24)  //Petal X 8
                        petal_y[7] = random_range(32,40) //Petal Y 8
                        petal_alpha[7]    = 0            //Petal 8 Alpha
                        petal_angle[7]    = 80           //Petal 8 Angle
                    }
                //Petal 9
                if petal_y[8]&lt;0
                    {
                        petal_x[8] = random_range(8,24)  //Petal X 9
                        petal_y[8] = random_range(32,40) //Petal Y 9
                        petal_alpha[8]    = 0            //Petal 9 Alpha
                        petal_angle[8]    = 80           //Petal 9 Angle
                    }
                //Petal 10
                if petal_y[9]&lt;0
                    {
                        petal_x[9] = random_range(4,12)  //Petal X 10
                        petal_y[9] = random_range(40,48) //Petal Y 10
                        petal_alpha[9]    = 0            //Petal 10 Alpha
                        petal_angle[9]    = 80           //Petal 10 Angle
                    }
            }

    } //End of Shield Active Check
}
//End of Shield Check

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Character-Specific Logic</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Lilac Action System

//Do not execute code if we are not Lilac
if skin = spr_lilac and user_cursor_mode = 0
    {
        if anim_idle_timer &gt;= 120 and tile_angle = 0 and alt_skin != 2
            {
                var disco_id = collision_circle(universal_player_x,universal_player_y,256,obj_disco_ball,false,true);
                if instance_exists(disco_id)
                    {
                        if disco_id.fade_effect_target = 0.5
                            {
                                anim_current = anim_lilac_dancing
                                if frame &lt; anim_lilac[anim_lilac_dancing,0]
                                    {
                                        frame = anim_lilac[anim_lilac_dancing,0]
                                        
                                    }
                            }
                    }
            }
        if sit = 1
            {
                var bench_id = collision_circle(px,py,24,obj_bench,false,true);
                if instance_exists(bench_id)
                    {
                        px = lerp(px,bench_id.x,0.25);
                        xdir = 1
                        anim_current = anim_lilac_sitting
                        if frame &lt; anim_lilac[anim_lilac_sitting,0]
                            {
                                frame = anim_lilac[anim_lilac_sitting,0]
                            }
                    }
                else
                    sit = 0;
                sit_timer += 1
                //"Rest" mechanic
                if (stamina &lt; 96) stamina += 0.4;

                if (sit_timer &gt; 30)
                and (joy_input[0,0] = 1
                or joy_input[0,1] = 1
                or joy_input[0,2] = 1
                or joy_input[0,3] = 1
                or joy_input[1,0] = 1
                or joy_input[1,1] = 1
                or joy_input[1,2] = 1
                or joy_input[1,3] = 1
                or joy_input[1,4] = 1)
                    {
                        sit = 0
                        sit_timer = 0
                        anim_current=anim_standing
                    }
            }

        //================Post Speed Checks================//

        //Make sure we cannot go above 15px/f under any circumstances, by resetting movement to 15px/s
        //at the beginning of each step, if it is above 15px/f
        if hsp &gt;  15 hsp =  15;
        if hsp &lt; -15 hsp = -15;
        //Never allow the player to go above 15px/f upwards, either
        if gravity_speed &lt; -15 gravity_speed = -15;
        if gravity_speed &gt; 15  gravity_speed = floor(15);
        //Prevent player from leaving the boundaries of the camera
        if use_maps_multi_map_mode = 0 and (room != rm_campaign)
            {
                if px &lt; camera_boundary_left+15  {px = camera_boundary_left+15;  hsp = 0;}
                if px &gt; camera_boundary_right-15 {px = camera_boundary_right-15; hsp = 0;}
            }
        //Prevent player from infinitely flying above the ceiling
        if py &lt; camera_boundary_top-64
            py = camera_boundary_top-64;
        var lilac_animation_override = 0;
        if (use_maps_multi_map_mode = 1) or (room = rm_campaign)
            {
                if px &lt; camera_boundary_left+15  {px = camera_boundary_left+15;  hsp = 0;}
                if (px &gt; camera_boundary_right-32 and room != rm_editor)
                    {
                        if (use_maps_boundary = 0)
                        or (room = rm_campaign and campaign_stage_select &lt; campaign_stage_section_limit)
                            {
                                //Fade to black after a certain period of time
                                transition_alpha+=0.1288
                                transition_timer += 1
                                px += 3
                                lilac_animation_override = 1
                                if ground = 1
                                    {
                                        anim_current=anim_walking;
                                        anim_previous=anim_walking;
                                    }
                                else
                                    {
                                        if px &lt; camera_boundary_right py += 2.5;
                                        anim_current=anim_falling;
                                    }
                                if transition_timer &gt;=114
                                    {
                                        transition_loading = 1
                                        transition_alpha = 1
                                        transition_timer = 0
                                        now_loading = 1
                                        use_maps_current_map += 1
                                        checkpoint_x = 0
                                        checkpoint_y = 0
                                        if room = rm_campaign
                                            {
                                                use_cutscene = 0
                                                dont_change_music = 1
                                                use_maps_current_map = 0
                                                campaign_stage_select += 1
                                                use_cuts_select = campaign_stage_section[campaign_stage_select]
                                            }
                                        use_maps_load = 1
                                    }
                                joy_input[2,6] = 30
                            }
                        else
                            {
                                if px &gt; camera_boundary_right-15
                                    {
                                        px = camera_boundary_right-15;
                                        hsp = 0;
                                    }
                            }
                    }
                if room = rm_editor
                    {
                        if px &gt; camera_boundary_right-15 {px = camera_boundary_right-15; hsp = 0;}
                    }
            }

         if pause = 0 and pause_logic = 0
            {
                //==============Input System==============//

                //Attack Button Locking
                if joy_input[1,0] = 1 joy_input[2,5]+= 1;
                else                  joy_input[2,5] = 0;

                //Reset Attack Button Locking If An NPC Is Nearby
                if joy_input[2,5] &gt; 0
                    {
                        var npc_check = instance_nearest(universal_player_x,universal_player_y,obj_interact_parent);
                        if instance_exists(npc_check)
                            {
                                if point_distance(npc_check.x,npc_check.y,universal_player_x,universal_player_y) &lt; 64
                                    {
                                        if ((px &gt; npc_check.x and xdir = -1)
                                        or  (px &lt;= npc_check.x and xdir = 1))
                                            joy_input[2,5] = 0;
                                    }
                            }
                    }
                //Middle Button Combination (Lilac)
                if joy_mouse_button_switch = 1
                    {
                        if (mouse_check_button(mb_left) and mouse_check_button(mb_right))
                            joy_mouse_button_timer += 1;
                        else
                            joy_mouse_button_timer = 0;
                        if joy_mouse_button_timer &gt; 4
                            joy_input[1,mouse_middle] = 1;
                    }
                //Cyclone Attack Locking
                if (anim_current=anim_lilac_cyclone
                or  anim_current=anim_lilac_dragon_boost_1
                or  anim_current=anim_lilac_dragon_boost_2
                or  anim_current=anim_lilac_dragon_boost_r)
                and ground = 0 and lilac_cyclone_refresh = 0
                
                    lilac_cyclone_refresh = 1;

                //Allow the cyclone attack to execute once the player has either landed on the ground, in the water, or on a spring, or got hurt
                if (lilac_cyclone_refresh = 1) and (ground=1 or py &gt; water_height or spring_timer &gt; 0 or hurt[0] = 1 or gravity_ladder!=0)
                    
                    lilac_cyclone_refresh = 0;

                //Refresh Invulnerability State
                if (invuln_hud_time = 0 and invuln_hud_acti = 1) invuln_hud_acti = 0;

                //Jump Button Locking
                if joy_input[1,2] = 1 lilac_jump_press+= 1;
                if joy_input[1,2] = 0 lilac_jump_press = 0;

                //Hang Bar Jump Button Locking
                if gravity_ladder!=0
                    {
                        lilac_hang_bar_jump  = 4;
                            lilac_sprite_offset_x = 0
                            lilac_sprite_offset_y = 0
                            lilac_tail_offset_x = 0
                            lilac_tail_offset_y = 0
                    }
                else
                    {
                        if lilac_hang_bar_jump &gt; 0
                            lilac_hang_bar_jump -= 1;
                    }
                if  ((anim_current &gt; 0 and anim_current &lt;= 3) or (gravity_rail_check = 0 and anim_current = anim_lilac_rail_grinding))
                and (lilac_animation_override = 0 and hurt[0] = 0)
                    {
                        if (ground = 1 and xcompass = 0)
                            {
                                if hsp = 0
                                    {
                                        if (joy_input[0,2] = 0 and joy_input[0,0] = 0)
                                            anim_current=anim_standing;
                                        else
                                            anim_current=anim_wall_pushing;
                                    }
                                //Walking Animation
                                if (abs(hsp) &gt; 0 and abs(hsp) &lt; hcap-1) anim_current = anim_walking;
                                //Running Animation
                                if (abs(hsp) &gt;= 5 and abs(hsp) &lt; 9.5) anim_current = anim_running;
                                //Running Faster Animation
                                if (abs(hsp) &gt;= 9.5) anim_current = anim_faster;
                            }
                        
                    }

                //==============Attack System==============//

                //Reset attack state if we have interrupted an attack by jumping
                if (anim_current=anim_jump and attack[0] = 1) or (hurt[0] = 1) or gravity_ladder != 0
                    {
                        attack[0] = 0                   //Reset Attack State
                        attack[1] = 0                   //Increment Attack Stage
                        attack[2] = 0                   //Reset Cyclone Attack State
                        attack[3] = 0                   //Reset Cyclone Attack Timer
                        jump_override = 0               //Disable Jump Override
                    }
        
                //=======Dragon Boost Particle System=======//
                
                //Visibility timer for the dragon boost particles6
                if lilac_dragon_boost_visible&gt;-1 lilac_dragon_boost_visible-=1;
        
                //Create an orbital point above the player's feet (So that particles spawn over the center of Lilac's sprites during rotation)
                var boost_particle_x = px+lengthdir_x(24,angle_a+90)
                var boost_particle_y = py+lengthdir_y(24,angle_a+90)

                //=======Dragon Boost Tapering System=======//

                //If dragon boost tapering is enabled, send the player further up into the air
                if lilac_dragon_boost_taper = 1 and xcompass = 0
                    {
                        if spring_timer &gt; 0
                        or ground = 1
                            {
                                lilac_dragon_boost_taper = 0
                                lilac_dragon_boost_taper_mod = 0
                            }
                        //Override gravity speed
                        if lilac_dragon_boost_taper_mod != 0
                            gravity_speed = lilac_dragon_boost_taper_mod;
        
                        //Slowly taper off the gravity speed
                        lilac_dragon_boost_taper_mod += 0.2499999999
        
                        //Override current animation with the jump animation
                        if attack[0] = 0 anim_current=anim_jump;
        
                        //If the tapered gravity speed is dragging the player down,
                        //or they have touched a ceiling, stop tapering their gravity speed
                        if (lilac_dragon_boost_taper_mod &gt; 0 or tile_collision_ceiling = 1)
                            {
                                lilac_dragon_boost_taper = 0
                                lilac_draogn_boost_taper_mod = 0
                                gravity_speed = 2
                            }
                    }
                if lilac_boost_sprite = 1
                    {
                        if anim_current != anim_lilac_dragon_boost_2
                            lilac_boost_sprite = 0;
                    }
                if lilac_boost_fling_timer &gt; 0
                    {
                        lilac_boost_fling_timer -= 1
                        lilac_dragon_boost_angle = lilac_boost_fling_dir
                    }
                    
                
                //      Normal Attacks      //
                //--------------------------//
        
                if gravity_ladder = 0
                    {
                        //Check if we are attacking
                        if (joy_input[2,5] = 1 and joy_input[0,1] = 0)
                        //Check if we are dragon boosting
                        and anim_current!=anim_lilac_dragon_boost_1
                        and anim_current!=anim_lilac_dragon_boost_2
                        and anim_current!=anim_lilac_dragon_boost_r
                        and lilac_boost_cancel = 0
                            {
                                //Perform attacks on the ground, if we are not moving
                                if ((anim_current=anim_standing or anim_current = anim_idle_1) and ground=1)
                                or (anim_current=anim_wall_pushing and joy_input[0,3] = 0)
                                    {
                                        //Reset Attack State
                                        if attack[1] &gt; 1 attack[1] = 0
                                        //Alternate Between Attack Animations
                                        if attack[1] = 0 anim_current=anim_lilac_attack_1;
                                        if attack[1] = 1 anim_current=anim_lilac_attack_2;
                                        //Iterate Attack State
                                        attack[0] = 1                   //Set Attack State
                                        attack[1] += 1                  //Increment Attack Stage
                                        attack[2] = 0                   //Reset Cyclone Attack State
                                        attack[3] = 0                   //Reset Cyclone Attack Timer
                                        attack_range = 72               //Horizontal Hitbox Range
                                        attack_width = 45               //Angular Hitbox Range
                                        travel_length = 0               //Horizontal offset for Hitbox
                                        travel_height = 0               //Vertical offset for Hitbox
                                        attack_shape  = 0               //Shape of the hitbox (Elliptical)
                                        attack_offset = 8               //Attack offset
                                        //Play Voice Sample
                                        var voice_sample = random_range(0,3.9)
                                        switch(floor(voice_sample))
                                            {
                                                case 0: {scr_play_sound(lilac_attack_1,0); break;}
                                                case 1: {scr_play_sound(lilac_attack_2,0); break;}
                                                case 2: {scr_play_sound(lilac_attack_3,0); break;}
                                                case 3: {scr_play_sound(lilac_attack_4,0); break;}
                                            }
                                        //Play Lilac Whip Sound
                                        scr_play_sound(lilac_attack_whip,0)
                                    }
                                //Perform attacks in the air, or on the ground if we are moving
                                if (hsp!=0 or ground=0) and (anim_current!=anim_lilac_midair_attack)
                                and (anim_current!=anim_lilac_uppercut and anim_current!=anim_lilac_divekick)
                                //Allow us to slide across the ground with ground attacks if they were already
                                //playing, though
                                and (anim_current!=anim_lilac_attack_1 or anim_current!=anim_lilac_attack_2)
                                    {
                                        anim_current=anim_lilac_midair_attack //Attack Animation
                                        attack[0] = 1                         //Set Attack State
                                        attack[1] = 0                         //Reset Attack Stage
                                        attack[2] = 0                         //Reset Cyclone Attack State
                                        attack[3] = 0                         //Reset Cyclone Attack Timer
                                        attack_range = 72                     //Horizontal Hitbox Range
                                        attack_width = 45                     //Angular Hitbox Range
                                        travel_length = 0                     //Horizontal offset for Hitbox
                                        travel_height = 0                     //Vertical offset for Hitbox
                                        attack_shape  = 0                     //Shape of the hitbox (Elliptical)
                                        attack_offset = 8                     //Attack offset
                                        if spring_timer &gt; 0 and lilac_stamina_hop_mod &gt; 0 gravity_speed = lilac_stamina_hop_mod;
                                        //Set current frame to the current animation's beginning frame
                                        //If this is not done, the animation will not play when more
                                        //stubborn animations demand priority
                                        frame = anim_current
                                        //Play Voice Sample
                                        var voice_sample = random_range(0,3.9)
                                        switch(floor(voice_sample))
                                            {
                                                case 0: {scr_play_sound(lilac_attack_1,0); break;}
                                                case 1: {scr_play_sound(lilac_attack_2,0); break;}
                                                case 2: {scr_play_sound(lilac_attack_3,0); break;}
                                                case 3: {scr_play_sound(lilac_attack_4,0); break;}
                                            }
                                        //Play Lilac Whip Sound
                                        scr_play_sound(lilac_attack_whip,0)
                                    }
                                //Uppercut Attack
                                if (anim_current = anim_looking_up and xcompass = 0
                                //Do not execute the attack if we are dragon boosting
                                and anim_current!=anim_lilac_dragon_boost_1 and anim_current!=anim_lilac_dragon_boost_r
                                and anim_current!=anim_lilac_dragon_boost_2)
                                //Also activate if we are moving along the ground
                                or (joy_input[0,3] = 1 and hsp!=0 and gravity_speed=0 and anim_current!=anim_lilac_uppercut and above_water = 1 and xcompass = 0)
                                //Or if we are swimming
                                or (joy_input[0,3] = 1 and above_water = 0 and anim_current!=anim_lilac_uppercut and xcompass = 0)
                                //Or if we are pushing against a wall
                                or (anim_current=anim_wall_pushing and joy_input[0,3] = 1)
                                    {
                                        anim_current=anim_lilac_uppercut    //Attack Animation
                                        attack[0] = 1                       //Set Attack State
                                        attack[1] = 0                       //Reset Attack Stage
                                        attack[2] = 0                       //Reset Cyclone Attack State
                                        attack_range = 52                   //Horizontal Hitbox Range
                                        attack_width = 90                   //Angular Hitbox Range
                                        travel_length = 0                   //Horizontal offset for Hitbox
                                        travel_height = 0                   //Vertical offset for Hitbox
                                        attack_shape  = 0                   //Shape of the hitbox (Elliptical)
                                        attack_offset = 8                   //Attack offset
                                        lilac_direction_lock = xdir         //Direction of the Attack
                                        lilac_direction_lock_2 = xdir       //Direction of the Attack (Modifiable)
                                        lilac_uppercut_glitch_height = 0    //Lilac's uppercut glitch height
                                        jump_override = 1                   //Enable Jump Override
                                        gravity_speed = 0                   //Reset Gravity Speed
                                        lilac_uppercut_anim_frame = 0       //Reset Uppercut Slash's Sprite Animation Frame
                                        tile_check_wall_trigger = 0
                                        tile_check_slope_priority = 0
                                        tile_surface_wall_xcompass = 0
                                        tile_surface_ceiling_timer = 0
                                        tile_surface_ceiling_disable = 0
                                        //If we are standing still, initiate the glitch jump timer
                                        if hsp = 0 lilac_glitch_jump_timer = 8;
                                        //Play Sound
                                        var voice_sample = random_range(0,3.9)
                                        switch(floor(voice_sample))
                                            {
                                                case 0: {scr_play_sound(lilac_uppercut_0,0); break;}
                                                case 1: {scr_play_sound(lilac_uppercut_1,0); break;}
                                                case 2: {scr_play_sound(lilac_uppercut_2,0); break;}
                                            }
                                        //Play Lilac Whip Sound
                                        scr_play_sound(lilac_uppercut_4,0)
                                    }
                            }//End of Attack Check
                        
                        //Uppercut Attack's Leap
                        if (anim_current = anim_lilac_uppercut)
                            {
                                //Decrement the glitch jump timer
                                if lilac_glitch_jump_timer &gt; 0 lilac_glitch_jump_timer -= 1;
                                //If the player has pressed jump within the timing window, allow the player to perform the glitch jump
                                if lilac_glitch_jump_timer &gt; 0 and lilac_glitch_jump_timer &lt; 8 and lilac_jump_press = 1
                                    {
                                        lilac_glitch_jump = 1
                                        lilac_glitch_jump_timer = 0
                                        lilac_uppercut_glitch_height = 0
                                        //Apply uppercut glitch height
                                        if above_water = 1
                                            lilac_uppercut_glitch_height = -2;
                                        else
                                            {
                                                lilac_glitch_jump = 0
                                                lilac_glitch_jump_timer = 0
                                            }

                                    }
                                //Set rotation axis for uppercut slash's sprites
                                lilac_uppercut_x = px + lengthdir_x(64,angle_a+85)
                                lilac_uppercut_y = py + lengthdir_y(64,angle_a+85)
                                //Leap upwards during the last frames of animation
                                if (frame &gt; 149 and gravity_speed = 0 or above_water = 0) and tile_collision_ceiling = 0
                                    {
                                        //Determine the general direction of the jump by the player's X/Y coordinates
                                        var jump_length_x = lengthdir_x(gravity_jump,tile_angle+90)
                                        var jump_length_y = lengthdir_y(gravity_jump,tile_angle+90)
                                        //Determine the additional speed of the jump by another orbit
                                        var speed_length_y = lengthdir_y(hsp,tile_angle)
                                        //Apply horizontal and vertical speed to the player based on the difference
                                        hsp           = jump_length_x+hsp
                                        gravity_speed = jump_length_y+speed_length_y
                                        lilac_uppercut_gravity = gravity_speed
                                        //Override slope clipping for this one frame
                                        gravity_slope = 0
                                        lilac_glitch_jump = 0
                                    }
                                if above_water = 0 and lilac_uppercut_gravity &lt; -4
                                    {
                                        gravity_speed = -4
                                        lilac_uppercut_gravity = -4
                                    }
                                if (frame &gt; 149 and frame &lt; 151)
                                    {
                                        //Disable slope Y clipping for this frame in particular, otherwise Lilac sticks to the slope's ground
                                        if floor(frame)=149 gravity_slope=0;
                                        //Lunge forward for a few frames
                                        if (abs(hsp) &lt;= 2 and frame&gt;= 149 and frame&lt;=150)
                                        and wall_collision_left = 0 and wall_collision_right = 0
                                            hsp = 2*lilac_direction_lock;

                                        if xcompass != 0 scr_set_declip();
                                        gravity_speed = lilac_uppercut_gravity+lilac_uppercut_glitch_height
                                        lilac_uppercut_gravity += 0.24999999999999999999

                                        if joy_input[0,0] = 1 and joy_input[0,2] = 0 and hsp &lt; 5  {hsp += acc; lilac_direction_lock_2 = 1}
                                        if joy_input[0,0] = 0 and joy_input[0,2] = 1 and hsp &gt; -5 {hsp -= acc; lilac_direction_lock_2 = -1}
                                        //
                                        if joy_input[0,0] = 0 and joy_input[0,2] = 0 hsp = 2*lilac_direction_lock_2;
                                        //Apply air friction
                                        if (abs(hsp) &gt;= 5 and gravity_speed &gt; -4 and gravity_speed &lt; 0 and user_turbo_mode = 0)
                                            gravity_friction = 1;
                                        if tile_collision_ceiling = 1 {lilac_uppercut_gravity = 0; gravity_speed = 1;}

                                        //If we have touched the ceiling, override gravity speed and reset it
                                        if frame &gt; 150 and (tile_surface_id[1]!=-1)
                                        or lilac_uppercut_gravity &gt; 0 or
                                        (frame &gt; 150 and (tile_collision_ceiling = 1))
                                        or tile_collision_ceiling = 1
                                            {
                                                anim_current = anim_falling
                                                attack[0] = 0                 //Reset Attack State
                                                attack[2] = 0                 //Reset Cyclone Attack State
                                                jump_override = 0             //Disable Jump Override
                                                lilac_glitch_jump = 0         //Disable Glitch Jump
                                                gravity_speed=2
                                                lilac_uppercut_gravity = 0
                                                lilac_uppercut_glitch_height = 0
                                            }
                                        if (ground = 1) and lilac_uppercut_gravity &gt;= 0
                                            {
                                                anim_current = anim_standing
                                                attack[0] = 0                 //Reset Attack State
                                                attack[2] = 0                 //Reset Cyclone Attack State
                                                jump_override = 0             //Disable Jump Override
                                                lilac_glitch_jump = 0         //Disable Glitch Jump
                                                gravity_speed=0
                                                lilac_uppercut_gravity = 0
                                                Animations_Override = 0
                                                lilac_uppercut_glitch_height = 0
                                            }
                                    }
                                //Keep the player locked in the uppercut's facing direction
                                xdir = lilac_direction_lock
                            }
                        
                        //Crouch Attack
                        if (joy_input[2,5] = 1 and joy_input[0,1] = 1 and anim_current = anim_ducking)
                        and (anim_current!=anim_lilac_dragon_boost_1
                        and anim_current!=anim_lilac_dragon_boost_2
                        and anim_current!=anim_lilac_dragon_boost_r
                        and anim_current!=anim_lilac_crouch_attack)
                            {
                                anim_current=anim_lilac_crouch_attack //Attack Animation
                                attack[0] = 1                         //Set Attack State
                                attack[1] = 0                         //Reset Attack Stage
                                attack[2] = 0                         //Reset Cyclone Attack State
                                attack_range = 52                     //Horizontal Hitbox Range
                                attack_width = 45                     //Angular Hitbox Range
                                travel_length = 0                     //Horizontal offset for Hitbox
                                travel_height = 0                     //Vertical offset for Hitbox
                                attack_shape  = 0                     //Shape of the hitbox (Elliptical)
                                attack_offset = 8                     //Attack offset
                                //Play Sound
                                var voice_sample = random_range(0,4.9)
                                switch(floor(voice_sample))
                                    {
                                        case 0: {scr_play_sound(lilac_attack_1,0); break;}
                                        case 1: {scr_play_sound(lilac_attack_2,0); break;}
                                        case 2: {scr_play_sound(lilac_attack_3,0); break;}
                                        case 3: {scr_play_sound(lilac_attack_4,0); break;}
                                    }
                                //Play Lilac Whip Sound
                                scr_play_sound(lilac_attack_whip_3,0)
                            }
                        //Prevent the player from moving while crouching, or using the crouch attack
                        if anim_current=anim_lilac_crouch_attack hsp = 0;

                        //Perform downward spiral in the air
                        if  (joy_input[0,1] = 1 and joy_input[2,5] = 1)
                        and (gravity_speed!=0)
                        and (anim_current!=anim_lilac_uppercut
                        and  anim_current!=anim_lilac_divekick
                        and  anim_current!=anim_ladder_climbing
                        and  anim_current!=anim_lilac_dragon_boost_1
                        and  anim_current!=anim_lilac_dragon_boost_2
                        and  anim_current!=anim_lilac_dragon_boost_r)
                        //Or perform the downward spiral from a cyclone attack
                        or (anim_current=anim_lilac_midair_attack and joy_input[0,1] = 1 and joy_input[2,5] = 1)
                        //Also allow us to initiate a downward spiral from an uppercut earlier
                        or (anim_current = anim_lilac_uppercut and frame &gt; 150 and joy_input[0,1] = 1 and joy_input[2,5] = 1)
                            {
                                anim_current=anim_lilac_divekick    //Attack Animation
                                attack[0] = 1                       //Set Attack State
                                attack[2] = 0                       //Reset Cyclone Attack State
                                attack_range = 32                   //Horizontal Hitbox Range
                                attack_width = 45                   //Angular Hitbox Range
                                travel_length = 0                   //Horizontal offset for Hitbox
                                travel_height = 0                   //Vertical offset for Hitbox
                                attack_shape  = 0                   //Shape of the hitbox (Elliptical)
                                attack_offset = 0                   //Attack offset
                                spring_timer = -1                   //Disable spring animation
                                jump_override = 0                   //Disable jump override
                                lilac_uppercut_sound_check = 0      //Reset sound effect check
                                lilac_boost_cancel = 0
                                //Reset Air Drag Trigger, And Refresh Air Drag Variables (Lilac is capable of perserving horizontal speed with the divekick)
                                gravity_friction    = 0         //Player Air Speed Drag Trigger
                                drag_rate           = 0.375     //Player Air Speed Drag Rate
                                drag_reduction      = 0.0117    //Player Air Speed Drag Reduction Rate
                                drag_timer          = 0         //Reset Drag Timer
                                //Play Sound
                                var voice_sample = random_range(0,2.9)
                                switch(floor(voice_sample))
                                    {
                                        case 0: {scr_play_sound(lilac_uppercut_0,0); break;}
                                        case 1: {scr_play_sound(lilac_uppercut_1,0); break;}
                                    }
                                //Play Lilac Dropkick Sound (Part 1)
                                scr_play_sound(lilac_attack_6,0)
                            }
                        //Apply momentum
                        if (anim_current=anim_lilac_divekick)
                            {
                                if (frame &gt; 173 and frame &lt;= 178)
                                        gravity_accel = 0.125;
                                if (frame &gt; 178 and frame &lt; 179)
                                    {
                                        //Play Dropkick Sound (Part 2)
                                        if lilac_uppercut_sound_check = 0
                                            {
                                                scr_play_sound(lilac_attack_7,0)
                                                lilac_uppercut_sound_check = 1
                                                //If we are not moving quickly enough, set default horizontal speed to 5
                                                if abs(hsp) &lt; 5
                                                    {
                                                        if xdir =  1 hsp = 5;
                                                        if xdir = -1 hsp = -5;
                                                    }
                                            }
                                        //If we are not falling quickly enough, set default vertical speed to 5
                                        if lilac_divekick_speed_check = 0
                                            {
                                                if gravity_speed &gt;= 0 gravity_speed += 5;
                                                if gravity_speed &gt; 15 gravity_speed = 15;
                                                if gravity_speed &lt; 0
                                                    {
                                                        var gravity_speed_mod = abs(gravity_speed);
                                                        gravity_speed_mod -= 5
                                                        gravity_speed = abs(gravity_speed_mod)
                                                    }
                                                lilac_divekick_speed_check = 1
                                            }
                                    }
                                if frame &gt; 178 gravity_accel = 0.2499;
                            }
                        //Allow the player to cancel out of the divekick while underwater with the down key
                        if (anim_current=anim_lilac_divekick and joy_input[0,1] = 0 and above_water = 0)
                            {
                                anim_current = anim_swimming; //Swimming Animation
                                attack[0] = 0                 //Reset Attack State
                                attack[1] = 0                 //Reset Attack Stage
                                attack[2] = 0                 //Reset Cyclone Attack State
                                attack[3] = 0                 //Reset Cyclone Attack Timer
                            }
                        //Disable speedcheck if we are no longer using the divekick animation
                        if (anim_current!=anim_lilac_divekick) lilac_divekick_speed_check = 0;
                        
                        //      Special Attack      //
                        //--------------------------//

                        if  (anim_current!=anim_lilac_dragon_boost_1
                        and  anim_current!=anim_lilac_dragon_boost_2
                        and  anim_current!=anim_lilac_dragon_boost_r
                        and  lilac_boost_cancel = 0
                        and  anim_current!=anim_hurt)
                            {
                                //Check if we are pressing the jump key again in mid-air
                                if joy_input[1,2] = 1 and attack[2] = 0 attack[2] = 1;
                                if joy_input[1,2] = 0 and attack[2] = 1 attack[2] = 2;
                                //Reset confirm key if a cyclone attack was already used once
                                //(Prevents infinite cyclones via double-tapping the jump button)
                                if lilac_cyclone_refresh = 1            attack[2] = 0;

                                //If we have landed before performing the attack, reset confirm keys
                                if (ground = 1 and attack[2] &gt; 0)
                                    {
                                        attack[2] = 0 attack[3] = 0
                                    }
                                //If we have landed on a spring, and the spring reset confirm keys, modify their value
                                //so the player doesn't have to double tap the jump key to use the cyclone attack
                                if spring_timer&gt;=0 and attack[2] = 0 attack[2]=2;
                                //If we are pressing the jump key again during a jump, and not performing other attacks,
                                //perform the cyclone attack
                                if (lilac_jump_press = 1 and attack[0] = 0 and gravity_speed != 0 and anim_current != anim_lilac_cyclone
                                and anim_current != anim_hurt
                                //Also check if we have used a cyclone in mid-air previously in the same jump
                                and (lilac_cyclone_refresh = 0 and ground = 0 and lilac_hang_bar_jump=0 and above_water = 1 or attack[2] = 2))
                                //Or cancel into the cyclone attack if we were already performing a divekick
                                or  (anim_current=anim_lilac_divekick) and lilac_jump_press = 1 and lilac_cyclone_refresh = 0
                                and (frame &gt; 178 and frame &lt; 182 and stamina &gt; 1 and above_water = 1)
                                //Or perform a cycle while holding down underwater
                                or (lilac_cyclone_refresh = 0 and anim_current != anim_lilac_cyclone
                                and joy_input[0,1] = 1 and joy_input[0,3] = 0 and lilac_jump_press = 1
                                and above_water = 0 and ground = 0 and stamina &gt; 1)
                                //Oooooor perform a ground cyclone, if we were on the ground
                                or (ground=1 and joy_input[0,1] = 1 and joy_input[0,0] = 1 and joy_input[0,2] = 0 and joy_input[2,5] = 1 and anim_current != anim_lilac_cyclone and abs(hsp) &gt; 2)
                                or (ground=1 and joy_input[0,1] = 1 and joy_input[0,2] = 1 and joy_input[0,0] = 0 and joy_input[2,5] = 1 and anim_current != anim_lilac_cyclone and abs(hsp) &gt; 2)
                                    {
                                        anim_current=anim_lilac_cyclone     //Attack Animation
                                        frame = 167                         //Set Frame
                                        attack[0] = 1                       //Set Attack State
                                        attack[2] = 3                       //Set Attack State
                                        attack[3] = 64                      //Set Attack Stage
                                        attack_range = 48                   //Horizontal Hitbox Range
                                        attack_width = 180                  //Angular Hitbox Range
                                        travel_length = 0                   //Horizontal offset for Hitbox
                                        travel_height = 0                   //Vertical offset for Hitbox
                                        attack_shape  = 0                   //Shape of the hitbox (Elliptical)
                                        attack_offset = 12                  //Attack offset
                                        invuln_hud_acti = 0                 //Disable invulnerability
                                        lilac_stamina_count=stamina-19.75   //Stamina Counter
                                        lilac_stamina_drain=stamina         //Stamina Drain Timer
                                        lilac_stamina_hop_mod=2.9           //Stamina Drain Modifier
                                        lilac_boost_cancel = 0
                                        lilac_boost_cancel_stamina = 0
                                        if spring_timer=-1 gravity_speed=0; //Reset Gravity Speed
                                        //Stamina Lock
                                        //stamina_pause = 1
                                        //Modify Gravity Acceleration
                                        gravity_accel=0.100375
                                        if ground = 0 gravity_friction = 1;
                                        lilac_cyclone_decay=0.65            //Cyclone Animation Speed Decay Timer
                                        //Setup Particle Effects
                                        particle_frame_1  = 0       //Animation Frame for Particle 1
                                        particle_frame_2  = -7      //Animation Frame for Particle 2
                                        particle_frame_3  = -10     //Animation Frame for Particle 3
                                        particle_frame_4  = -14     //Animation Frame for Particle 4
                                        particle_frame_5  = -18     //Animation Frame for Particle 5
                                        particle_x_1=px+random_range(-18,18); particle_y_1=py+random_range(-24,12);
                                        particle_x_2=px+random_range(-18,18); particle_y_2=py+random_range(-24,12);
                                        particle_x_3=px+random_range(-18,18); particle_y_3=py+random_range(-24,12);
                                        particle_x_4=px+random_range(-18,18); particle_y_4=py+random_range(-24,12);
                                        particle_x_5=px+random_range(-18,18); particle_y_5=py+random_range(-24,12);
                                        //Or disable upwards leaping if we are on the ground and holding the necessary inputs
                                        if (ground=1)
                                            {
                                                lilac_cyclone_ground_check = 1
                                                lilac_stamina_hop_mod=0
                                            }
                                        //Reset vertical speed if we are in the air, and have pressed down while performing the cyclone
                                        if (ground=0 and joy_input[0,1] = 1)
                                            {
                                                lilac_stamina_hop_mod=0
                                                spring_state = 0
                                                spring_timer = -1
                                                //gravity_accel = 0.2499
                                                gravity_speed = 0
                                                gravity_friction = 0
                                            }
                                        //If stamina is less than 0, reset stamina value to 0
                                        //if lilac_stamina_count &lt; 0 lilac_stamina_count = 0;
        
                                        //Play Voice Sample
                                        var voice_sample = random_range(0,4)
                                        switch(floor(voice_sample))
                                            {
                                                case 0: {scr_play_sound(lilac_attack_cyclone_1,0); break;}
                                            }
                                        //Play Sound
                                        scr_play_sound(lilac_attack_cyclone,0)
                                    }
                            }
                    } //End of Ladder Safety Check
                //If we have landed in the water before performing the attack, reset confirm keys
                if (above_water = 0 and ground = 0)
                    {
                        attack[2] = 0 attack[3] = 0
                    }
                
                //       Dragon Boost       //
                //--------------------------//
                
                //If the stamina bar is full, and we have pressed the c key, perform a dragon boost
                if ((joy_input[1,3] = 1 or joy_input[1,4] = 1) and lilac_dragon_boost_timer = 30 and (stamina &gt;= 100))
                and (anim_current!=anim_lilac_dragon_boost_1 and anim_current!=anim_lilac_cyclone
                and anim_current!=anim_lilac_attack_1        and anim_current!=anim_lilac_attack_2
                and anim_current!=anim_lilac_crouch_attack   and anim_current!=anim_lilac_midair_attack
                and anim_current!=anim_lilac_uppercut
                and anim_current!=anim_wall_pushing)         and anim_current!=anim_lilac_dragon_boost_r
                and lilac_boost_cancel = 0
                and anim_current!=anim_lilac_dragon_boost_2 and anim_current!=anim_hurt
                and anim_current!=anim_death and anim_current!=anim_ladder_climbing
                and anim_current!=anim_hanging_idle
                    {
                        //Setting up the appearance times and randomized positions in relation to the player
                        //My wrist was not happy, I hate this block of code with a passion :^(
                        //Particle Frames
                        lilac_particle_frame[0]   = 0   lilac_particle_frame[1]   = -1  lilac_particle_frame[2]   = -2
                        lilac_particle_frame[3]   = -3  lilac_particle_frame[4]   = -4  lilac_particle_frame[5]   = -5
                        lilac_particle_frame[6]   = -6  lilac_particle_frame[7]   = -7  lilac_particle_frame[8]   = -8
                        lilac_particle_frame[9]   = -12 lilac_particle_frame[10]  = -14
                        //Particle X Positions
                        lilac_particle_x[0]   = boost_particle_x+random_range(-18,18) lilac_particle_x[1]   = boost_particle_x+random_range(-18,18)
                        lilac_particle_x[2]   = boost_particle_x+random_range(-18,18) lilac_particle_x[3]   = boost_particle_x+random_range(-18,18)
                        lilac_particle_x[4]   = boost_particle_x+random_range(-18,18) lilac_particle_x[5]   = boost_particle_x+random_range(-18,18)
                        lilac_particle_x[6]   = boost_particle_x+random_range(-18,18) lilac_particle_x[7]   = boost_particle_x+random_range(-18,18)
                        lilac_particle_x[8]   = boost_particle_x+random_range(-18,18) lilac_particle_x[9]   = boost_particle_x+random_range(-18,18)
                        lilac_particle_x[10]  = boost_particle_x+random_range(-18,18)
                        //Particle Y Positions
                        lilac_particle_y[0]   = boost_particle_y+random_range(-12,24) lilac_particle_y[1]   = boost_particle_y+random_range(-12,24)
                        lilac_particle_y[2]   = boost_particle_y+random_range(-12,24) lilac_particle_y[3]   = boost_particle_y+random_range(-12,24)
                        lilac_particle_y[4]   = boost_particle_y+random_range(-12,24) lilac_particle_y[5]   = boost_particle_y+random_range(-12,24)
                        lilac_particle_y[6]   = boost_particle_y+random_range(-12,24) lilac_particle_y[7]   = boost_particle_y+random_range(-12,24)
                        lilac_particle_y[8]   = boost_particle_y+random_range(-12,24) lilac_particle_y[9]   = boost_particle_y+random_range(-12,24)
                        //Enable dragon boost taper if we were bouncing off of a spring
                        if (spring_timer!=-1 or gravity_speed &gt; 0) and (anim_current!=anim_jump) lilac_dragon_boost_taper = 0.1;
                        lilac_particle_y[10]  = boost_particle_y+random_range(-12,24)
                        anim_current=anim_lilac_dragon_boost_1     //Attack Animation
                        attack[0] = 1                              //Set Attack State
                        attack[1] = 0                              //Reset Attack State
                        attack[2] = 0                              //Reset Attack State
                        attack[3] = 0                              //Reset Attack Stage
                        attack_range = 32                          //Horizontal Hitbox Range
                        attack_width = 360                         //Angular Hitbox Range
                        travel_length = 0                          //Horizontal offset for Hitbox
                        travel_height = 0                          //Vertical offset for Hitbox
                        attack_shape = 0                           //Shape of the hitbox (Elliptical)
                        attack_offset = 0                          //Attack offset
                        spring_timer=-1                            //Reset Spring Timer
                        gravity_speed=0                            //Reset Gravity Speed
                        lilac_cyclone_refresh = 1                  //Disable Cyclone
                        lilac_boost_cancel = 0
                        lilac_boost_cancel_stamina = 0
                        lilac_boost_launch = 0
                        lilac_boost_clip = 0
                        lilac_boost_fling_dir = 0
                        lilac_boost_fling_timer = 0
                        if joy_input[1,4] = 1
                            lilac_boost_flight_controls = 1;
                        //Play Dragon Boost Charging Sound
                        scr_play_sound(lilac_attack_boost,0)
                    }
                
                //  End of Attack Animations  //
                //----------------------------//
                
                //If we have completed the animation, end Ground Attacks
                if (anim_current=anim_lilac_attack_1 and frame &gt;= anim_lilac[anim_lilac_attack_1,1])
                or (anim_current=anim_lilac_attack_2 and frame &gt;= anim_lilac[anim_lilac_attack_2,1])
                or (anim_current=anim_lilac_midair_attack and frame &gt;= anim_lilac[anim_lilac_midair_attack,1])
                    {
                        anim_current = anim_standing; //Standing Animation
                        attack[0] = 0                 //Reset Attack State
                        attack[2] = 0                 //Reset Cyclone Attack State
                    }
                if (anim_current=anim_lilac_uppercut and frame &gt;= anim_lilac[anim_lilac_uppercut,1])
                    {
                        anim_current = anim_falling;  //Standing Animation
                        attack[0] = 0                 //Reset Attack State
                        attack[2] = 0                 //Reset Cyclone Attack State
                        jump_override = 0             //Disable Jump Override
                        lilac_glitch_jump = 0         //Disable Glitch Jump
                    }
                //If we have completed the animation, end Crouch Attack
                if (anim_current=anim_lilac_crouch_attack and frame &gt;= anim_lilac[anim_lilac_crouch_attack,1])
                    {
                        anim_current = anim_ducking; //Ducking Animation
                        attack[0] = 0                //Reset Attack State
                        attack[1] = 0                //Reset Attack Stage
                        attack[2] = 0                //Reset Cyclone Attack State
                    }
                //If we are at stage three in the cyclone attack, start a timer
                //Stamina drain timers can be found in the animation code, which is independent from the freeze frame timer
                if anim_current=anim_lilac_cyclone
                    {
                        //Check for ceiling before leaping upwards
                        if tile_collision_ceiling = 1 or joy_input[0,1] = 1 or spring_timer&gt;0 lilac_stamina_hop_mod = 0;
                        //Leap Upward If We Are Not Holding Down
                        if lilac_stamina_hop_mod &gt; 0
                            {
                                gravity_speed = -lilac_stamina_hop_mod
                                lilac_stamina_hop_mod-=0.1
                            }
                        //
                        if (ground=0 and joy_input[0,1] = 1 and attack[3] &gt; 52 and attack[3] &lt; 56)
                            {
                                lilac_stamina_hop_mod=0
                                spring_state = 0
                                spring_timer = -1
                                gravity_speed += 0.2499
                                gravity_accel = 0.2499
                            }
                        if joy_input[0,3] = 1 and gravity_speed &gt; 0
                            {
                                gravity_speed = gravity_speed*0.75
                                gravity_accel = 0.100375;
                            }
                        //If We Were Bouncing Off Of A Spring, Inherent The Player's Current Gravity Speed
                        if spring_timer&gt;0 and lilac_jump_press = 1 and (spring_rotate=45 or spring_rotate=90 or spring_rotate=135)
                            {
                                lilac_stamina_hop_mod = abs(gravity_speed)
                                spring_timer=-1
                            }
                        //Reset gravity speed if we were bouncing off a spring from the ceiling
                        if (lilac_jump_press = 1 and spring_timer&gt;0)
                        and (spring_rotate=225 or spring_rotate=270 or spring_rotate=315)
                            {
                                lilac_stamina_hop_mod = 2.9
                                spring_timer=-1
                            }
                    }
                //Reset ceiling check if the animation has ended
                else
                    {
                        lilac_cyclone_ground_check  = 0
                        stamina_pause = 0
                        lilac_stamina_hop_mod = 0
                        if not (frame &gt; 173 and frame &lt;= 178)
                            gravity_accel = 0.2499;
                    }
                //   Particle System   //
                //=====================//
                //Iterate Particle Animation Frames
                if particle_frame_1!=-128 particle_frame_1+=0.40;
                if particle_frame_2!=-128 particle_frame_2+=0.40;
                if particle_frame_3!=-128 particle_frame_3+=0.40;
                if particle_frame_4!=-128 particle_frame_4+=0.40;
                if particle_frame_5!=-128 particle_frame_5+=0.40;
                //Reset Particle Animation Frames
                if particle_frame_1&gt;7.8
                    {
                        particle_frame_1 = 0;
                        if anim_current!=anim_lilac_cyclone particle_frame_1=-128
                    }
                if particle_frame_2&gt;7.8
                    {
                        particle_frame_2 = 0;
                        if anim_current!=anim_lilac_cyclone particle_frame_2=-128;
                    }
                if particle_frame_3&gt;7.8
                    {
                        particle_frame_3 = 0;
                        if anim_current!=anim_lilac_cyclone particle_frame_3=-128
                    }
                if particle_frame_4&gt;7.8
                    {
                        particle_frame_4 = 0;
                        if anim_current!=anim_lilac_cyclone particle_frame_4=-128;
                    }
                if particle_frame_5&gt;7.8
                    {
                        particle_frame_5 = 0;
                        if anim_current!=anim_lilac_cyclone particle_frame_5=-128;
                    }
                //Reset Particle Animation X/Y
                if floor(particle_frame_1=0) {particle_x_1=px+random_range(-18,18); particle_y_1=py-32+random_range(-12,24);}
                if floor(particle_frame_2=0) {particle_x_2=px+random_range(-18,18); particle_y_2=py-32+random_range(-12,24);}
                if floor(particle_frame_3=0) {particle_x_3=px+random_range(-18,18); particle_y_3=py-32+random_range(-12,24);}
                if floor(particle_frame_4=0) {particle_x_4=px+random_range(-18,18); particle_y_4=py-32+random_range(-12,24);}
                if floor(particle_frame_5=0) {particle_x_5=px+random_range(-18,18); particle_y_5=py-32+random_range(-12,24);}
                //If we have landed while looping through the cyclone attack or downward kick, or took damage, end either of those animations
                if (ground=1) and (anim_current=anim_lilac_divekick or (anim_current=anim_lilac_cyclone and lilac_cyclone_ground_check = 0))
                    {
                        anim_current = anim_standing; //Standing Animation
                        attack[0] = 0                 //Reset Attack State
                        attack[1] = 0                 //Reset Attack Stage
                        attack[2] = 0                 //Reset Cyclone Attack State
                        attack[3] = 0                 //Reset Cyclone Attack Timer
                    }
    
                //Dragon Boost Particle System
                if lilac_particle_frame[10]!=-128
                    {
                        //     Particle Animations     //
                        //=============================//
                        var lilac_count = 0;
                        while(lilac_count &lt; 10)
                            {
                                if lilac_particle_frame[lilac_count]!=-128
                                    {
                                        lilac_particle_frame[lilac_count]+=0.40
                                        lilac_particle_y[lilac_count]-=1
                                    }
                                if lilac_particle_frame[lilac_count]&gt;7.8
                                    {
                                        lilac_particle_frame[lilac_count] = 0
                                        lilac_particle_x[lilac_count] = boost_particle_x+random_range(-18,18)
                                        lilac_particle_y[lilac_count] = boost_particle_y+random_range(-12,24)
                                        if lilac_dragon_boost_visible=-1 lilac_particle_frame[lilac_count]=-128;
                                    }
                                lilac_count += 1
                            }
                    }
            }//End of Freeze Frame Check

        //Allow animation system to play during freeze-frames
        if pause = 0 and user_cursor_mode = 0
            {
                //          Animation System Core          //
                //=========================================//
        
                //Make sure we aren't dead, before allowing normal animations
                if death[0] = 0 and not (targets_ready = 3 and ground = 1)
                    {
                        if gravity_rail_check = 1 and attack[0] = 0
                            {
                                anim_current = anim_lilac_rail_grinding;
                                if above_water = 0 and ground = 0
                                    {
                                        anim_current = anim_swimming
                                        scr_set_rail_grinding_stop()
                                    }
                            }
                        //Perpetually advance frames based on provided speed,
                        //if we are not using aerial attacks
                        if  anim_current!=anim_lilac_midair_attack
                        and anim_current!=anim_lilac_cyclone
                        and anim_current!=anim_ladder_climbing
                        and anim_current!=anim_swimming
                        and anim_current!=anim_spring
                        and anim_current!=anim_faster
                        and anim_current!=anim_walking
                        and anim_current!=anim_lilac_uppercut
                        and anim_current!=anim_lilac_dragon_boost_c
                            frame += anim_lilac[anim_current,3]
                        //If a new animation has started, initialize the new animation
                        if anim_previous!=anim_current
                            {
                                frame = anim_lilac[anim_current,0]  //Set starting frame of animation
                                anim_previous=anim_current          //Disable triggered breakpoint
                            }
                
                        //============Hair Sprites============//
                        
                        //Advance hair frames based on provided speed
                        if anim_current=anim_hanging_idle
                            {
                                tail_frame += 0.12
                                //Reset Hair Animations After They Have Completed
                                if tail_frame &gt; 14.8 tail_frame = 3;
                            }
                        //Use Clear Frame For Animations That Don't Need The Hair
                        //(Prevents Needing More Specific Questions In The Draw Event)
                        else tail_frame = 15;
                        
                        //============Attack Sprites============//
                        
                        //Advance attack frames based on provided speed
                        if action_confirm=1
                            {
                                action_frame += anim_lilac[anim_current,3]+0.167
                                //Set rotation axis for attack sprites
                                action_offset_x = px + lengthdir_x(action_distance,angle_a+90)
                                action_offset_y = py + lengthdir_y(action_distance,angle_a+90)
                        
                                //Modifications of attack sprite based on current
                                //attack can be found in Animation Overrides
                        
                                //Reset Attack Animations After They Have Completed
                                if spr_action=spr_attack_0 and action_frame &gt; 5.9
                                or spr_action=spr_attack_1 and action_frame &gt; 3.9
                                    {
                                        action_frame   = 0;
                                        action_confirm = 0;
                                    }
                            }
                        else action_frame = 0
                        
                            //============Speed Modifiers============//
                        
                            //If we are using an aerial attack, increase animation
                            //speed based on movement speed
                            if anim_current=anim_lilac_midair_attack
                                frame += anim_lilac[anim_lilac_midair_attack,3]+abs(hsp/64)
                            //If we are using the cyclone attack, increase animation
                            //speed based on a timer
                            if anim_current=anim_lilac_cyclone
                                {
                                    frame += lilac_cyclone_decay*1.67 //attack[3]/56
                                    //Decrement cyclone decay timer
                                    if lilac_cyclone_decay &gt; 0.28 lilac_cyclone_decay -= 0.025;
                                }
                            //If we are bouncing on a spring, increase animation
                            //speed based on a timer
                            if anim_current=anim_spring
                                {
                                    frame += spring_anim_mod*1.67
                                    //Decrement animation modifier
                                    if spring_anim_mod &gt; 0.16 spring_anim_mod -= 0.025;
                                    //End springing animation if it hasn't already
                                    if spring_timer=-1 anim_current=anim_falling;
                                }
                            //If we are running, increase animation speed based on horizontal speed
                            if anim_current=anim_faster or anim_current=anim_walking
                                frame += anim_lilac[anim_current,3]+abs(hsp)/56;

                            if anim_current = anim_lilac_uppercut
                                {
                                    //Iterate uppercut slash's sprite animations
                                    if frame &gt;= 147 and frame &lt; 149 frame += 0.35;
                                    if frame &gt;= 149 frame += 0.167;
                                }
                        
                                //============Special Actions============//
                        
                                //Key Release for Wall Pushing Animation
                                if (anim_current=anim_wall_pushing and hsp!=0 and ground=1)
                                or (anim_current=anim_wall_pushing and joy_input[0,0] = 0 and joy_input[0,2] = 0 and ground=1)
                                or (anim_current=anim_wall_pushing and ground=0)
                                    anim_current=anim_standing;
                                //If we are on a ladder, animations should play forwards or in reverse based on input
                                //Enforce ladder climbing state, if we are in the cyclone state
                                if ladder_state = 0
                                    {
                                        if gravity_ladder = 1 and attack[2] &gt; 0 anim_current=anim_ladder_climbing;
                                        if anim_current=anim_ladder_climbing
                                            {
                                                //Keep Lilac's Attack And Cyclone States Empty
                                                attack[0] = 0; attack[1] = 0; attack[2] = 0; attack[3] = 0;
                                                //Climbing up
                                                if joy_input[0,3] = 1 and joy_input[0,1] = 0 frame += anim_lilac[anim_current,3];
                                                //Climbing Down
                                                if joy_input[0,3] = 0 and joy_input[0,1] = 1
                                                    {
                                                        frame -= anim_lilac[anim_current,3]
                                                        //If we are playing frames below the current animation, restart animation loop from
                                                        //its endpoint instead
                                                        if frame &lt; anim_lilac[anim_current,0]+0.40 frame = anim_lilac[anim_current,1];
                                                    }
                                            }
                                    }
        
                                //Idle Animation
                                if anim_current = anim_standing
                                    {
                                        //Iterate idle timer
                                        anim_idle_timer += 1
        
                                        //If the timer has reached its limit, start the idle animation
                                        if anim_idle_timer = 530
                                            {
                                                anim_current = anim_idle_1
                                                frame = anim_lilac[anim_idle_1,0]
                                            }
                                        //If the timer has exceeded its limit, reset the timer
                                        if anim_idle_timer &gt; 530 anim_idle_timer = 0;
                                    }
                                //If we have moved or attacked at all, reset iteration timer
                                if hsp!=0 or gravity_speed!=0 or attack[0]!=0 anim_idle_timer = 0;
                                //If we have reached the end of the animation, reset idle timer and return to the standing animation
                                if anim_current = anim_idle_1 and frame &gt; anim_lilac[anim_idle_1,2]+0.8
                                    {
                                        anim_idle_timer = 0
                                        anim_current = anim_standing
                                    }

                                //   Stamina drain timer for the cyclone   //
                                //-----------------------------------------//

                                if anim_current=anim_lilac_cyclone
                                    {
                                        //Increment Cyclone Attack Stage
                                        attack[3] -= 1
                                        //Drain Stamina
                                        //if user_turbo_mode = 0 stamina-=0.25;
                                        //if stamina &lt; 0 stamina = 0;
                                        //Decrement Stamina From Stamina Bar
                                        lilac_stamina_drain-=0.25
                                        //Iterate Cyclone Animations
                                        lilac_cyclone_sprite_frame += lilac_cyclone_decay
                                        //Reset Cyclone Animations After They Have Completed
                                        if lilac_cyclone_sprite_frame &gt; 5.8 lilac_cyclone_sprite_frame = 0;
                                        //Set rotation axis for cyclone sprites
                                        lilac_cyclone_x = px + lengthdir_x(32,angle_a+90)
                                        lilac_cyclone_y = py + lengthdir_y(32,angle_a+90)
                                        //End Cyclone When 20 Stamina Is Spent, Or the Stamina Bar Is Empty
                                        if lilac_stamina_drain&lt;=lilac_stamina_count
                                            {
                                                if ground = 1 anim_current = anim_standing;   //Standing Animation
                                                if ground = 0 anim_current = anim_falling;    //Falling Animation
                                                attack[0] = 0                   //Reset Attack State
                                                attack[1] = 0                   //Reset Attack Stage
                                                attack[2] = 0                   //Reset Cyclone Attack State
                                                attack[3] = 0                   //Reset Cyclone Attack Timer
                                                lilac_cyclone_ground_check  = 0 //Reset Cyclone Ground Check
                                                lilac_stamina_drain         = 0 //Reset Cyclone Stamina Drain
                                                lilac_stamina_count         = 0 //Reset Cyclone Stamina Counter
                                                jump_lock                   = 0 //Reset Jump Lock
                                                joy_input[2,4]              = 0 //Reset Jump Button Lock
                                            }
                                    }

                                //      Initial phases of the dragon boost      //
                                //----------------------------------------------//

                                //The rolling phase of the dragon boost needs to be independent of the freeze frame timer,
                                //otherwise the rolling phase would never end until the enemy died :^P
                    
                                //Keep gravity reset during the first phase of the dragon boost attack
                                if anim_current=anim_lilac_dragon_boost_1 or anim_current=anim_lilac_dragon_boost_r
                                    {
                                        //If we are not on the ground, lock all horizontal and vertical speed
                                        if ground = 0 {gravity_speed=0; hsp=0; spring_timer=-1;}
                                        //Decrement timer
                                        lilac_dragon_boost_timer-=1
                                        //Disable the dragon boost if we have rolled into a sideways spring
                                        if ground=1 and spring_timer&gt;0
                                            {
                                                anim_current=anim_walking
                                                invuln_hud_acti = 0
                                            }
                                        //Set Dragon Boost Particle Timer
                                        lilac_dragon_boost_visible=15
                                        //Set Invulnerability
                                        invuln_hud_acti = 1
                                        //Allow player to make extreme arbitrary
                                        //changes of direction
                                        if joy_input[0,0] = 1 and joy_input[0,2] = 0 lilac_dragon_boost_dir=1;
                                        if joy_input[0,0] = 0 and joy_input[0,2] = 1 lilac_dragon_boost_dir=-1;
                                        //If no input is provided, change desired direction to facing direction
                                        if joy_input[0,0] = 0 and joy_input[0,2] = 0 lilac_dragon_boost_dir=xdir;
                                        //If we are rolling, animate the tail sprites
                                        if anim_current=anim_lilac_dragon_boost_r
                                            {
                                                lilac_tail_frame+=0.30
                                                if lilac_tail_frame&gt;3.8 lilac_tail_frame=0;
                                            }
                                        //If we are on the ground, pan the camera backwards in anticipation
                                        if lilac_dragon_boost_dir = 1 and ground = 1 and view_offset &gt;-65 view_offset-=2.5;
                                        if lilac_dragon_boost_dir =-1 and ground = 1 and view_offset &lt; 65 view_offset+=2.5;
                                        if gravity_rail_check = 1
                                            scr_set_rail_grinding_stop();
                                    }
                                //If the first phase of the dragon boost has ended, start rolling
                                if anim_current=anim_lilac_dragon_boost_1 and frame &gt;= anim_lilac[anim_lilac_dragon_boost_1,1]
                                    anim_current=anim_lilac_dragon_boost_r;
                                //If we have completed the first phase of the dragon boost attack, initiate the second phase
                                if anim_current=anim_lilac_dragon_boost_r and lilac_dragon_boost_timer&lt;=0
                                    {
                                        anim_current=anim_lilac_dragon_boost_2     //Attack Animation
                                        gravity_speed=0                            //Reset Gravity Speed
                                        spring_timer=-1                            //Reset Spring Timer
                                        lilac_dragon_boost_timer=30                //Reset Dragon Boost Timer
                                        //Play Dragon Boost Sound 
                                        scr_play_sound(lilac_dragon_boost,0)
                                    }

                                //      Active phases of the dragon boost      //
                                //---------------------------------------------//

                                //strap the phone to ur face, shout "dargon boot" and jump out the nearest window -scootles
                                if anim_current=anim_lilac_dragon_boost_2 and pause_logic = 0
                                    {
                                        //   Lock Dragon Boost Angle   //
                                        //=============================//
                                        //Set Dragon Boost Particle Timer
                                        lilac_dragon_boost_visible=15
                                        lilac_dragon_boost_lock += 1
                                        //Boost Cancel Pressed Inputs
                                        if joy_input[1,3] = 1
                                            lilac_boost_cancel += 1;
                                        else
                                            lilac_boost_cancel = 0;
                                        //Determine our dragon boost angle
                                        if lilac_dragon_boost_lock = 1
                                            {
                                                //===Thoroughly examine player inputs for directions to aim in===//
                                                
                                                //-----Facing Right-----//
                                                //----------------------//
                        
                                                //Direction: Up-Right ^&gt;
                                                if (joy_input[0,2] = 0 and joy_input[0,0] = 1 and joy_input[0,3] = 1 and joy_input[0,1] = 0)
                                                or (joy_input[0,2] = 0 and joy_input[0,0] = 0 and joy_input[0,3] = 1 and joy_input[0,1] = 0 and xdir=1)
                                                    {
                                                        lilac_dragon_boost_angle = 45
                                                        xdir=1
                                                        lilac_boost_sprite = 1
                                                        if xcompass != 0
                                                            {
                                                                lilac_dragon_boost_angle = tile_angle
                                                            }
                                                        else
                                                            {
                                                                //Trigger Dragon Boost Tapering If We Are Dragon Boosting From The Ground
                                                                if (ground = 1 or py &gt; water_height+128) lilac_dragon_boost_taper = 0.1;
                                                                //Disable Floor Collisions For This One Frame
                                                                gravty_slope=0
                                                            }
                                                    }
                                                //Direction: Right &gt;
                                                if (joy_input[0,2] = 0 and joy_input[0,0] = 1 and joy_input[0,3] = 0 and joy_input[0,1] = 0)
                                                or (joy_input[0,2] = 0 and joy_input[0,0] = 0 and joy_input[0,3] = 0 and joy_input[0,1] = 0 and xdir=1)
                                                or (ground = 1 and xdir = 1 and joy_input[0,3] = 0)
                                                    {
                                                        lilac_dragon_boost_angle = 0
                                                        xdir=1
                                                        lilac_dragon_boost_taper = 0
                                                        lilac_boost_sprite = 1
                                                        if ground = 1
                                                            {
                                                                lilac_dragon_boost_angle = tile_angle
                                                            }
                                                    }
                                                //Direction: Down-Right v&gt;
                                                if (joy_input[0,2] = 0 and joy_input[0,0] = 1 and joy_input[0,3] = 0 and joy_input[0,1] = 1)
                                                or (joy_input[0,2] = 0 and joy_input[0,0] = 0 and joy_input[0,3] = 0 and joy_input[0,1] = 1 and xdir=1 and ground = 0)
                                                    {
                                                        lilac_dragon_boost_angle = 325
                                                        xdir=1
                                                        lilac_dragon_boost_taper = 0
                                                        lilac_boost_sprite = 1
                                                        //Check if we should boost downwards instead
                                                        if ground = 1
                                                            {
                                                                lilac_dragon_boost_angle = tile_angle
                                                                xdir=1
                                                                lilac_dragon_boost_taper = 0
                                                                lilac_boost_sprite = 1
                                                            }
                                                    }

                                                //-----Facing Left-----//
                                                //---------------------//

                                                //Direction: Up-Left &lt;^
                                                if (joy_input[0,2] = 1 and joy_input[0,0] = 0 and joy_input[0,3] = 1 and joy_input[0,1] = 0)
                                                or (joy_input[0,2] = 0 and joy_input[0,0] = 0 and joy_input[0,3] = 1 and joy_input[0,1] = 0 and xdir=-1)
                                                    {
                                                        lilac_dragon_boost_angle = 135
                                                        xdir=-1
                                                        lilac_boost_sprite = 1
                                                        //if (ground = 0 and py &lt;= water_height+128) lilac_dragon_boost_taper = 0;
                                                        //Check if we should boost downwards instead
                                                        if xcompass != 0
                                                            {
                                                                lilac_dragon_boost_angle = tile_angle
                                                            }
                                                        else
                                                            {
                                                                //Trigger Dragon Boost Tapering If We Are Dragon Boosting From The Ground
                                                                if (ground = 1 or py &gt; water_height+128) lilac_dragon_boost_taper = 0.1;
                                                                //Disable Floor Collisions For This One Frame
                                                                gravty_slope=0
                                                            }
                                                    }
                                                //Direction: Left &lt;
                                                if (joy_input[0,2] = 1 and joy_input[0,0] = 0 and joy_input[0,3] = 0 and joy_input[0,1] = 0)
                                                or (joy_input[0,2] = 0 and joy_input[0,0] = 0 and joy_input[0,3] = 0 and joy_input[0,1] = 0 and xdir=-1)
                                                or (ground = 1 and xdir = -1 and joy_input[0,3] = 0)
                                                    {
                                                        lilac_dragon_boost_angle = 0
                                                        xdir=-1
                                                        lilac_dragon_boost_taper = 0
                                                        lilac_boost_sprite = 1
                                                        if ground = 1
                                                            {
                                                                lilac_dragon_boost_angle = tile_angle
                                                            }
                                                    }
                                                //Direction: Down-Left &lt;v
                                                if (joy_input[0,2] = 1 and joy_input[0,0] = 0 and joy_input[0,3] = 0 and joy_input[0,1] = 1)
                                                or (joy_input[0,2] = 0 and joy_input[0,0] = 0 and joy_input[0,3] = 0 and joy_input[0,1] = 1 and xdir=-1 and ground = 0)
                                                    {
                                                        lilac_dragon_boost_angle = 225
                                                        xdir=-1
                                                        lilac_dragon_boost_taper = 0
                                                        lilac_boost_sprite = 1
                                                        //Check if we should boost downwards instead
                                                        if ground = 1
                                                            {
                                                                lilac_dragon_boost_angle = tile_angle
                                                                xdir=-1
                                                                lilac_dragon_boost_taper = 0
                                                                lilac_boost_sprite = 1
                                                            }
                                                    }
                                                //Override all forms of input if we're launching from a slope first
                                                if lilac_boost_launch = 1
                                                    {
                                                        lilac_dragon_boost_angle = 90
                                                        lilac_boost_sprite = 1
                                                        //Disable Floor Collisions For This One Frame
                                                        gravity_slope=0
                                                        //Trigger Dragon Boost Tapering If We Are Dragon Boosting From The Ground
                                                        if (ground = 1 or py &gt; water_height+128) lilac_dragon_boost_taper = 0.1;
                                                        //if (ground = 0 and py &lt;= water_height+128) lilac_dragon_boost_taper = 0;
                                                    }
                                            }
                
                                        //  Dragon Walls Interactions  //
                                        //=============================//
                        
                                        var bounce_sound_yet = 0;
                                        //Downward-Right (v&gt;)
                                        if (wall_collision_right = 1 or tile_wall_trigger = 1) and (lilac_dragon_boost_angle &gt; 270 and lilac_dragon_boost_angle &lt; 360) {lilac_dragon_boost_angle=225; lilac_boost_dir = -1; bounce_sound_yet = 1;}
                                        //Upward-Right (^&gt;)
                                        if (wall_collision_right = 1 or tile_wall_trigger = 1) and (lilac_dragon_boost_angle &gt; 0 and lilac_dragon_boost_angle &lt; 90)  {lilac_dragon_boost_angle=135; lilac_boost_dir = -1; bounce_sound_yet = 1;}
                                        //Downward-Left (v&lt;)
                                        if (wall_collision_left = 1 or tile_wall_trigger_l = 1) and (lilac_dragon_boost_angle &gt; 180 and lilac_dragon_boost_angle &lt; 270) {lilac_dragon_boost_angle=325; lilac_boost_dir = 1; bounce_sound_yet = 1;}
                                        //Upward-Left (^&lt;)
                                        if (wall_collision_left = 1 or tile_wall_trigger_l = 1) and (lilac_dragon_boost_angle &gt; 90 and lilac_dragon_boost_angle &lt; 180) {lilac_dragon_boost_angle=45; lilac_boost_dir = 1; bounce_sound_yet = 1;}
                                        //Ceiling-Left
                                        if (lilac_boost_dir = -1 and tile_collision_ceiling = 1) {lilac_dragon_boost_angle=225 lilac_boost_dir = -1; tile_collision_ceiling = 0; bounce_sound_yet = 1;}
                                        //Ceiling-Right
                                        if (lilac_boost_dir = 1 and tile_collision_ceiling = 1)  {lilac_dragon_boost_angle=325 lilac_boost_dir = 1; tile_collision_ceiling = 0; bounce_sound_yet = 1;}
                                        //Ceiling-Up
                                        var lilac_boost_stop = 0;
                                        if (tile_collision_ceiling = 1 and lilac_dragon_boost_angle &gt; 70 and lilac_dragon_boost_angle &lt; 110)
                                            {
                                                lilac_boost_stop = 1;
                                            }
                
                                        //Disable dragon boost if sloped walls' angles were too shallow
                                        if (gravity_slope = 1 and ((tile_angle &gt; 0 and tile_angle &lt; 45) or (tile_angle &gt; 315)))
                                            {
                                                //lilac_dragon_boost_angle = tile_angle
                                                bounce_sound_yet = 0
                                            }
                                        //Play Sound
                                        if bounce_sound_yet = 1 scr_play_sound(lilac_dragon_boost_bounce,0);
                                        //Left Or Right (v&gt;)
                                        if ((wall_collision_right = 1 or tile_wall_trigger = 1) and (lilac_dragon_boost_angle=0 or ground = 1))
                                        or ((wall_collision_left  = 1 or tile_wall_trigger_l = 1) and (lilac_dragon_boost_angle=180 or ground = 1))
                                        //Dragon Boost Cancel
                                        or (lilac_dragon_boost_lock &gt; 2 and lilac_boost_cancel = 1 and ground = 0)
                                            {
                                                anim_current=anim_falling
                                                lilac_dragon_boost_lock  = 0
                                                if lilac_dragon_boost_angle = 0
                                                or lilac_dragon_boost_angle=325
                                                or lilac_dragon_boost_angle=45
                                                    {
                                                        fling_hsp = -5
                                                        hsp=fling_hsp
                                                        fling_timer=4
                                                        fling_vsp = -3
                                                        gravity_speed=fling_vsp
                                                        fling_ver_timer=4
                                                        anim_current=anim_jump
                                                        stamina = 0
                                                        lilac_dragon_boost_angle = 0
                                                    }
                                                if lilac_dragon_boost_angle=180
                                                or lilac_dragon_boost_angle=225
                                                or lilac_dragon_boost_angle=135
                                                    {
                                                        fling_hsp = 5
                                                        hsp=fling_hsp
                                                        fling_timer=4
                                                        fling_vsp = -3
                                                        gravity_speed=fling_vsp
                                                        fling_ver_timer=4
                                                        anim_current=anim_jump
                                                        stamina = 0
                                                        lilac_dragon_boost_angle = 180
                                                    }
                                                if (lilac_dragon_boost_lock &gt; 2 and lilac_boost_cancel = 1 and ground = 0)
                                                    {
                                                        fling_hsp = 5
                                                        hsp=fling_hsp
                                                        fling_timer=4
                                                        fling_vsp = -2
                                                        gravity_speed=fling_vsp
                                                        fling_ver_timer=4
                                                        frame = 83
                                                        hurt_invuln = 39
                                                        scr_set_lilac_clear_boost_cancel()
                                                        anim_current=anim_lilac_dragon_boost_c
                                                    }
                                                else
                                                    {
                                                        hurt_invuln = 0
                                                        lilac_dragon_boost_taper = 1
                                                        lilac_dragon_boost_taper_mod = -8
                                                    }
                                                lilac_dragon_boost_angle = 0
                                                lilac_dragon_boost_timer = 30
                                                invuln_hud_acti = 0
                                                lilac_boost_sprite = 0
                                                lilac_boost_launch = 0
                                                attack[0] = 0                 //Reset Attack State
                                                attack[1] = 0                 //Reset Attack Stage
                                                attack[2] = 0                 //Reset Cyclone Attack State
                                                attack[3] = 0                 //Reset Cyclone Attack Timer
                                                lilac_cyclone_refresh = 0
                                                scr_play_sound(lilac_dragon_boost_bounce,0);
                                                scr_play_sound(lilac_dragon_boost_explosion,0);
                                            }

                                        //     Dragon Boost Action     //
                                        //=============================//
                                        if lilac_dragon_boost_lock &gt;= 1
                                            {
                                                //Angle Corrections, Should Environmental Gimmicks Modify Dragon-Boosting Angle Too Dramatically
                                                if lilac_dragon_boost_angle &gt; 360
                                                    lilac_dragon_boost_angle = 0;
                                                if lilac_dragon_boost_angle &lt; 0
                                                    lilac_dragon_boost_angle = 360;
                                                //Maintain 90 degree angle direction if she's dragon boosting from a launcher point on a slope
                                                if lilac_boost_launch = 1
                                                    lilac_dragon_boost_angle = 90;
                                                //Disable Dragon Boost Tapering If Our Angle Falls Below A Certain Range
                                                if lilac_dragon_boost_angle &gt; 135 or lilac_dragon_boost_angle &lt; 45
                                                or ground = 1
                                                    {
                                                        lilac_dragon_boost_taper = 0;
                                                        lilac_dragon_boost_taper_mod = 0;
                                                    }
                                                //Assume Dragon Boosting Speed Is 8 By Default (For Diagonal Dragon Boosting!)
                                                lilac_boost_speed = 8
                                                //Change Lilac's Dragon Boosting Speed Based On Angle
                                                if (lilac_dragon_boost_angle &lt;= 45 or lilac_dragon_boost_angle &gt;= 325)
                                                or (lilac_dragon_boost_angle &gt;= 135 and lilac_dragon_boost_angle &lt;= 225)
                                                    lilac_boost_speed = 12;
                                                //Change Sprite's Facing Direction Based on Angle
                                                if ground = 0
                                                    {
                                                        if lilac_dragon_boost_angle &gt; 90 and lilac_dragon_boost_angle &lt; 270 lilac_boost_dir = -1; //Facing Left
                                                        if lilac_dragon_boost_angle &lt;= 90 or lilac_dragon_boost_angle &gt;= 270 lilac_boost_dir = 1; //Facing Right
                                                        //If we have left a sloped surface while dragon boosting towards the left, correct the dragon boost's angle
                                                        if xdir = -1 and lilac_dragon_boost_angle = 0
                                                            lilac_dragon_boost_angle = 180;
                                                    }

                                                //Aerial Controls (Via Special 2)
                                                if joy_input[1,4] = 1
                                                    lilac_boost_flight_controls = 1;
                                                if lilac_boost_flight_controls = 1
                                                    {
                                                        if xdir = 1
                                                            {
                                                                if (joy_input[0,3] = 1) lilac_dragon_boost_angle += 1.4;
                                                                if (joy_input[0,1] = 1) lilac_dragon_boost_angle -= 1.4;
                                                            }
                                                        if xdir = -1
                                                            {
                                                                if (joy_input[0,1] = 1) lilac_dragon_boost_angle += 1.4;
                                                                if (joy_input[0,3] = 1) lilac_dragon_boost_angle -= 1.4;
                                                            }
                                                    }

                                                //Apply Speed If We Are Not On The Ground
                                                if tile_wall_trigger = 0 and tile_wall_trigger_l = 0
                                                    {
                                                        if ground = 0
                                                            {
                                                                hsp = lengthdir_x(lilac_boost_speed,lilac_dragon_boost_angle);
                                                                if gravity_launch &gt; 0 and lilac_boost_clip = 0
                                                                    {
                                                                        px += 15*-xdir
                                                                        //px -= 12
                                                                        lilac_boost_clip = 1
                                                                    }
                                                            }
                                                        else
                                                            {
                                                                hsp = 12*xdir;
                                                                if gravity_slope = 1
                                                                    lilac_dragon_boost_angle = tile_angle;
                                                            }
                                                    }

                                                if (joy_input[1,4] = 0 and ground = 1 and lilac_dragon_boost_lock = 1 and xcompass != 180
                                                and gravity_slope = 1)
                                                or (joy_input[1,4] = 0 and gravity_slope = 0
                                                and ground = 1 and xcompass = 0 and lilac_dragon_boost_lock = 1)
                                                    {
                                                        if joy_input[0,3] = 1
                                                            {
                                                                switch(xcompass)
                                                                    {
                                                                        case 0:   {py -= 4; break;}
                                                                        case 90:  {px -= 4; break;}
                                                                        case 270: {px += 4; break;}
                                                                    }
                                                                if (joy_input[0,2] = 0 and joy_input[0,0] = 1)
                                                                or (joy_input[0,2] = 0 and joy_input[0,0] = 0 and xdir = 1)
                                                                    {
                                                                        switch(xcompass)
                                                                            {
                                                                                case 0:   {lilac_dragon_boost_angle = 45;  break;}
                                                                                case 90:  {lilac_dragon_boost_angle = 135; break;}
                                                                                case 270: {lilac_dragon_boost_angle = 45;  break;}
                                                                            }
                                                                    }
                                                                if (joy_input[0,2] = 1 and joy_input[0,0] = 0)
                                                                or (joy_input[0,2] = 0 and joy_input[0,0] = 0 and xdir = -1)
                                                                    {
                                                                        switch(xcompass)
                                                                            {
                                                                                case 0:   {lilac_dragon_boost_angle = 135; break;}
                                                                                case 90:  {lilac_dragon_boost_angle = 135; break;}
                                                                                case 270: {lilac_dragon_boost_angle = 45;  break;}
                                                                            }
                                                                    }
                                                                xcompass = 0
                                                                tile_surface_wall_xcompass = 0
                                                                tile_check_slope_priority = 0
                                                                gravity_slope = 0
                                                            }
                                                    }

                                                if (tile_collision_ceiling = 0 and ground = 0)
                                                    gravity_speed = lengthdir_y(lilac_boost_speed,lilac_dragon_boost_angle);
                                                //Dragon Boost Particle Visibility
                                                lilac_dragon_boost_visible=15
                                                //Disable dragon boost tapering if the dragon boost is facing a downward direction
                                                if gravity_speed &gt; 0 lilac_dragon_boost_taper = 0;
                                            }
                
                                        //   Stamina drain timer for the dragon boost   //
                                        //----------------------------------------------//
                
                                        //Decrement the stamina bar
                                        stamina -= 3
                                        //Set Invulnerability
                                        hurt_invuln = 0
                                        //End the dragon boost once the stamina bar is empty
                                        if stamina &lt;= 0 or spring_timer &gt; 0 or fling_timer &gt; 0
                                        or gravity_ladder &gt; 0
                                        or lilac_boost_stop = 1
                                            {
                                                scr_set_lilac_clear_dragon_boost();
                                            }

                                        //Animate secondary sprites
                                        lilac_boost_frame += 0.75
                                        if lilac_boost_frame &gt; 4.8
                                            lilac_boost_frame = 0;
                                    }

                        //If we are above the ending frame, restart the animation at the desired loop point
                        if frame &gt; anim_lilac[anim_current,1]+0.8 frame = anim_lilac[anim_current,2];
                    }

                //===========Death Animation===========//
        
                //If we have died, override normal animations
                if death[0] = 1
                    {
                        //Disable FOF collisions
                        tile_surface_id[5] = 0
                        tile_surface_asset = 0
                        //Stay on this frame of animation while we are not touching the ground
                        if ground = 0 frame = anim_lilac[anim_death,0];
                        //Complete the animation once we are
                        if (ground = 1)
                            {
                                if frame &lt; anim_lilac[anim_death,0] frame = anim_lilac[anim_death,0];
                                if frame &lt; anim_lilac[anim_death,1] frame += anim_lilac[anim_current,3];
                            }
                    }

                //==========Victory Animation==========//

                //If we have landed after breaking all the targets, trigger the victory animation
                if targets_ready = 3 and ground = 1
                    {
                        //Set the current animation frame to the beginning of the animation, if it wasn't before
                        if frame &lt; anim_lilac[anim_victory,0] frame = anim_lilac[anim_victory,0];
                        //Play the animation to the end
                        if frame &lt; anim_lilac[anim_victory,1] frame += anim_lilac[anim_victory,3];
                    }

                //Block-Pushing Animations
                if xcompass = 0 and ground = 1 and attack[0]=0 and gravity_rail_check = 0
                    scr_set_block_pushing();

                //If we are swimming, accelerate animation speeds
                //based on the player's movement speed
                if above_water = 0
                    {
                        if gravity_rail_check = 0 and anim_current = anim_lilac_rail_grinding
                            {
                                if hsp = 0 anim_current = anim_standing;
                                else       anim_current = anim_walking;
                                scr_set_rail_grinding_stop();
                            }
                        var sink_yes = 0;
                        if instance_exists(water_ID)
                            {
                                if water_ID.object_index = obj_mud_cube
                                or water_ID.object_index = obj_mud_water
                                    {
                                        sink_yes = 1;
                                        if ground = 0 and Animations_Override = 0 and attack[0]=0
                                        and hurt[0] = 0 and gravity_ladder = 0 and lilac_boost_cancel = 0
                                        and anim_current != anim_falling
                                            anim_current = anim_falling;
                                    }
                            }
                        if ground = 0 and Animations_Override = 0 and attack[0]=0
                        and hurt[0] = 0 and gravity_ladder = 0 and lilac_boost_cancel = 0
                        and sink_yes = 0
                            {
                                var anim_swim_speed = abs(hsp/24);
                                if hsp &gt; -dec and hsp &lt; dec
                                    anim_swim_speed = 0.125;
                                if anim_current != anim_swimming anim_current = anim_swimming;
                                if frame &lt; anim_lilac[anim_swimming,0] or frame &gt; anim_lilac[anim_swimming,1]+0.8
                                    frame = anim_lilac[anim_swimming,0];
                                frame += 0.08+anim_swim_speed
                                if frame &gt; anim_lilac[anim_swimming,1]+0.8
                                    frame = anim_lilac[anim_swimming,0];
                                //"Rest" mechanic
                                if (stamina &lt; 96) stamina += 0.2;
                            }
                    }
                if above_water = 1 and anim_current = anim_swimming
                    {
                        if ground = 1 anim_current = anim_standing;
                        else          anim_current = anim_jump;
                    }
                //Dragon boost cancel animation
                if lilac_boost_cancel &gt; 0
                    {
                        //Set the current animation frame to the beginning of the animation, if it wasn't before
                        if (frame &lt; 83 or frame &gt; 88)
                            frame = 83;

                        frame += 0.16
                        stamina_pause = 0
                        if lilac_boost_cancel_stamina = 0
                            {
                                stamina -= 15.4
                                lilac_boost_cancel_stamina = 1
                            }
                        //Play the animation to the end
                        if frame &gt; 88 or ground = 1 or hurt[0] = 1 or gravity_ladder &gt; 0
                        or tile_collision_ceiling = 1
                            {
                                lilac_boost_cancel = 0
                                lilac_boost_cancel_stamina = 0
                                lilac_dragon_boost_taper = 0
                                lilac_dragon_boost_taper_mod = 0
                                if ground = 0 anim_current=anim_falling;
                                else          anim_current=anim_standing;
                                if above_water = 0
                                    anim_current = anim_swimming;
                            }
                    }

                //          Active Attack Framing          //
                //=========================================//
                
                //If we are in a normal or special attack state, enable hitboxes based on frame data
                if attack[0] = 1 or attack[2] &gt; 0
                    {
                        //Check which frames should have a hitbox
                        switch(anim_current)
                            {
                                //Lilac Attack 1
                                case anim_lilac_attack_1:
                                    {
                                        if floor(frame)&gt;=135 and frame&lt;=139.6
                                            {
                                                active_frame=1;
                                                action_confirm=1;
                                                spr_action=spr_attack_0;
                                                action_distance = 40;
                                            }
                                        else active_frame=0;
                                        break;
                                    }
                                //Lilac Attack 2
                                case anim_lilac_attack_2:
                                    {
                                        if floor(frame)&gt;=143 and frame&lt;=146.8
                                            {
                                                active_frame=1;
                                                action_confirm=1;
                                                spr_action=spr_attack_0;
                                                action_distance = 40;
                                            }
                                        else active_frame=0;
                                        break;
                                    }
                                //Lilac Crouch Attack
                                case anim_lilac_crouch_attack:
                                    {
                                        if floor(frame)=157 or floor(frame)=158
                                            {
                                                active_frame=1;
                                                action_confirm=1;
                                                spr_action=spr_attack_1;
                                                action_distance = 20;
                                            }
                                        else active_frame=0;
                                        break;
                                    }
                                //Lilac Midair Attack
                                case anim_lilac_midair_attack:
                                    {
                                        if floor(frame)&gt;=161.6 and frame&lt;=166.4
                                            {
                                                active_frame=1;
                                                action_confirm=1;
                                                spr_action=spr_attack_0;
                                                action_distance = 40;
                                            }
                                        else active_frame=0;
                                        break;
                                    }
                                //Lilac Uppercut
                                case anim_lilac_uppercut:
                                    {
                                        if frame&gt;=149.5 or floor(frame)=151
                                            {
                                                active_frame=1;
                                                action_confirm=0;
                                            }
                                        else active_frame=0;
                                        break;
                                    }
                                //Lilac Divekick
                                case anim_lilac_divekick:
                                    {
                                        if floor(frame)=179 or floor(frame)=181
                                            {
                                                active_frame=1;
                                                action_confirm=0;
                                            }
                                        else active_frame=0;
                                        break;
                                    }
                                //Lilac Cyclone
                                case anim_lilac_cyclone:
                                    {
                                        if floor(frame)&gt;=167 and floor(frame)&lt;=172
                                            {
                                                active_frame=1;
                                                action_confirm=0;
                                            }
                                        else active_frame=0;
                                        break;
                                    }
                                //Lilac Dragon Boost 1
                                case anim_lilac_dragon_boost_1:
                                    {
                                        if floor(frame)&gt;=173 and floor(frame)&lt;=178
                                            {
                                                active_frame=1;
                                                action_confirm=0;
                                            }
                                        else active_frame=0;
                                        break;
                                    }
                                //Lilac Dragon Boost 2
                                case anim_lilac_dragon_boost_2:
                                    {
                                        if floor(frame)&gt;=183 and floor(frame)&lt;=186
                                            {
                                                active_frame=1;
                                                action_confirm=0;
                                            }
                                        else active_frame=0;
                                        break;
                                    }
                                //Lilac Dragon Boost R
                                case anim_lilac_dragon_boost_r:
                                    {
                                        if floor(frame)&gt;=208 and floor(frame)&lt;=215
                                            {
                                                active_frame=1;
                                                action_confirm=0;
                                            }
                                        else active_frame=0;
                                        break;
                                    }
                                //Lilac Non-Attack Animations
                                default:
                                    {
                                        active_frame=0;
                                        action_confirm=0;
                                        break;
                                    }
                            }
                    }

                //          Animation Overrides          //
                //=======================================//
                
                //Enforce an override of generic animations, to avoid
                //conflicts with the generic movement system
                
                switch(anim_current)
                    {
                        case anim_lilac_attack_1:       {Animations_Override = 1; attack_damage = 4; break;}
                        case anim_lilac_attack_2:       {Animations_Override = 1; attack_damage = 4; break;}
                        case anim_lilac_crouch_attack:  {Animations_Override = 1; attack_damage = 4; break;}
                        case anim_lilac_midair_attack:  {Animations_Override = 1; attack_damage = 4; break;}
                        case anim_lilac_uppercut:       {Animations_Override = 1; attack_damage = 4; break;}
                        case anim_lilac_divekick:       {Animations_Override = 1; attack_damage = 3; /*active_attack = 1;*/ break;}
                        case anim_lilac_cyclone:        {Animations_Override = 1; attack_damage = 2.70; active_attack = 0; break;}
                        case anim_lilac_dragon_boost_1: {Animations_Override = 1; attack_damage = 4; active_attack = 1; gravity_override = 1; break;}
                        case anim_lilac_dragon_boost_2: {Animations_Override = 1; attack_damage = 4; active_attack = 1; gravity_override = 1; break;}
                        case anim_lilac_dragon_boost_r: {Animations_Override = 1; attack_damage = 4; active_attack = 1; gravity_override = 1; break;}
                        //Assume the override is disabled in every other case
                        default:                        {Animations_Override = 0; attack_damage = 0; active_attack = 0; gravity_override = 0; lilac_dragon_boost_lock = 0; lilac_dragon_boost_timer = 30; gravity_accel = 0.2499; break;}
                    }
                if gravity_rail_check = 1 and anim_current = anim_standing
                    anim_current = anim_lilac_rail_grinding;
            }//End of Pause Check
}//End of Lilac Check
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Carol Action System

//Do not execute code if we are not Carol
if skin = spr_carol and user_cursor_mode = 0
    {
        if anim_idle_timer &gt;= 120 and bike = 0
            {
                var disco_id = collision_circle(universal_player_x,universal_player_y,256,obj_disco_ball,false,true);
                if instance_exists(disco_id)
                    {
                        if disco_id.fade_effect_target = 0.5
                            {
                                anim_current = anim_carol_dancing
                                if frame &lt; anim_carol[anim_carol_dancing,0]
                                    {
                                        frame = anim_carol[anim_carol_dancing,0]
                                        
                                    }
                            }
                    }
            }
        if sit = 1
            {
                var bench_id = collision_circle(px,py,24,obj_bench,false,true);
                if instance_exists(bench_id)
                    {
                        px = lerp(px,bench_id.x,0.25);
                        xdir = 1
                        anim_current = anim_carol_sitting
                        if frame &lt; anim_carol[anim_carol_sitting,0]
                            {
                                frame = anim_carol[anim_carol_sitting,0]
                            }
                    }
                else
                    sit = 0;
                sit_timer += 1
                //"Rest" mechanic
                if (stamina &lt; 96) stamina += 0.4;

                if (sit_timer &gt; 30)
                and (joy_input[0,0] = 1
                or joy_input[0,1] = 1
                or joy_input[0,2] = 1
                or joy_input[0,3] = 1
                or joy_input[1,0] = 1
                or joy_input[1,1] = 1
                or joy_input[1,2] = 1
                or joy_input[1,3] = 1
                or joy_input[1,4] = 1)
                    {
                        sit = 0
                        sit_timer = 0
                        anim_current=anim_standing
                    }
            }

        //================Post Speed Checks================//

        //Make sure we cannot go above 15px/f under any circumstances, by resetting movement to 15px/s
        //at the beginning of each step, if it is above 15px/f
        if (bike = 1 and bike_gears = 1 and gravity_rail_check = 0)
            {
                if hsp &gt;  12 hsp =  12;
                if hsp &lt; -12 hsp = -12;
            }
        else
            {
                if hsp &gt;  15 hsp =  15;
                if hsp &lt; -15 hsp = -15;
            }
        //Never allow the player to go above 15px/f upwards, either
        if gravity_speed &lt; -15 gravity_speed = -15;
        if gravity_speed &gt; 15  gravity_speed = floor(15);
        //Prevent player from leaving the boundaries of the camera
        if use_maps_multi_map_mode = 0 and (room != rm_campaign)
            {
                if px &lt; camera_boundary_left+15  {px = camera_boundary_left+15;  hsp = 0;}
                if px &gt; camera_boundary_right-15 {px = camera_boundary_right-15; hsp = 0;}
            }
        //Prevent player from infinitely flying above the ceiling
        if py &lt; camera_boundary_top-64
            py = camera_boundary_top-64;
        if (use_maps_multi_map_mode = 1) or (room = rm_campaign)
            {
                if px &lt; camera_boundary_left+15  {px = camera_boundary_left+15;  hsp = 0;}
                if (px &gt; camera_boundary_right-32 and room != rm_editor)
                    {
                        if (use_maps_boundary = 0)
                        or (room = rm_campaign and campaign_stage_select &lt; campaign_stage_section_limit)
                            {
                                //Fade to black after a certain period of time
                                transition_alpha+=0.1288
                                transition_timer += 1
                                px += 3
                                if ground = 1
                                    {
                                        anim_current=anim_walking;
                                        anim_previous=anim_walking;
                                    }
                                else
                                    {
                                        if px &lt; camera_boundary_right py += 2.5;
                                        anim_current=anim_falling;
                                    }
                                if transition_timer &gt;=114
                                    {
                                        transition_loading = 1;
                                        transition_alpha = 1;
                                        transition_timer = 0;
                                        now_loading = 1;
                                        use_maps_current_map += 1;
                                        checkpoint_x = 0
                                        checkpoint_y = 0
                                        if alt_skin = 2 and bike = 1
                                            scooter = 1;
                                        if room = rm_campaign
                                            {
                                                dont_change_music = 1
                                                use_maps_current_map = 0
                                                campaign_stage_select += 1
                                                use_cuts_select = campaign_stage_section[campaign_stage_select]
                                            }
                                        use_maps_load = 1
                                    }
                                joy_input[2,6] = 30
                            }
                        else
                            {
                                if px &gt; camera_boundary_right-15
                                    {
                                        px = camera_boundary_right-15;
                                        hsp = 0;
                                    }
                            }
                    }
                if room = rm_editor
                    {
                        if px &gt; camera_boundary_right-15 {px = camera_boundary_right-15; hsp = 0;}
                    }
            }
        //Coyote Time Buffer
        if ground = 0 coyote_time += 1;
        else          coyote_time = 0;

        if pause = 0 and pause_logic = 0
            {
                //Stamina Lock System
                if anim_current = anim_carol_wildclaws
                or anim_current = anim_carol_bike_roll
                or anim_current = anim_carol_attack_super_wild_claw
                    stamina_pause = 1;
                else
                    stamina_pause = 0;

                //==============Attack System==============//
                
                //Attack Button Locking
                if joy_input[1,0] = 1 joy_input[2,5]+= 1;

                var npc_yes = 0;
                //Reset Attack Button Locking If An NPC Is Nearby
                if joy_input[2,5] &gt; 0
                    {
                        var npc_check = instance_nearest(universal_player_x,universal_player_y,obj_interact_parent);
                        if instance_exists(npc_check)
                            {
                                if point_distance(npc_check.x,npc_check.y,universal_player_x,universal_player_y) &lt; 64
                                    {
                                        if ((px &gt; npc_check.x and xdir = -1)
                                        or  (px &lt;= npc_check.x and xdir = 1))
                                            npc_yes = 1;
                                    }
                            }
                    }
                if (joy_input[1,0] = 0 or joy_input[2,5] &gt; 10 or npc_yes = 1)
                    joy_input[2,5] = 0;

                //Jump Button Locking
                if joy_input[1,2] = 1 carol_jump_press+= 1;
                if joy_input[1,2] = 0 carol_jump_press = 0;
        
                //Special Button Locking
                if joy_input[1,3] = 1 carol_special_key_lock+= 1;
                if joy_input[1,3] = 0 carol_special_key_lock = 0;

                //Middle Mouse Button Substitute
                if joy_mouse_button_switch = 1 and joy_input[2,5] &gt;= 7
                    {
                        attack[0] = 0
                        attack[1] = 0
                        joy_input[1,3] = 1
                        if joy_input[2,5] = 8
                            carol_special_key_lock = 1;
                        if joy_input[2,5] &gt; 10
                            joy_input[2,5] = 7;
                    }

                //Switch Button Locking
                if joy_input[1,4] = 1 carol_switch_button += 1;
                if joy_input[1,4] = 0 carol_switch_button = 0;
        
                //Hang Bar Jump Button Locking
                if gravity_ladder!=0 carol_hang_bar_jump  = 4;
                else                 {if carol_hang_bar_jump &gt; 0 carol_hang_bar_jump -= 1;}
        
                //Roll Locking
                if anim_current=anim_carol_rolling {carol_roll_lock  = 0;}
                else       {if carol_roll_lock &lt; 32 {carol_roll_lock += 1;}}
                
                //Golden Claw Attack Locking
                if anim_current=anim_carol_goldenclaws carol_attack_lock = 1;
                if joy_input[0,1] = 0                  carol_attack_lock = 0;

                //Momentary Attack Speedup Buff
                if carol_speed_up &gt; 0
                    {
                        carol_speed_up -= 1
                        if anim_current=anim_carol_attack_1
                        or anim_current=anim_carol_attack_2
                        or anim_current=anim_carol_attack_3
                            frame += 0.48;
                    } 

                //Coyote Time Buffer
                if ((anim_current=anim_falling or anim_current=anim_carol_rolling) and angle_a = 0 and coyote_time &lt; 8) and carol_jump_press = 1
                    {
                        gravity_speed = -5
                        //Disable jump lock and timer
                        carol_jump_lock  = 0
                        carol_jump_timer = 0
                    }
        
                //Bike Mount Trigger
                if bike_mount_trigger &gt; 0 bike_mount_trigger -=1;

                //Carrie's Double Jump Lock Check
                if alt_skin &gt; 0 and bike = 0
                    {
                        if bike_double_jump_lock = 1 and (ground = 1 or spring_timer &gt; 0
                        or anim_current = anim_carol_wall_jump or above_water = 0 or hurt[0] = 1)
                            bike_double_jump_lock = 0
                    }
                else
                    {
                        if ground = 1 or gravity_ladder &gt; 0
                            boot_swipe_jump = 4;
                    }
        
                //==============Bike Management System==============//
        
                //Mount The Bike If We Have Landed On It
                if px &gt;= bike_x-28 and px &lt;= bike_x+28 and py &gt;= bike_y-30 and py &lt;= bike_y    //Hitbox
                and bike_mount_trigger = 0 and gravity_speed &gt; 0 and bike = 0                  //Condition
                and alt_skin != 1 //Prevent Carrie specifically from using the bike
                    {
                        bike = 1; bike_confirm = 1; //Mount The Bike
                        px   = bike_x               //Set Player's X to Bike's X
                        py   = bike_y               //Set Player's Y to Bike's Y
                        hsp  = 0                    //Reset Player's Speed
                        xdir = bike_dir             //Set Player's Facing Direction to Bike's Facing Direction
                        angle_a = bike_angle        //Set Player's Angle to Bike's Angle
                        bike_x = -1;   bike_y = -1; //Disable Drawing Of The Bike Tile
                        acc = 0.06                  //Modify acceleration
                        bike_gears = 0
                        carol_crouch_leap_timer = 0
                        carol_crouch_leap_switch = 0
                        //Play Sound
                        scr_play_sound(carol_gas_can,0)
                    }
        
                if bike = 1
                    {
                        //Change Gears
                        if carol_switch_button = 1
                            {
                                bike_gears += 1
                                if bike_gears &gt; 1
                                    bike_gears = 0;
                                switch(bike_gears)
                                    {
                                        case 0:
                                            {
                                                //Physics Parameters
                                                acc  = 0.06     //Player Acceleration (Ground)
                                                mcap = 12       //Player Horizontal Speed Cap (Maximum Speed)
                                                hcap = 8        //Player Horizontal Speed Cap (Under Own Power)
                                                wcap = 8        //Player Horizontal Speed Cap (Underwater)
                                                frc  = 0.046875 //Player Friction
                                                stagger_speed = 0.15 //Speed for sliding backwards down a slope
                                                slope_acceleration_rate_storage = 0.06
                                                break;
                                            }
                                        case 1:
                                            {
                                                //Physics Parameters
                                                acc  = 0.07375                      //Player Horizontal Acceleration
                                                mcap = 12                           //Player Horizontal Speed Cap (Maximum Speed)
                                                hcap = 5                            //Player Horizontal Speed Cap (Under Own Power)
                                                wcap = 4                            //Player Horizontal Speed Cap (Underwater)
                                                frc  = 0.3688                       //Player Friction
                                                stagger_speed = 0.4                 //Player Stagger Speed
                                                slope_acceleration_rate_storage = 0.07375
                                                break;
                                            }
                                    }
                                scr_play_sound(carol_bike_change_gears,0)
                            }
                        //Bike Flinging
                        if bike_fling_speed &lt; 0
                            {
                                //If we have touched the ceiling, disable bike flinging
                                if tile_collision_ceiling = 1 bike_fling_speed = 0;
                                //Override gravity speed
                                gravity_speed = bike_fling_speed
                                bike_fling_speed += gravity_accel
                            }
        
                        //Jump Off Of Walls While Riding The Bike
                        if bike_jump_trigger = 1
                            {
                                if bike_jump_speed &lt; -0.5 {hsp = 0; px += bike_jump_speed; bike_jump_speed += 0.5}
                                if bike_jump_speed &gt; 0.5  {hsp = 0; px += bike_jump_speed; bike_jump_speed -= 0.5}
                                if bike_jump_speed &gt;= -0.5 and bike_jump_speed &lt;= 0.5
                                or bike_jump_speed &gt; 0 and joy_input[0,0] = 1 and joy_input[0,2] = 0
                                or bike_jump_speed &lt; 0 and joy_input[0,2] = 1 and joy_input[0,0] = 0
                                    {
                                        hsp = bike_jump_speed;
                                        bike_jump_speed = 0;
                                        bike_jump_trigger = 0;
                                    }
                            }
        
                        //Reset Bike Particles On Hangbars
                        if (anim_current=anim_hanging_idle or anim_current=anim_ladder_climbing)
                        and bike = 1 and skidding_override = 0 and above_water = 1
                            {
                                //Initialize Animation Frames
                                skid_animation_frame[0] = -2  skid_animation_frame[1] = -3
                                skid_animation_frame[2] = -4  skid_animation_frame[3] = -5
                                skid_animation_frame[4] = -6  skid_animation_frame[5] = -7
                                skid_animation_frame[6] = -8  skid_animation_frame[7] = -9
                                skid_animation_frame[8] = -10 skid_animation_frame[9] = -11
                                //Enable Skid Particles
                                skidding_override = 1;
                            }
        
                        //Restart Double Jump Timer On Hangbars
                        if anim_current=anim_hanging_idle or anim_current=anim_ladder_climbing
                            {
                                bike_jump_roll = 0
                                bike_double_jump_lock = 0
                            }
        
                        //Refresh Double Jump Lock
                        if bike_double_jump_lock = 1 and (ground = 1 or spring_timer &gt; 0
                        or anim_current = anim_carol_wall_jump or above_water = 0 or hurt[0] = 1)
                            bike_double_jump_lock = 0
        
                        //Bike Particles
                        if xdir = -1
                            {
                                bike_particles_rotate_x = px+lengthdir_x(24,angle_a+17)
                                bike_particles_rotate_y = py+lengthdir_y(24,angle_a+17)
                            }
                        else
                            {
                                bike_particles_rotate_x = px+lengthdir_x(-24,angle_a-12)
                                bike_particles_rotate_y = py+lengthdir_y(-24,angle_a-12)
                            }
                        //Scroll Bike Particles Backwards
                        if anim_current!=anim_carol_wall_jump and anim_current!=anim_ladder_climbing
                            {
                                skid_offset_x[0]-=2*xdir
                                skid_offset_x[1]-=2*xdir
                                skid_offset_x[2]-=2*xdir
                                skid_offset_x[3]-=2*xdir
                                skid_offset_x[4]-=2*xdir
                                skid_offset_x[5]-=2*xdir
                                skid_offset_x[6]-=2*xdir
                                skid_offset_x[7]-=2*xdir
                                skid_offset_x[8]-=2*xdir
                                skid_offset_x[9]-=2*xdir
                            }
                        //Override Skidding Particle Positions If We Are Underwater
                        if above_water = 0
                            {
                                skid_offset_x[0]=-16
                                skid_offset_x[1]=-16
                                skid_offset_x[2]=-16
                                skid_offset_x[3]=-16
                                skid_offset_x[4]=-16
                                skid_offset_x[5]=-16
                                skid_offset_x[6]=-16
                                skid_offset_x[7]=-16
                                skid_offset_x[8]=-16
                                skid_offset_x[9]=-16
                                skid_offset_y[0]=-16
                                skid_offset_y[1]=-16
                                skid_offset_y[2]=-16
                                skid_offset_y[3]=-16
                                skid_offset_y[4]=-16
                                skid_offset_y[5]=-16
                                skid_offset_y[6]=-16
                                skid_offset_y[7]=-16
                                skid_offset_y[8]=-16
                                skid_offset_y[9]=-16
                            }
                        //Play Bike Sounds
                        if bike_gravity_speed = 0
                            {
                                //Engine Idling Sounds
                                if abs(hsp) &lt;= 2
                                    {
                                        //Start engine idling sound
                                        if not audio_is_playing(carol_bike_idle) audio_play_sound(carol_bike_idle,50,true);
                                    }
                                //Engine Driving Sounds
                                if abs(hsp) &gt;= 0
                                    {
                                        //Stop the idling sounds if we are above a speed of 2px/s
                                        if abs(hsp) &gt; 2
                                            {
                                                if audio_is_playing(carol_bike_idle) audio_stop_sound(carol_bike_idle);
                                            }
                                        //Start engine driving sound
                                        if not audio_is_playing(carol_bike_moving) audio_play_sound(bike_pitch,50,true);
                                        //Modify pitch of driving sound based on speed
                                        if alt_skin = 0 audio_sound_pitch(bike_pitch,abs(hsp)/3)
                                        if alt_skin = 2 audio_sound_pitch(bike_pitch,abs(hsp)/1.4)
                
                                        //Stop the driving sounds if we have stopped moving
                                        if hsp = 0 and audio_is_playing(carol_bike_moving) audio_stop_sound(carol_bike_moving);
                                    }
                            }
                        //Play Bike Landing Sound
                        if ground = 1 and bike_landing_sound &lt; 8
                            {
                                bike_landing_sound += 1
                                //Do not play landing sound if we are underwater
                                if bike_landing_sound = 1 and above_water = 1 audio_play_sound(carol_bike_land,50,false);
                            }
                        if ground = 0 and bike_landing_sound &gt; 0 bike_landing_sound = 0;
                        //Play Bike Skidding Sound
                        if anim_current=anim_skidding and ground=1 and not audio_is_playing(carol_bike_skidding)
                            audio_play_sound(carol_bike_skidding,50,false);
                        //Prevent Bike Animations From Freezing At High-Speeds
                        if anim_current = anim_faster
                            anim_current = anim_walking;
        
                        //Set Spawn Points For Skid Particles
                        switch(anim_current)
                            {
                                case anim_carol_wall_jump: {skid_spawn_x = px+10*xdir; skid_spawn_y = py+2   break;}
                                case anim_ladder_climbing: {skid_spawn_x = px;         skid_spawn_y = py-5   break;}
                                case anim_hanging_idle:    {skid_spawn_x = px-9*xdir;  skid_spawn_y = py+24; break;}
                                case anim_jump:            {skid_spawn_x = px-8*xdir;  skid_spawn_y = py;    break;}
                                case anim_falling:         {skid_spawn_x = px-8*xdir;  skid_spawn_y = py;    break;}
                                case anim_spring:          {skid_spawn_x = px-8*xdir;  skid_spawn_y = py;    break;}
                                case anim_hurt:            {skid_spawn_x = px-7*xdir;  skid_spawn_y = py+4;  break;}
                                case anim_carol_wildclaws: {skid_spawn_x = px+3*xdir;  skid_spawn_y = py+2;  break;}
                                //Disable Particles
                                case anim_carol_bike_roll: {skid_spawn_x = -24; skid_spawn_y = -24}
                                //Assume We Should Spawn Particles At Tail Pipe In Any Other Case
                                default:
                                    {
                                        skid_spawn_x = bike_particles_rotate_x
                                        skid_spawn_y = bike_particles_rotate_y
                                        break;
                                    }
                            }
                    }
        
                //==============Animation Override System==============//
        
                //Modify and override animations relevant to riding our bike
                if (bike = 1 and bike_confirm = 1 and alt_skin != 1) scr_set_carol_state_riding_bike();
        
                //--------------Revert Character Animations--------------//
        
                //Revert character animations back to normal
                if (bike = 0 and anim_carol[0,0] = 172) scr_set_carol_state_without_bike();
        
                //Do not execute code if we are on a ladder
                if gravity_ladder = 0
                    {
                        //      Normal Attacks      //
                        //--------------------------//
                        
                        //Check if we are attacking
                        if (joy_input[1,0] = 1 and attack[0] = 0 and anim_current!=anim_carol_wall_jump and npc_yes = 0
                        and anim_current!=anim_carol_crouch_attack and anim_current!=anim_carol_rolling and hurt[0] = 0
                        and joy_input[2,5] &lt;= 5 and sit = 0)
                            {
                                //If we were performing the double jump on the bike, override it
                                if bike_jump_roll &gt; 0
                                    {
                                        bike_jump_roll = 0
                                        frame = anim_carol[44,0]
                                        //Initialize Animation Frames
                                        skid_animation_frame[0] = -2  skid_animation_frame[1] = -3
                                        skid_animation_frame[2] = -4  skid_animation_frame[3] = -5
                                        skid_animation_frame[4] = -6  skid_animation_frame[5] = -7
                                        skid_animation_frame[6] = -8  skid_animation_frame[7] = -9
                                        skid_animation_frame[8] = -10 skid_animation_frame[9] = -11
                                        //Enable Skid Particles
                                        skidding_override = 1;
                                    }
                                if (joy_input[0,3] = 0 and joy_input[0,1] = 0 and alt_skin = 0) or bike = 1 or alt_skin &gt; 0
                                    {
                                        if anim_current = anim_swimming
                                            {
                                                anim_current=anim_carol_attack_1
                                                frame = anim_carol[anim_carol_attack_1,0]
                                            }
                                        //Reset Attack State
                                        if bike = 0 and attack[1] &gt; 4 attack[1] = 0;
                                        if bike = 1 and attack[1] &gt; 2 attack[1] = 0;
                                        //Ground Attack
                                        if attack[1] = 0 {anim_current=anim_carol_attack_3; carol_attack_frame=0; attack_offset = 0; carol_attack_frame_repeat=4; carol_action_distance=-16}
                                        if attack[1] = 1 {anim_current=anim_carol_attack_2; carol_attack_frame=0; attack_offset = 8; carol_attack_frame_repeat=3; carol_action_distance=40}
                                        if attack[1] = 2 {anim_current=anim_carol_attack_1; carol_attack_frame=0; attack_offset = 8; carol_attack_frame_repeat=4; carol_action_distance=56}
                                        if alt_skin = 0
                                            {
                                                if attack[1] = 3 {anim_current=anim_carol_attack_4; carol_attack_frame=0; attack_offset = 8; carol_attack_frame_repeat=3; carol_action_distance=56}
                                                if attack[1] = 4 {anim_current=anim_carol_attack_5; carol_attack_frame=0; attack_offset = 8; carol_attack_frame_repeat=4; carol_action_distance=64}
                                            }
                                        if alt_skin &gt; 0 and attack[1] &gt; 2
                                            {anim_current=anim_carol_attack_2; carol_attack_frame=0; attack_offset = 8; carol_attack_frame_repeat=3; carol_action_distance=40}
                                    }
                                //Don't let keyboard users have ANY fun!
                                if not (joy_input[0,3] = 1 and joy_input[0,1] = 1)
                                    {
                                        //Iterate Attack State
                                        attack[0]  = 1                  //Set Attack State
                                        attack[1] += 1                  //Increment Attack Stage
                                        attack_range = 72               //Horizontal Hitbox Range
                                        attack_width = 90               //Angular Hitbox Range
                                        travel_length = 0               //Horizontal offset for Hitbox
                                        travel_height = 0               //Vertical offset for Hitbox
                                        attack_shape  = 0               //Shape of the hitbox (Elliptical)
                                    }
                                if alt_skin = 0
                                    {
                                        if joy_input[0,3] = 1 and joy_input[0,1] = 0 and bike = 0
                                            {
                                                anim_current=anim_carol_attack_boot_swipe
                                                carol_attack_frame=0
                                                attack_offset = 0
                                                attack_range = 48
                                                if above_water = 0
                                                    boot_swipe_jump = 4;
                                                if ground = 1
                                                    {
                                                        boot_swipe_jump = 4
                                                        if gravity_slope = 0
                                                            {
                                                                gravity_speed = -boot_swipe_jump
                                                                carol_jump_lock  = 1
                                                                carol_jump_timer = 0
                                                                if potion_feather_timer &gt; 0
                                                                    {
                                                                        gravity_speed -= 1.4
                                                                    }
                                                            }
                                                        //If we were on a slope, influence the jump speed based on angle
                                                        if (gravity_slope = 1 or tile_surface_wall_xcompass != 0)
                                                            {
                                                                //Determine the general direction of the jump by the player's X/Y coordinates
                                                                var jump_length_x = lengthdir_x(boot_swipe_jump,tile_angle+90)
                                                                var jump_length_y = lengthdir_y(boot_swipe_jump,tile_angle+90)
                                                                //Determine the additional speed of the jump by another orbit
                                                                var speed_length_y = lengthdir_y(hsp,tile_angle)
                                                                //Apply horizontal and vertical speed to the player based on the difference
                                                                hsp           = jump_length_x+hsp
                                                                gravity_speed = jump_length_y+speed_length_y
                                                                //Disable jump lock and timer
                                                                carol_jump_lock  = 0
                                                                carol_jump_timer = 0
                                                                //Set fling timer to prevent the player from overriding their horizontal speed
                                                                if xcompass != 0 and not (angle_a &lt;= 90 and xdir=-1) and not (angle_a &gt;= 270 and xdir=1)
                                                                    {
                                                                        hsp = jump_length_x;
                                                                        fling_timer = boot_swipe_jump;
                                                                        fling_hsp=hsp;
                                                                    }
                                                                //If we were jumping off of a flat wall, reset direction of gravity speed
                                                                if (tile_angle = 270 and xdir = -1) or (tile_angle = 90 and xdir = 1)
                                                                    {
                                                                        fling_ver_timer = boot_swipe_jump
                                                                        fling_vsp = -abs(jump_length_y+speed_length_y)
                                                                    }
                                                                if (tile_angle = 270 and xdir = 1 or tile_angle = 90 and xdir = -1)
                                                                    {
                                                                        fling_ver_timer = boot_swipe_jump
                                                                        fling_vsp = abs(jump_length_y+speed_length_y)
                                                                    }
                                                                if potion_feather_timer &gt; 0
                                                                    {
                                                                        fling_vsp += 1.4
                                                                    }
                                                                //Override slope clipping for this one frame
                                                                gravity_slope = 0
                                                                xcompass = 0                        //Override current tile compass direction
                                                                tile_check_slope_priority = 0       //Slope Priority For Flat Surface Running
                                                                tile_surface_wall_xcompass = 0      //Tile Compass For Flat Surface Running
                                                            }
                                                    }
                                                else
                                                    {
                                                        gravity_speed = -boot_swipe_jump
                                                        carol_jump_lock  = 1
                                                        carol_jump_timer = 0
                                                        boot_swipe_jump -= 0.5
                                                    }
                                                scr_play_sound(carol_boot_swipe,0)
                                            }
                                        if joy_input[0,3] = 0 and joy_input[0,1] = 1 and bike = 0 and ground = 1 and hsp = 0
                                            {
                                                anim_current=anim_carol_attack_claw_swipe
                                                carol_attack_frame=0
                                                attack_offset = 0
                                                attack_range = 48
                                            }
                                        if joy_input[0,3] = 0 and joy_input[0,1] = 1 and bike = 0 and ground = 0
                                            {
                                                anim_current=anim_carol_attack_jump_kick
                                                carol_attack_frame=0
                                                attack_offset = 0
                                                attack_range = 80
                                                if abs(hsp) &lt; 12  hsp += 3*xdir;
                                                audio_stop_sound(carol_boot_swipe)
                                                audio_play_sound(carol_jump_kick,50,false)
                                            }
                                    }
                                //Play Voice Sample
                                if not (joy_input[0,3] = 1 and joy_input[0,1] = 1) //Don't let keyboard users have ANY fun!
                                    {
                                        var voice_sample = random_range(0,3.9)
                                        if anim_current!=anim_carol_attack_boot_swipe
                                        and anim_current!=anim_carol_attack_jump_kick
                                            {
                                                if alt_skin = 0
                                                    {
                                                        switch(floor(voice_sample))
                                                            {
                                                                case 0: {audio_play_sound(carol_attack_1,50,false); break;}
                                                                case 1: {audio_play_sound(carol_attack_2,50,false); break;}
                                                                case 2: {audio_play_sound(carol_attack_3,50,false); break;}
                                                                case 3: {audio_play_sound(carol_attack_4,50,false); break;}
                                                            }
                                                    }
                                                else
                                                    {
                                                        switch(floor(voice_sample))
                                                            {
                                                                case 0: {audio_play_sound(carol_attack_1,50,false); break;}
                                                                case 1: {audio_play_sound(snd_carrie_attack_1,50,false); audio_play_sound(carol_attack_1,50,false); break;}
                                                                case 2: {audio_play_sound(snd_carrie_attack_2,50,false); audio_play_sound(carol_attack_4,50,false); break;}
                                                                case 3: {audio_play_sound(carol_attack_4,50,false); break;}
                                                            }
                                                    }
                                            }
                                    }
                            }
                        if anim_current=anim_carol_attack_boot_swipe
                            {
                                if (carol_jump_lock = 1) and (gravity_slope = 0)
                                    {
                                        carol_jump_timer += 1
                                        gravity_speed = -boot_swipe_jump
                                        //Disable jump, if we have reached the height of the jump, or released the button
                                        if carol_jump_timer &gt; 3.4
                                        or tile_collision_ceiling = 1
                                            {
                                                carol_jump_lock  = 0
                                                carol_jump_timer = 0
                                            }
                                    }
                            }
                        //Crouch Attack//
                        //-------------//
                        if anim_current = anim_ducking and carol_jump_press = 1
                            {
                                anim_current=anim_carol_crouch_attack
                                carol_crouch_leap_switch = 1
                                //If we were on the bike, unmount from it and leave a bike tile in its place
                                if bike = 1
                                    {
                                        bike       = 0
                                        bike_x     = px
                                        bike_y     = py
                                        bike_dir   = xdir
                                        bike_angle = angle_a
                                        //Drawing code in "Carol Tail and Particles" code block in the drawing event
                                        //Stop bike sound effects
                                        audio_stop_sound(carol_bike_idle)
                                        audio_stop_sound(carol_bike_moving)
                                        bike_mount_trigger = 32
                                    }
                                var voice_sample = random_range(0,1.9)
                                switch(floor(voice_sample))
                                    {
                                        case 0:
                                            {
                                                if alt_skin = 0
                                                    {
                                                        audio_stop_sound(carol_attack_leap);
                                                        audio_play_sound(carol_attack_leap,50,false);
                                                    }
                                                else
                                                    {
                                                        audio_stop_sound(snd_carrie_attack_leap)
                                                        audio_play_sound(snd_carrie_attack_leap,50,false)
                                                        audio_stop_sound(carol_pounce)
                                                        audio_play_sound(carol_pounce,50,false)
                                                    }
                                                break;
                                            }
                                        case 1: {audio_stop_sound(carol_pounce);      audio_play_sound(carol_pounce,50,false);      break;}
                                    }
                            }
                        
                        //Check if we are pressing the jump key again in mid-air
                        if joy_input[1,2] = 1 and carol_jump_confirm_key = 0 carol_jump_confirm_key = 1;
                        if joy_input[1,2] = 0 and carol_jump_confirm_key = 1 carol_jump_confirm_key = 2;
                        
                        //If we have landed before performing the attack, reset confirm keys
                        if (ground = 1 and carol_jump_confirm_key &gt; 0)
                            {
                                carol_jump_confirm_key = 0
                                carol_spring_confirm_key = 0
                            }
                        //If we have landed on a spring, and the spring reset confirm keys, modify their value
                        //so the player doesn't have to double tap the jump key to use the cyclone attack
                        if spring_timer&gt;=0 and (carol_jump_confirm_key=0 or carol_jump_confirm_key=2) and (carol_spring_confirm_key = 0)
                            {
                                carol_jump_confirm_key=1
                                carol_spring_confirm_key=1
                            }
                        //Reset spring confirm key if the spring timer has been reset
                        if spring_timer = spring_timer_blue or spring_timer = spring_timer_gold carol_spring_confirm_key=0;
                        //Reset jump confirm key if we have fall off of a platform, so the bike's double jump doesn't need two
                        //button taps to confirm
                        if (gravity_speed &gt; 0 and carol_jump_confirm_key = 0) carol_jump_confirm_key = 1;
        
                        //Disable Crouch Attack If We Have Released The Down Button
                        if anim_current = anim_ducking and joy_input[0,1] = 0 anim_current=anim_standing;
                        //Crouch Upward Leap
                        if anim_current=anim_carol_crouch_attack and bike = 0
                            {
                                //Iterate Leap Timer
                                carol_crouch_leap_timer += 1
                                //If we started the leap from the ground, leap upward
                                var carol_leap_speed = 6;
                                if carol_crouch_leap_switch = 1 and carol_crouch_leap_timer &lt; 4
                                    gravity_speed=-3;
                                if (gravity_speed &lt;= -3 or potion_feather_timer &gt; 0)
                                    carol_leap_speed = 8;
                                //Forward Leap
                                if (xdir = 1)  or (joy_input[0,0] = 1 and joy_input[0,2] = 0) {if hsp &lt; carol_leap_speed hsp = carol_leap_speed;}
                                if (xdir = -1) or (joy_input[0,0] = 0 and joy_input[0,2] = 2) {if hsp &gt; -carol_leap_speed hsp = -carol_leap_speed;}
                                //Disable Upward Leap Upon Touching The Ground, Or Landing In The Water
                                if ground = 1 and carol_crouch_leap_timer &gt; 2
                                or above_water = 0
                                    {
                                        anim_current=anim_standing; carol_crouch_leap_switch = 0;
                                    }
                                //Or The Walls
                                if wall_collision_left = 1 or wall_collision_right = 1 or spring_timer &gt;= 0 {anim_current=anim_falling; carol_crouch_leap_switch = 0;}
                                //Or If The Player Presses In The Other Direction
                                if xdir = 1  and joy_input[0,2] = 1 and joy_input[0,0] = 0
                                or xdir = -1 and joy_input[0,0] = 1 and joy_input[0,2] = 0
                                    {
                                        anim_current=anim_falling;
                                        carol_crouch_leap_switch = 0;
                                    }
                                //Disable slope Y clipping for this frame in particular, otherwise Carol sticks to the slope's ground
                                if carol_crouch_leap_timer = 1 gravity_slope=0;
                                if carol_crouch_leap_timer &gt; 1 and carol_crouch_leap_timer &lt; 8
                                and tile_exists(tile_ramp_id) and xcompass = 0
                                    {
                                        if tile_ramp_pos[1] &gt; orig_clip[tile_ramp_id_debug,tile_ramp_pos[0]]
                                            {
                                                gravity_slope=1
                                                carol_crouch_leap_switch = 0
                                            }
                                    }
                            }
        
                        //Mid-Air Leap Attack//
                        //-------------------//
                        if  (anim_current = anim_jump or anim_current = anim_falling or anim_current = anim_spring or anim_current=anim_carol_rolling)
                        and (carol_jump_press = 1 and above_water = 1 and carol_hang_bar_jump = 0)
                        and (wall_collision_left = 0 and wall_collision_right = 0)
                        and (carol_jump_confirm_key = 2 or ground = 0)
                        and bike = 0 and hurt[0] = 0
                            {
                                anim_current=anim_carol_crouch_attack
                                spring_timer = -1
                                var voice_sample = random_range(0,1.9)
                                switch(floor(voice_sample))
                                    {
                                        case 0:
                                            {
                                                if alt_skin = 0
                                                    {
                                                        audio_stop_sound(carol_attack_leap);
                                                        audio_play_sound(carol_attack_leap,50,false);
                                                    }
                                                else
                                                    {
                                                        audio_stop_sound(snd_carrie_attack_leap)
                                                        audio_play_sound(snd_carrie_attack_leap,50,false)
                                                        audio_stop_sound(carol_pounce)
                                                        audio_play_sound(carol_pounce,50,false)
                                                    }
                                                break;
                                            }
                                        case 1: {audio_stop_sound(carol_pounce);      audio_play_sound(carol_pounce,50,false);      break;}
                                    }
                            }

                        //Golden Claw Attack//
                        //------------------//
                        //Perform golden claw attack, if we were leaping forward or rolling
                        if (anim_current=anim_carol_crouch_attack and joy_input[2,5] = 1)
                        or (bike=1 and bike_boost_trigger &gt; 0 and joy_input[2,5] = 1)
                            {
                                if joy_input[0,3] = 0 and joy_input[0,1] = 1 and joy_input[1,4] = 0
                                and bike = 0 and ground = 0 and alt_skin = 0
                                    {
                                        anim_current=anim_carol_attack_jump_kick; carol_attack_frame=0; attack_offset = 0;
                                        audio_stop_sound(carol_boot_swipe);
                                        audio_play_sound(carol_jump_kick,50,false);
                                    }
                                else
                                    {
                                        //Ground Attack
                                        carol_crouch_leap_switch = 0;
                                        anim_current=anim_carol_goldenclaws;
                                        carol_attack_frame=0;
                                        carol_attack_frame_repeat=12;
                                        carol_action_distance=-16
                                        carol_speed_up = 30;
                                        //Iterate Attack State
                                        attack[0]  = 1                  //Set Attack State
                                        attack[1]  = 0                  //Increment Attack Stage
                                        attack_range = 72               //Horizontal Hitbox Range
                                        attack_width = 90               //Angular Hitbox Range
                                        travel_length = 0               //Horizontal offset for Hitbox
                                        travel_height = 0               //Vertical offset for Hitbox
                                        attack_shape  = 0               //Shape of the hitbox (Elliptical)
                                        attack_offset = 0               //Vertical offset for Hitbox
                                        audio_play_sound(carol_gold_claws,50,false);                                       
                                    }
                            }
                        if (bike = 0 and carol_switch_button = 1 and alt_skin = 0
                        and joy_input[1,0] = 0 and stamina &gt;= 10 and stamina_pause = 0)
                            {
                                anim_current=anim_carol_attack_super_wild_claw;
                                //Ground Attack
                                carol_crouch_leap_switch = 0;
                                carol_attack_frame=0;
                                carol_attack_frame_repeat=12;
                                carol_action_distance=-16
                                carol_speed_up = 30;
                                //Iterate Attack State
                                attack[0]  = 1                  //Set Attack State
                                attack[1]  = 0                  //Increment Attack Stage
                                attack_range = 72               //Horizontal Hitbox Range
                                attack_width = 90               //Angular Hitbox Range
                                travel_length = 0               //Horizontal offset for Hitbox
                                travel_height = 0               //Vertical offset for Hitbox
                                attack_shape  = 0               //Shape of the hitbox (Elliptical)
                                attack_offset = 0               //Vertical offset for Hitbox
                                audio_play_sound(carol_gold_claws,50,false);   
                            }
        
                        //Rolling Attack//
                        //--------------//
                        if hsp!=0 and gravity_speed=0 and joy_input[0,1] = 1 and anim_current!=anim_carol_rolling
                        and anim_current!=anim_carol_crouch_attack and carol_roll_lock &gt; 16 and carol_attack_lock = 0
                        and anim_current!=anim_carol_attack_1
                        and anim_current!=anim_carol_attack_2
                        and anim_current!=anim_carol_attack_3
                        and anim_current!=anim_carol_attack_boot_swipe
                        and bike = 0
                        and tile_collision_ceiling = 0
                            {
                                anim_current=anim_carol_rolling
                                attack[0]    = 1                 //Set Attack State
                                attack_range = 32                //Horizontal Hitbox Range
                                attack_width = 359               //Angular Hitbox Range
                                travel_length = 0                //Horizontal offset for Hitbox
                                travel_height = 0                //Vertical offset for Hitbox
                                attack_shape  = 0                //Shape of the hitbox (Elliptical)
                                attack_offset = 0                //Attack offset
                                carol_jump_lock  = 0             //Set Jump Lock
                                carol_jump_timer = 0             //Set Jump Timer
                                carol_roll_lock  = 0             //Set Roll Lock
                                carol_roll_timer = 0             //Set Roll Timer
                                attack_offset = 0                //Vertical offset for Hitbox
                                audio_play_sound(carol_roll,50,false)
                            }
                        //Perform rolling attack if we are using the rolling animation
                        if carol_roll_lock = 0
                            {
                                //Allow continuous attacking while rolling
                                attack[0]    = 1                 //Set Attack State
                                attack_range = 32                //Horizontal Hitbox Range
                                attack_width = 359               //Angular Hitbox Range
                                travel_length = 0                //Horizontal offset for Hitbox
                                travel_height = 0                //Vertical offset for Hitbox
                                attack_shape  = 0                //Shape of the hitbox (Elliptical)
                                attack_offset = 0                //Attack offset

                                //==========Decceleration==========//

                                //Change Direction
                                if joy_input[0,0] = 1 and joy_input[0,2] = 0 and hsp&gt;0 xdir=1;
                                if joy_input[0,2] = 1 and joy_input[0,0] = 0 and hsp&lt;0 xdir=-1;
        
                                //==========Deceleration==========//
        
                                //Apply Friction If We Are Not Pressing Any Buttons
                                if (joy_input[0,0] = 0 and joy_input[0,2] = 0 and ground=1)
                                    {
                                        carol_roll_timer += 1
                                        //Left
                                        if hsp&lt;-0.046875
                                            {
                                                //Friction On The Ground
                                                if gravity_speed = 0                  hsp += 0.046875;
                                                //Friction In Mid-Air
                                                if gravity_speed !=0 and abs(hsp)&gt;0.046875 hsp += drag[0];
                                                //Apply Slow Speed When We Are Slower Than Set Friction (Emulates The Original Game's Behavior)
                                                if gravity_speed !=0 and abs(hsp)&lt;0.046875 hsp = 0.046875;
                                            }
                                        //Right
                                        if hsp&gt;0.046875
                                            {
                                                //Friction On The Ground
                                                if gravity_speed = 0 hsp -= 0.046875;
                                                //Friction In Mid-Air
                                                if gravity_speed !=0 and abs(hsp)&gt;0.046875 hsp -= drag[0];
                                                //Apply Slow Speed When We Are Slower Than Set Friction (Emulates The Original Game's Behavior)
                                                if gravity_speed !=0 and abs(hsp)&lt;0.046875 hsp = -0.046875;
                                            }
                                        //Stop moving completely if we are slower than the base friction speed (Only on the ground, though.)
                                        if (abs(hsp)&lt;0.046875 or tile_surface_id[3] != -1 or tile_surface_id[4] != -1 or tile_wall_right_trig = 1
                                        or tile_wall_left_trig = 1) and gravity_speed = 0
                                        or (carol_roll_timer &gt; 31 and abs(hsp) &lt; 2)
                                            {
                                                hsp=0; anim_current=anim_standing;
                                                carol_roll_timer = 0;
                                            }
                                        acc_time=0;
                                    }
                                else
                                    carol_roll_timer = 0;
        
                                //============Braking============//
        
                                //Left Braking
                                if joy_input[0,2] = 1 and hsp&gt;0 and wall_collision_left=0  hsp-=dec;
                                //Right Braking
                                if joy_input[0,0] = 1 and hsp&lt;0 and wall_collision_right=0 hsp+=dec;
        
                                //============Jumping============//
        
                                //If we were on a slope, influence the jump speed based on angle
                                if (gravity_slope = 1 or tile_surface_wall_xcompass != 0) and carol_jump_press = 1
                                    {
                                        //Determine the general direction of the jump by the player's X/Y coordinates
                                        var jump_length_x = lengthdir_x(gravity_jump,tile_angle+90)
                                        var jump_length_y = lengthdir_y(gravity_jump,tile_angle+90)
                                        //Determine the additional speed of the jump by another orbit
                                        var speed_length_y = lengthdir_y(hsp,tile_angle)
                                        //Apply horizontal and vertical speed to the player based on the difference
                                        hsp           = jump_length_x+hsp
                                        gravity_speed = jump_length_y+speed_length_y
                                        if potion_feather_timer &gt; 0
                                            {
                                                gravity_speed -= 1.4
                                            }
                                        //Disable jump lock and timer
                                        carol_jump_lock  = 0
                                        carol_jump_timer = 0
                                        //Set fling timer to prevent the player from overriding their horizontal speed
                                        if xcompass != 0 and not (angle_a &lt;= 90 and xdir=-1) and not (angle_a &gt;= 270 and xdir=1)
                                            {
                                                hsp = jump_length_x;
                                                fling_timer = 8;
                                                fling_hsp=hsp;
                                            }
                                        //If we were jumping off of a flat wall, reset direction of gravity speed
                                        if (tile_angle = 270 and xdir = -1) or (tile_angle = 90 and xdir = 1)
                                            {
                                                fling_ver_timer = 8
                                                fling_vsp = -abs(jump_length_y+speed_length_y)
                                            }
                                        if (tile_angle = 270 and xdir = 1 or tile_angle = 90 and xdir = -1)
                                            {
                                                fling_ver_timer = 8
                                                fling_vsp = abs(jump_length_y+speed_length_y)
                                            }
                                        //Override slope clipping for this one frame
                                        gravity_slope = 0
                                        xcompass = 0                        //Override current tile compass direction
                                        tile_check_slope_priority = 0       //Slope Priority For Flat Surface Running
                                        tile_surface_wall_xcompass = 0      //Tile Compass For Flat Surface Running
                                    }
        
                                //========Exit Conditions========//
        
                                //Exit Conditions For Rolling
                                if abs(hsp) &lt; dec and joy_input[0,1] = 1    //Holding down after stopping
                                or abs(hsp) &lt; dec and joy_input[0,1] = 0    //Stopping after slowing down
                                    {
                                        attack[0] = 0;
                                        carol_roll_lock = 1;
                                        if gravity_speed != 0 anim_current=anim_jump;
                                        jump_lock      = 0 //Reset Jump Lock
                                        joy_input[2,4] = 0 //Reset Jump Button Lock
                                    }
                                if (carol_roll_timer &gt; 31 and abs(hsp) &lt; 2)
                                or (abs(hsp) &gt; 0 and abs(hsp) &lt; 2)
                                or wall_collision_left  = 1                 //Stopping after hitting a wall
                                or wall_collision_right = 1                 //Stopping after hitting a wall
                                or tile_collision_ceiling = 1
                                    {
                                        attack[0] = 0;
                                        carol_roll_lock = 1;
                                        if gravity_speed = 0 anim_current=anim_walking;
                                        else          anim_current=anim_jump;
                                        jump_lock      = 0 //Reset Jump Lock
                                        joy_input[2,4] = 0 //Reset Jump Button Lock
                                    }
                                if ground=0 and above_water = 0           //Stopping after rolling off the ground underwater
                                or carol_special_key_lock = 1
                                    {
                                        anim_current=anim_swimming
                                        //Modify animation frame position so it starts the animation;
                                        //more persistent animations, such as rolling, will refuse to
                                        //relingquish control otherwise
                                        frame = anim_carol[anim_current,0]
                                        attack[0] = 0;
                                        carol_roll_lock = 1;
                                        jump_lock                   = 0 //Reset Jump Lock
                                        joy_input[2,4]              = 0 //Reset Jump Button Lock
                                    }
                                //Golden Claw Attack
                                if (joy_input[2,5] = 1)
                                    {
                                        //Ground Attack
                                        carol_crouch_leap_switch = 0;
                                        anim_current=anim_carol_goldenclaws;
                                        carol_attack_frame=0;
                                        carol_attack_frame_repeat=12;
                                        carol_action_distance=-16
                                        //Iterate Attack State
                                        attack[0]  = 1                      //Set Attack State
                                        attack[1]  = 0                      //Increment Attack Stage
                                        attack_range = 72                   //Horizontal Hitbox Range
                                        attack_width = 90                   //Angular Hitbox Range
                                        travel_length = 0                   //Horizontal offset for Hitbox
                                        travel_height = 0                   //Vertical offset for Hitbox
                                        attack_shape  = 0                   //Shape of the hitbox (Elliptical)
                                        attack_offset = 0                   //Attack offset
                                        jump_lock      = 0                  //Reset Jump Lock
                                        joy_input[2,4] = 0                  //Reset Jump Button Lock
                                        //Modify animation frame position so it starts the animation;
                                        //more persistent animations, such as rolling, will refuse to
                                        //relingquish control otherwise
                                        frame = anim_carol[anim_current,0]
                                        //Play Voice Sample
                                        audio_play_sound(carol_gold_claws,50,false);
                                    }
                            }

                        //Wild Kicks Attack//
                        //----------------//
                        if (attack[0] = 0 and anim_current!=anim_hurt and carol_special_key_lock = 1 and anim_current!=anim_carol_wildclaws and bike = 0
                        and anim_current!=anim_carol_wall_jump and stamina &gt; 10)
                        //Conditions for performing the wildclaws attack while on the bike
                        or (attack[0] = 0 and anim_current!=anim_hurt and carol_special_key_lock = 1 and anim_current!=anim_carol_wildclaws and bike = 1 and ground = 0
                        and anim_current!=anim_carol_wall_jump and stamina &gt; 10)
                            {
                                anim_current=anim_carol_wildclaws
                                //Iterate Attack State
                                attack[0] = 1                   //Set Attack State
                                attack[1] = 0                   //Reset Attack Stage
                                attack_range = 72               //Horizontal Hitbox Range
                                attack_width = 90               //Angular Hitbox Range
                                travel_length = 0               //Horizontal offset for Hitbox
                                travel_height = 0               //Vertical offset for Hitbox
                                attack_shape  = 0               //Shape of the hitbox (Elliptical)
                                attack_offset = 0               //Vertical offset for Hitbox
                                carol_stamina_count=stamina-32  //Stamina Counter
                                carol_stamina_drain=stamina     //Stamina Drain Counter
                                carol_wildclaws_stage=0         //Set Wildclaws Stage
                                carol_attack_frame_repeat=4     //Set Wildclaws Loop Point
                                carol_action_distance=32        //Set Wildclaws Attack Sprites Offset
                                invuln_hud_acti = 1             //Set Invulnerability
                                carol_roll_lock = 1             //Disable Roll Attack
                                if spring_timer &gt; 0
                                    {
                                        if spring_rotate = 45
                                        or spring_rotate = 135
                                        or spring_rotate = 225
                                        or spring_rotate = 315
                                            {
                                                fling_timer = floor(spring_timer/3)
                                                fling_hsp = hsp
                                            }
                                        fling_ver_timer = floor(spring_timer/3)
                                        fling_vsp = gravity_speed
                                        spring_timer = -1
                                    }
                                hurt[0] = 0
                                hurt[1] = 0
                                hurt[2] = 0
                                hurt[3] = 0
                                //If stamina is less than 0, reset stamina value to 0
                                if carol_stamina_count &lt; 0 carol_stamina_count = 0;
                                if alt_skin = 0
                                    {
                                        var voice_sample = random_range(0,1.9)
                                        switch(floor(voice_sample))
                                            {
                                                case 0: {audio_play_sound(carol_wildclaws_1,50,false); break;}
                                                case 1: {audio_play_sound(carol_wildclaws_2,50,false); break;}
                                            }
                                    }
                                else
                                    {
                                        var voice_sample = random_range(0,1.9)
                                        audio_stop_sound(snd_carrie_wild_kick_1)
                                        audio_stop_sound(snd_carrie_wild_kick_2)
                                        switch(floor(voice_sample))
                                            {
                                                case 0: {audio_play_sound(snd_carrie_wild_kick_1,50,false); break;}
                                                case 1: {audio_play_sound(snd_carrie_wild_kick_2,50,false); break;}
                                            }
                                        audio_play_sound(carol_wildkick_attack,50,false)
                                    }
                            }
                        //Deceleration
                        if anim_current=anim_carol_wildclaws
                            {
                                //============Jumping============//

                                if bike = 1 and bike_jump_roll = 1
                                    {
                                        bike_jump_roll = 0
                                        //Initialize Animation Frames
                                        skid_animation_frame[0] = -2  skid_animation_frame[1] = -3
                                        skid_animation_frame[2] = -4  skid_animation_frame[3] = -5
                                        skid_animation_frame[4] = -6  skid_animation_frame[5] = -7
                                        skid_animation_frame[6] = -8  skid_animation_frame[7] = -9
                                        skid_animation_frame[8] = -10 skid_animation_frame[9] = -11
                                        //Enable Skid Particles
                                        skidding_override = 1;
                                    }
                                //If we were on a slope, influence the jump speed based on angle
                                if ground = 1 and carol_jump_press = 1
                                    {
                                        //Determine the general direction of the jump by the player's X/Y coordinates
                                        var jump_length_x = lengthdir_x(gravity_jump,tile_angle+90)
                                        var jump_length_y = lengthdir_y(gravity_jump,tile_angle+90)
                                        //Determine the additional speed of the jump by another orbit
                                        var speed_length_y = lengthdir_y(hsp,tile_angle)
                                        //Apply horizontal and vertical speed to the player based on the difference
                                        hsp           = jump_length_x+hsp
                                        gravity_speed = jump_length_y+speed_length_y
                                        //Disable jump lock and timer
                                        carol_jump_lock  = 0
                                        carol_jump_timer = 0
                                        //Set fling timer to prevent the player from overriding their horizontal speed
                                        if xcompass != 0 and not (angle_a &lt;= 90 and xdir=-1) and not (angle_a &gt;= 270 and xdir=1)
                                            {
                                                hsp = jump_length_x;
                                                fling_timer = 8;
                                                fling_hsp=hsp;
                                            }
                                        //If we were jumping off of a flat wall, reset direction of gravity speed
                                        if (tile_angle = 270 and xdir = -1) or (tile_angle = 90 and xdir = 1)
                                            {
                                                fling_ver_timer = 8
                                                fling_vsp = -abs(jump_length_y+speed_length_y)
                                            }
                                        if (tile_angle = 270 and xdir = 1 or tile_angle = 90 and xdir = -1)
                                            {
                                                fling_ver_timer = 8
                                                fling_vsp = abs(jump_length_y+speed_length_y)
                                            }
                                        //Override slope clipping for this one frame
                                        gravity_slope = 0
                                        ground = 0
                                        xcompass = 0                        //Override current tile compass direction
                                        tile_check_slope_priority = 0       //Slope Priority For Flat Surface Running
                                        tile_surface_wall_xcompass = 0      //Tile Compass For Flat Surface Running
                                    }

                                //============Stamina============//

                                if user_turbo_mode = 0
                                    {
                                        //Drain Stamina
                                        stamina-=1.5
                                        //Decrement Stamina From Stamina Bar
                                        if carol_stamina_drain &gt; carol_stamina_count carol_stamina_drain-=1.5;
                                    }
                                else
                                    {
                                        //Drain Stamina
                                        stamina-=0.75
                                        //Decrement Stamina From Stamina Bar
                                        if carol_stamina_drain &gt; carol_stamina_count carol_stamina_drain-=0.75;
                                    }
                                
                                //============Friction============//
                                if ground = 1
                                    {
                                        if user_turbo_mode = 0
                                            {
                                                //Left
                                                if hsp &lt; -1.6 hsp += dec;
                                                //Right
                                                if hsp &gt; 1.6 hsp -= dec;
                                            }
                                        else
                                            {
                                                //Left
                                                if hsp &lt; -3.2 hsp += dec;
                                                //Right
                                                if hsp &gt; 3.2 hsp -= dec;
                                            }
                                    }
                                acc_time=0;
        
                                //===========End Attack===========//
                                //Disable attack if we have run out of stamina
                                if (stamina &lt;= 0) or (stamina &gt; 0 and carol_stamina_drain&lt;=carol_stamina_count and joy_input[1,3] = 0)
                                    {
                                        anim_current = anim_standing; //Standing Animation
                                        attack[0] = 0                 //Reset Attack State
                                        invuln_hud_acti = 0           //Disable Invulnerability
                                        //Stop Sound Effect
                                        audio_stop_sound(carol_wildkick_attack)
                                    }
                                //Allow attack to loop if we still have stamina, and play a sound effect
                                if stamina &gt; 0 and carol_stamina_drain&lt;=carol_stamina_count and joy_input[1,3] = 1
                                    {
                                        if not audio_is_playing(carol_wildkick_attack) audio_play_sound(carol_wildkick_attack,50,false);
                                    }
                            }

                        //Wall Jumping//
                        //------------//
                        //Check wall collision sensors
                        if above_water = 1 and anim_current!=anim_carol_wildclaws and anim_current!=anim_hurt and fling_timer = 0 and fling_ver_timer = 0
                            {
                                if ((wall_collision_left  = 1 and xdir=-1) and joy_input[0,2] = 1 and joy_input[0,0] = 0 and joy_input[1,2] = 0 and ground = 0)
                                or ((wall_collision_right = 1 and xdir= 1) and joy_input[0,2] = 0 and joy_input[0,0] = 1 and joy_input[1,2] = 0 and ground = 0)
                                    {
                                        //Iterate Timer
                                        if carol_wall_jump_sound &lt; 8 carol_wall_jump_sound +=1;
                                        //Play Sound Effect
                                        if carol_wall_jump_sound = 1
                                            {
                                                if bike = 0
                                                    {
                                                        audio_play_sound(carol_wall_clipping,50,false)
                                                        //Initialize Animation Frames
                                                        skid_animation_frame[0] = -2  skid_animation_frame[1] = -3
                                                        skid_animation_frame[2] = -4  skid_animation_frame[3] = -5
                                                        skid_animation_frame[4] = -6  skid_animation_frame[5] = -7
                                                        skid_animation_frame[6] = -8  skid_animation_frame[7] = -9
                                                        skid_animation_frame[8] = -10 skid_animation_frame[9] = -11
                                                    }
                                                else
                                                    {
                                                        if anim_current!=anim_carol_wall_jump audio_play_sound(carol_bike_land,50,false);
                                                    }
                                                //Set Override Bike Speed
                                                bike_gravity_speed = gravity_speed
                                            }
                                        if carol_wall_jump_sound = 7
                                            {
                                                hurt[0] = 0
                                                hurt[1] = 0
                                                hurt[2] = 0
                                                hurt[3] = 0
                                            }
                                        //Set Animation
                                        anim_current=anim_carol_wall_jump
                                    }
                                else
                                    //Reset Iteration Timer
                                    carol_wall_jump_sound = 0
                                //Wall Jump Control Phase
                                if anim_current=anim_carol_wall_jump
                                    {
                                        //Reduce gravity cap for the wall jump
                                        if gravity_speed &gt; 4 and bike = 0 gravity_speed = 4;
                                        if gravity_speed &gt; 0 and bike = 1 gravity_speed = 0;
                                        if bike_gravity_speed &gt; 4 bike_gravity_speed = 4;
                                        //Keep facing direction towards the wall
                                        if wall_collision_left = 1 and xdir=-1
                                            {
                                                //Face left
                                                xdir=-1
                                                //Modify skid particle offsets
                                                skid_animation_offset_x = -12
                                                skid_animation_offset_y = -2
                                            }
                                        if wall_collision_right = 1 and xdir = 1
                                            {
                                                //Face right
                                                xdir=1
                                                //Modify skid particle offsets
                                                skid_animation_offset_x = 12
                                                skid_animation_offset_y = -2
                                            }
                                        //Jump upwards if the jump key is pressed
                                        if carol_jump_press = 1
                                            {
                                                anim_current=anim_carol_wall_jump_2
                                                if alt_skin = 0
                                                    audio_play_sound(carol_wall_jump,50,false);
                                                else
                                                    audio_play_sound(snd_carrie_wall_jump,50,false);
                                            }
                                        //Drive up the wall if we are on the bike
                                        if bike = 1
                                            {
                                                if (xdir =  1 and joy_input[0,0] = 1 and joy_input[0,2] = 0
                                                or xdir = -1 and joy_input[0,0] = 0 and joy_input[0,2] = 1)
                                                    {
                                                        py += bike_gravity_speed
                                                        gravity_speed = 0
                                                        bike_gravity_speed -= 0.3
                                                        if bike_jump_roll &gt; 0
                                                            {
                                                                //Initialize Animation Frames
                                                                skid_animation_frame[0] = -2  skid_animation_frame[1] = -3
                                                                skid_animation_frame[2] = -4  skid_animation_frame[3] = -5
                                                                skid_animation_frame[4] = -6  skid_animation_frame[5] = -7
                                                                skid_animation_frame[6] = -8  skid_animation_frame[7] = -9
                                                                skid_animation_frame[8] = -10 skid_animation_frame[9] = -11
                                                                //Enable Skid Particles
                                                                skidding_override = 1;
                                                                bike_attack_sprite_frame = 0
                                                                bike_jump_roll = 0
                                                            }
                                                        if bike_gravity_speed &lt; -8 bike_gravity_speed = -8;
                                                        if audio_is_playing(carol_bike_idle) and bike_gravity_speed &lt; -2 audio_stop_sound(carol_bike_idle);
                                                        //Start engine driving sound
                                                        if not audio_is_playing(carol_bike_moving) audio_play_sound(bike_pitch,50,true);
                                                        //Modify pitch of driving sound based on speed
                                                        audio_sound_pitch(bike_pitch,abs(bike_gravity_speed)/3)
                                                    }
                                                //Decelerate the bike while nothing is pressed
                                                if joy_input[0,0] = 0 and joy_input[0,2] = 0
                                                    {
                                                        py += bike_gravity_speed
                                                        bike_gravity_speed += 0.3
                                                        if tile_collision_ceiling = 1 py += 1;
                                                    }
                                                //If we have touched a ceiling, disable further upward movement
                                                if tile_collision_ceiling = 1 
                                                    {
                                                        gravity_speed = 0;
                                                        bike_gravity_speed = 0;
                                                    }
                                            }
                                    }
                                //Perform A Jump
                                if (anim_current=anim_carol_wall_jump or anim_current=anim_carol_wall_jump_2) and carol_jump_press = 1
                                    {
                                        gravity_speed = -7
                                        if potion_feather_timer &gt; 0
                                            {
                                                gravity_speed -= 1.4
                                            }
                                        if bike = 0
                                            {
                                                fling_hsp = 2*-xdir
                                                hsp=fling_hsp
                                                fling_timer=1
                                                if wall_collision_left = 1 and joy_input[0,2] = 1 and joy_input[0,0] = 0
                                                if wall_collision_right = 1 and joy_input[0,2] = 0 and joy_input[0,0] = 1
                                                    {
                                                        fling_hsp = 0.25*-xdir
                                                        hsp=fling_hsp
                                                    }
                                            }
                                        else
                                            {
                                                bike_jump_speed=6*-xdir;
                                                bike_jump_trigger = 1;
                                                anim_current=anim_jump
                                                if tile_collision_ceiling = 1
                                                    {
                                                        bike_fling_speed=0;
                                                        //bike_jump_trigger = 0;
                                                        gravity_speed = 2;
                                                        anim_current=anim_falling;
                                                    }
                                            }
                                    }
                                if anim_current=anim_carol_wall_jump_2 and joy_input[1,2] = 0 anim_current=anim_falling;
                                //Wall Jump Exit Conditions
                                if (anim_current=anim_carol_wall_jump) and
                                    (
                                        (   wall_collision_left  = 1 and joy_input[0,2] = 0 and ground = 0 and bike = 0)
                                        or (wall_collision_right = 1 and joy_input[0,0] = 0 and ground = 0 and bike = 0)
                                        or (joy_input[0,2] = 0 and joy_input[0,0] = 0 and ground = 0 and bike = 0)
                                        or (wall_collision_left = 0 and wall_collision_right = 0
                                        and tile_wall_trigger_l = 0 and tile_wall_trigger = 0)
                                    )
                                    {
                                        anim_current=anim_falling
                                        carol_wall_jump_lock_timer = 0
                                        //Fling the bike upwards if we rose above a wall
                                        if bike = 1 and bike_gravity_speed &lt; 0 and gravity_speed &lt;= 0
                                            {
                                                gravity_speed = bike_gravity_speed;
                                                bike_fling_speed = bike_gravity_speed
                                                fling_timer = 4
                                                fling_hsp=2*xdir
                                                if tile_collision_ceiling = 1 and gravity_speed&lt;0
                                                    {
                                                        gravity_speed = 0
                                                        bike_fling_speed = 0
                                                    }
                                            }
                                        //Declip from wall if we have fallen off of it, or moved in the opposite direction from the wall
                                        if (bike = 1 and gravity_speed &gt;= 0 or bike_gravity_speed &gt;= 0)
                                        and (joy_input[0,2] = 0 and joy_input[0,0] = 0)
                                        or spring_timer &gt; 0
                                            {
                                                gravity_speed = 0
                                                bike_gravity_speed = 0
                                                bike_fling_speed = 0
                                                fling_timer = 0
                                                fling_hsp=0
                                            }
                                        //Disable bike gravity_speed
                                        bike_gravity_speed = 0
                                    }
                                //Push the player away from the wall if they have pressed a direction opposite of the wall
                                if (
                                        bike = 1 and anim_current=anim_carol_wall_jump and ground=0
                                        and (joy_input[0,2] = 1 and joy_input[0,0] = 1 and (wall_collision_right = 1 or wall_collision_left = 1))
                                        or (joy_input[0,2] = 1 and joy_input[0,0] = 0 and wall_collision_right = 1 and ground = 0)
                                        or (joy_input[0,2] = 0 and joy_input[0,0] = 1 and wall_collision_left = 1 and ground = 0)
                                    )
                                    {
                                        anim_current=anim_jump
                                        carol_wall_jump_lock_timer = 0
                                        if bike = 1 and bike_gravity_speed &lt; 0 bike_fling_speed = bike_gravity_speed;
                                        ground = 0
                                        if joy_input[0,0] = 1 xdir = 1;
                                        if joy_input[0,2] = 1 xdir = -1;
                                        fling_timer = 2
                                        fling_hsp=2*xdir
                                    }
                                if anim_current=anim_carol_wall_jump and (ground = 1 or gravity_slope = 1) and gravity_ceiling = 0
                                    {
                                        anim_current=anim_standing
                                        carol_wall_jump_lock_timer = 0
                                        gravity_speed = bike_gravity_speed
                                        bike_gravity_speed = 0
                                    }
                            }
        
                        //==============Carol's Bike==============//
        
                        //    Boosting    //
                        //----------------//
        
                        //If we are on the ground, and the user is pressing the special key, boost forward
                        if carol_special_key_lock = 1 and bike = 1 and (ground = 1 or anim_current = anim_carol_wall_jump) and bike_boost_trigger = 0
                        and anim_current != anim_looking_up and anim_current != anim_ducking and anim_current!=anim_carol_wildclaws and
                        ((joy_input[0,0] &gt; 0 and joy_input[0,2] = 0 or joy_input[0,2] &gt; 0 and joy_input[0,0] = 0) or anim_current=anim_wall_pushing or bike_gravity_speed != 0)
                            {
                                //Play Sound
                                audio_play_sound(carol_bike_boost,50,false)
                                //If we are on the ground, boost forward based on direction
                                if ground = 1
                                    {
                                        if user_turbo_mode = 0 hsp = 10*xdir;
                                        else                   hsp = 12*xdir;
                                    }
                                //If we are on a wall, boost upward
                                if anim_current = anim_carol_wall_jump bike_gravity_speed = -8;
                                if tile_collision_ceiling = 1 bike_gravity_speed = 0.3;
                                //Set stamina drain amount
                                carol_stamina_count=stamina-22.75  //Stamina Counter
                                carol_stamina_drain=stamina        //Stamina Drain Counter
                                carol_action_distance=22.75        //Set Wildclaws Attack Sprites Offset
                                //If stamina is less than 0, reset stamina value to 0
                                if carol_stamina_count &lt; 0 carol_stamina_count = 0;
                                //Set boost trigger stage
                                bike_boost_trigger = 1
                                //Setup appearance times
                                carol_particle_frame[0]   = -1 carol_particle_frame[1]  = -2  carol_particle_frame[2] = -3
                                carol_particle_frame[3]   = -4 carol_particle_frame[4]  = -5  carol_particle_frame[5] = -6
                                carol_particle_frame[6]   = -7 carol_particle_frame[7]  = -8  carol_particle_frame[8] = -9
                                carol_particle_frame[9]   = -10 carol_particle_frame[10] = -11
                                //Drag those pesky particles back if they were still active during the last boost :^P
                                carol_particle_x[0]=skid_spawn_x; carol_particle_y[0]=skid_spawn_y
                                carol_particle_x[1]=skid_spawn_x; carol_particle_y[1]=skid_spawn_y
                                carol_particle_x[2]=skid_spawn_x; carol_particle_y[2]=skid_spawn_y
                                carol_particle_x[3]=skid_spawn_x; carol_particle_y[3]=skid_spawn_y
                                carol_particle_x[4]=skid_spawn_x; carol_particle_y[4]=skid_spawn_y
                                carol_particle_x[5]=skid_spawn_x; carol_particle_y[5]=skid_spawn_y
                                carol_particle_x[6]=skid_spawn_x; carol_particle_y[6]=skid_spawn_y
                                carol_particle_x[7]=skid_spawn_x; carol_particle_y[7]=skid_spawn_y
                                carol_particle_x[8]=skid_spawn_x; carol_particle_y[8]=skid_spawn_y
                                carol_particle_x[9]=skid_spawn_x; carol_particle_y[9]=skid_spawn_y
                                //Setup angle of the first particle
                                carol_particle_angle = tile_angle
                                //Disable skid particles for the time being
                                skidding_override = 0
                            }
        
                        //Second stage of the boost
                        if bike_boost_trigger &gt;= 1
                            {
                                //============Stamina============//
                                //Drain Stamina
                                if user_turbo_mode = 0
                                    {
                                        stamina-=0.75
                                        //Decrement Stamina From Stamina Bar
                                        if carol_stamina_drain &gt; carol_stamina_count carol_stamina_drain-=0.75;
                                    }
                                else
                                    {
                                        stamina-=0.375
                                        //Decrement Stamina From Stamina Bar
                                        if carol_stamina_drain &gt; carol_stamina_count carol_stamina_drain-=0.375;
                                    }                                
                                //Use boost trigger as a timer
                                bike_boost_trigger += 1
                                //Once we have boosted for 30 frames, stop boosting and resume skid particles
                                if bike_boost_trigger &gt;= 30
                                    {
                                        bike_boost_trigger = 0;
                                        //Initialize Animation Frames
                                        skid_animation_frame[0] = -2  skid_animation_frame[1] = -3
                                        skid_animation_frame[2] = -4  skid_animation_frame[3] = -5
                                        skid_animation_frame[4] = -6  skid_animation_frame[5] = -7
                                        skid_animation_frame[6] = -8  skid_animation_frame[7] = -9
                                        skid_animation_frame[8] = -10 skid_animation_frame[9] = -11
                                        //Enable Skid Particles
                                        skidding_override = 1;
                                    }
                            }
        
                        //    Double Jump    //
                        //-------------------//
        
                        if  (((carol_jump_press = 1 and alt_skin != 1 and bike = 1 and carol_jump_confirm_key = 2)
                        or (carol_switch_button = 1 and alt_skin &gt; 0 and bike = 0 and ground = 0))
                        and attack[0] = 0
                        and bike_jump_roll = 0 and (bike = 1 or alt_skin &gt; 0) and bike_gravity_speed = 0 and above_water = 1
                        and bike_double_jump_lock = 0 and carol_hang_bar_jump = 0) and tile_surface_id[1]=-1
                        or (bike_double_jump_trigger = 1)
                            {
                                bike_jump_roll = 1
                                bike_jump_roll_speed = -5
                                if potion_feather_timer &gt; 0
                                    {
                                        bike_jump_roll_speed = -7.4
                                    }
                                bike_double_jump_lock = 1
                                anim_current   = anim_carol_bike_roll
                                gravity_friction = 1
                                //Prevent Carrie specifically from double-jumping like a bike
                                if (alt_skin != 1 and bike = 1)
                                    {
                                        audio_play_sound(carol_bike_air_dash,50,false)
                                        carol_particle_x[0]=skid_spawn_x; carol_particle_y[0]=skid_spawn_y
                                        carol_particle_frame[0]   = -1
                                        carol_particle_angle = 45*xdir
                                        if bike_gears = 1 bike_jump_roll_speed = -7;
                                        //Set stamina drain amount
                                        carol_stamina_count=stamina-9      //Stamina Counter
                                        carol_stamina_drain=stamina        //Stamina Drain Counter
                                        //If stamina is less than 0, reset stamina value to 0
                                        if carol_stamina_count &lt; 0 carol_stamina_count = 0;
                                        bike_init_timer = 0
                                    }
                                if alt_skin &gt; 0 and bike = 0
                                    {
                                        audio_play_sound(snd_carrie_jump,50,false)
                                        audio_stop_sound(carol_pounce)
                                        bike_jump_roll_speed = -7
                                    }
                                if spring_timer &gt; -1 bike_jump_roll_speed = -spring_speed;
                                spring_timer = -1
                            }
                        if bike_jump_roll &gt;= 1 and bike_jump_roll &lt;= 35
                            {
                                //============Stamina============//
                                //Drain Stamina
                                if (alt_skin = 0) or (alt_skin = 2 and bike = 1) stamina-=0.25;
                                bike_jump_roll       += 1
                                bike_jump_roll_speed += 0.18
                                gravity_speed         = bike_jump_roll_speed
                                //Iterate attack sprite frames
                                bike_attack_sprite_frame += 0.65
                                if bike_attack_sprite_frame &gt; 7.8 bike_attack_sprite_frame = 0;
                                //Override speed if we are touching a ceiling
                                if tile_collision_ceiling = 1 and gravity_speed&lt;0 {gravity_speed=0 bike_jump_roll_speed=0}
                                //Disable triggering the double jump from a gas can on the ground
                                if ground = 0 bike_double_jump_trigger = 0;
                            }
                        //Disable double jump animation
                        if bike_jump_roll &gt; 35
                        or (anim_current = anim_carol_wall_jump and bike_jump_roll &gt; 0)
                        or (ground = 1 and bike_jump_roll &gt; 0 and bike_double_jump_trigger = 0)
                            {
                                bike_jump_roll = 0
                                if anim_current != anim_carol_wildclaws
                                    anim_current = anim_falling
                                //Initialize Animation Frames
                                skid_animation_frame[0] = -2  skid_animation_frame[1] = -3
                                skid_animation_frame[2] = -4  skid_animation_frame[3] = -5
                                skid_animation_frame[4] = -6  skid_animation_frame[5] = -7
                                skid_animation_frame[6] = -8  skid_animation_frame[7] = -9
                                skid_animation_frame[8] = -10 skid_animation_frame[9] = -11
                                //Enable Skid Particles
                                skidding_override = 1;
                            }
                    }//End of ladder safety check
        
                //Bike Boost Particle System
                //Iterate Particle Animation Frames
                if carol_particle_frame[0]!=-128 carol_particle_frame[0]+=0.65;
                //Particle Animation Frames 1
                if (floor(carol_particle_frame[0])=0) {carol_particle_x[0]=skid_spawn_x; carol_particle_y[0]=skid_spawn_y;}
                //Disable animation of particles
                if carol_particle_frame[0]&gt;12.8 carol_particle_frame[0] = -128;
                var carol_count = 1;
                while(carol_count &lt; 10)
                    {
                        if carol_particle_frame[carol_count]!=-128
                            carol_particle_frame[carol_count]+=0.40;
                        if (floor(carol_particle_frame[carol_count])=0)
                            {
                                carol_particle_x[carol_count]=skid_spawn_x;
                                carol_particle_y[carol_count]=skid_spawn_y;
                            }
                        //Disable animation of particles
                        if carol_particle_frame[carol_count]&gt;12.8 carol_particle_frame[carol_count] = -128;
                        carol_count += 1
                    }
        
                //  End of Attack Animations  //
                //----------------------------//
                
                //If we have completed an attack animation, end the attack animation and return to standing
                if (anim_current=anim_carol_attack_1
                or  anim_current=anim_carol_attack_2
                or  anim_current=anim_carol_attack_3
                or  anim_current=anim_carol_attack_4
                or  anim_current=anim_carol_attack_5
                or  anim_current=anim_carol_goldenclaws
                or  anim_current=anim_carol_attack_boot_swipe
                or  anim_current=anim_carol_attack_jump_kick
                or  anim_current=anim_carol_attack_claw_swipe
                or  anim_current=anim_carol_attack_super_wild_claw)
                and (frame &gt;= anim_carol[anim_current,1])
                    {
                        if anim_current=anim_carol_attack_claw_swipe
                            anim_current=anim_ducking;
                        else
                            anim_current = anim_standing;
                        attack[0] = 0                 //Reset Attack State
                    }
                //If the attack state variable did not clear for some reason, clean it
                if bike = 0 and attack[1] &gt;= 5 attack[1] = 0;
                if bike = 1 and attack[1] &gt;= 4 attack[1] = 0;
                if attack[0]  = 1 and anim_current=anim_standing attack[0] = 0;
                //Loop bike init animation if we have landed on the bike
                if bike_init_timer &gt; 0
                    {
                        //Disable bike init animation if any inputs are made, or we are double jumping
                        if anim_current = anim_carol_bike_roll
                        or joy_input[0,0] = 1
                        or joy_input[0,1] = 1
                        or joy_input[0,2] = 1
                        or joy_input[0,3] = 1
                        or joy_input[1,0] = 1
                        or joy_input[1,2] = 1
                            bike_init_timer = 0;
                        anim_current = anim_carol_bike_init
                        bike_init_timer -= 1
                        attack[0] = 0
                        attack[1] = 0
                    }
                //If the player was wall jumping while the water's level rose, disable the wall jump animation
                if above_water = 0 and anim_current=anim_carol_wall_jump anim_current=anim_swimming;
        }//End of freeze frame check

        //Allow animation system to play during freeze-frames
        if pause = 0 and user_cursor_mode = 0
            {
                //          Animation System Core          //
                //=========================================//
        
                //Make sure we aren't dead, before allowing normal animations
                if death[0] = 0 and not (targets_ready = 3 and ground = 1)
                    {
                        //---Character Sprites---//
                        //-----------------------//
                        
                        if gravity_rail_check = 1 and attack[0] = 0
                            {
                                anim_current = anim_carol_rail_grinding;
                                if above_water = 0 and ground = 0
                                    {
                                        anim_current = anim_swimming
                                        scr_set_rail_grinding_stop()
                                    }
                            }
                        //Perpetually advance frames based on provided speed,
                        //if we are not using aerial attacks
                        if  anim_current!=anim_ladder_climbing
                        and anim_current!=anim_swimming
                        and anim_current!=anim_carol_rolling
                        and anim_current!=anim_spring
                        and anim_current!=anim_faster
                            frame += anim_carol[anim_current,3]
                        //If a new animation has started, initialize the new animation
                        if anim_previous!=anim_current
                            {
                                frame = anim_carol[anim_current,0]  //Set starting frame of animation
                                anim_previous=anim_current          //Disable triggered breakpoint
                            }
                
                        //---Attack Sprites---//
                        //--------------------//
                        
                        //---Basic Attacks---//
                        if anim_current=anim_carol_attack_1
                        or anim_current=anim_carol_attack_2
                        or anim_current=anim_carol_attack_3
                        or anim_current=anim_carol_attack_4
                        or anim_current=anim_carol_attack_5
                        or anim_current=anim_carol_goldenclaws
                            //Iterate animation frames
                            carol_attack_frame+=0.75;
                        //Set rotation axis for attack sprites
                        action_offset_x = px + lengthdir_x(carol_action_distance,angle_a+90)
                        action_offset_y = py + lengthdir_y(carol_action_distance,angle_a+90)
                
                        //---Wild Claws Attack---//
                        if anim_current=anim_carol_wildclaws
                        or anim_current=anim_carol_attack_super_wild_claw
                            {
                                //Iterate animation frames
                                carol_attack_frame+=0.75;
                                //Reset animation frames once loop point is reached
                                if carol_attack_frame &gt; carol_attack_frame_repeat+0.9
                                    {
                                        carol_attack_frame=0
                                        carol_wildclaws_stage += 1
                                        //Set loop point
                                        switch(carol_wildclaws_stage)
                                            {
                                                case 0: {carol_attack_frame_repeat=4; carol_action_distance=40; break;}
                                                case 1: {carol_attack_frame_repeat=3; carol_action_distance=48; break;}
                                                case 2: {carol_attack_frame_repeat=4; carol_action_distance=40; break;}
                                                case 3: {carol_attack_frame_repeat=4; carol_action_distance=40; carol_wildclaws_stage = 0; break;}
                                            }
                                    }
                            }
                
                        //============Speed Modifiers============//
                
                        //If we are bouncing on a spring, increase animation
                        //speed based on a timer
                        if anim_current=anim_spring
                            {
                                frame += spring_anim_mod*1.67
                                //Decrement animation modifier
                                if spring_anim_mod &gt; 0.16 spring_anim_mod -= 0.025;
                                //End springing animation if it hasn't already
                                if spring_timer=-1 anim_current=anim_falling;
                            }
                        //If we are rolling, accelerate animation speeds
                        //based on the player's movement speed
                        if anim_current=anim_carol_rolling frame += 0.15+abs(hsp/16);
                        if anim_current=anim_faster
                            {
                                if alt_skin = 0 frame += 0.05+abs(hsp/16);
                                else            frame += 0.15+abs(hsp/16);
                            }
                
                        //============Special Actions============//
                
                        //Key Release for Wall Pushing Animation
                        //(Only works below everything else. It took me two days to figure this one out. :^P)
                        if (anim_current=anim_wall_pushing and hsp!=0 and ground=1)
                        or (anim_current=anim_wall_pushing and joy_input[0,0] = 0 and joy_input[0,2] = 0 and ground=1)
                        or (anim_current=anim_wall_pushing and ground=0)
                            anim_current=anim_standing;
                        //If we are on a ladder, and not on the bike, animations should play forwards or in reverse based on input
                        if ladder_state = 0 and bike = 0
                            {
                                if anim_current=anim_ladder_climbing
                                    {
                                        //Keep Carol's Attack States Empty
                                        attack[0] = 0; attack[1] = 0;
                                        //Climbing up
                                        if joy_input[0,3] = 1 and joy_input[0,1] = 0 frame += anim_carol[anim_current,3];
                                        //Climbing Down
                                        if joy_input[0,3] = 0 and joy_input[0,1] = 1
                                            {
                                                frame -= anim_carol[anim_current,3]
                                                //If we are playing frames below the current animation, restart animation loop from
                                                //its endpoint instead
                                                if frame &lt; anim_carol[anim_current,0]+0.40 frame = anim_carol[anim_current,1];
                                            }
                                    }
                            }
                        //If we are on a bike, animate as normal
                        if anim_current=anim_ladder_climbing and bike = 1 frame += anim_carol[anim_current,3];
                        //Idle Animation
                        if anim_current = anim_standing
                            {
                                //Iterate idle timer
                                anim_idle_timer += 1
        
                                //If the timer has reached its limit, start the idle animation
                                if anim_idle_timer = 530 and not (alt_skin = 2 and bike = 1)
                                    {
                                        anim_current = anim_idle_1
                                        frame = anim_carol[anim_idle_1,0]
                                    }
                                //If the timer has exceeded its limit, reset the timer
                                if anim_idle_timer &gt; 530 anim_idle_timer = 0;
                            }
                        //If we have moved or attacked at all, reset iteration timer
                        if hsp!=0 or gravity_speed!=0 or attack[0]!=0 anim_idle_timer = 0;
                        //If we have reached the end of the animation, reset idle timer and return to the standing animation
                        if anim_current = anim_idle_1 and frame &gt; anim_carol[anim_idle_1,2]+0.8
                            {
                                anim_idle_timer = 0
                                anim_current = anim_standing
                            }
                        //If we are above the ending frame, restart the animation at the desired loop point
                        if frame &gt; anim_carol[anim_current,1]+0.8 frame = anim_carol[anim_current,2];
                    }
        
                //---Tail Sprites---//
                //------------------//
        
                //Determine which sprites the tail will use
                if (anim_current = anim_jump or anim_current = anim_falling)
                    {
                        carol_tail_animation_end = 5.8
                        carol_tail_sprite = spr_carols_tail_jump
                        if alt_skin &gt; 0
                            carol_tail_sprite = spr_carols_old_tail_jump;
                        if carol_tail_sprite_frame &gt; 5.8 carol_tail_sprite_frame = 0;
                    }
                //If the player is not jumping or falling, change to the idle sprite
                else
                    {
                        carol_tail_animation_end = 11.8
                        carol_tail_sprite = spr_carols_tail_idle
                        if alt_skin &gt; 0
                            carol_tail_sprite = spr_carols_old_tail_idle;
                        if carol_tail_sprite_frame &gt; 11.8 carol_tail_sprite_frame = 0;
                    }
                //If we are swimming, override the jump tail
                if above_water = 0
                    {
                        carol_tail_animation_end = 11.8
                        carol_tail_sprite = spr_carols_tail_idle
                        if alt_skin &gt; 0
                            carol_tail_sprite = spr_carols_old_tail_idle;
                        if carol_tail_sprite_frame &gt; 11.8 carol_tail_sprite_frame = 0;
                    }
                //Perpetually advance tail frames based on provided speed
                switch(anim_current)
                    {
                        //For the few animations that have tail sprites baked into the main sprite,
                        //assume they should be invisible
                        case anim_carol_rolling:   {carol_tail_sprite_frame = 12; break;}
                        case anim_death:           {carol_tail_sprite_frame = 12; break;}
                        case anim_spring:          {carol_tail_sprite_frame = 12; break;}
                        case anim_ladder_climbing: {carol_tail_sprite_frame = 12; break;}
                        case anim_carol_attack_1:  {carol_tail_sprite_frame = 12; break;}
                        case anim_carol_attack_2:  {carol_tail_sprite_frame = 12; break;}
                        case anim_carol_attack_3:  {carol_tail_sprite_frame = 12; break;}
                        case anim_carol_attack_4:  {carol_tail_sprite_frame = 12; break;}
                        case anim_carol_attack_5:  {carol_tail_sprite_frame = 12; break;}
                        case anim_carol_dancing:
                            {
                                if alt_skin = 0
                                    carol_tail_sprite_frame = 12;
                                else
                                    {
                                        carol_tail_sprite_frame += 0.2004
                                        if carol_tail_sprite_frame &gt; carol_tail_animation_end+0.8
                                            carol_tail_sprite_frame = 0;
                                        //Set rotation axis for tail sprites
                                        carol_tail_x_anchor = px + lengthdir_x(carol_tail_offset_y,angle_a+90)
                                        carol_tail_y_anchor = py + lengthdir_y(carol_tail_offset_y,angle_a+90)
                                        //Set rotation axis for tail sprites
                                        carol_tail_x = carol_tail_x_anchor + lengthdir_x(carol_tail_offset_x*xdir,angle_a)
                                        carol_tail_y = carol_tail_y_anchor + lengthdir_y(carol_tail_offset_x*xdir,angle_a)
                                    }
                                break;
                            }
                        case anim_carol_attack_boot_swipe: {carol_tail_sprite_frame = 12; break;}
                        case anim_carol_attack_jump_kick:  {carol_tail_sprite_frame = 12; break;}
                        case anim_carol_attack_claw_swipe: {carol_tail_sprite_frame = 12; break;}
                        case anim_carol_bike_roll:         {carol_tail_sprite_frame = 12; break;}
                        case anim_hurt:                    {carol_tail_sprite_frame = 12; break;}
                        case anim_faster:
                            {
                                if alt_skin = 0
                                    carol_tail_sprite_frame = 12;
                                else
                                    {
                                        carol_tail_sprite = spr_carols_old_tail_idle;
                                        carol_tail_sprite_frame += 0.65
                                        if carol_tail_sprite_frame &gt; carol_tail_animation_end+0.8
                                            carol_tail_sprite_frame = 0;
                                        //Set rotation axis for tail sprites
                                        carol_tail_x_anchor = px + lengthdir_x(carol_tail_offset_y,angle_a+90)
                                        carol_tail_y_anchor = py + lengthdir_y(carol_tail_offset_y,angle_a+90)
                                        //Set rotation axis for tail sprites
                                        carol_tail_x = carol_tail_x_anchor + lengthdir_x(carol_tail_offset_x*xdir,angle_a)
                                        carol_tail_y = carol_tail_y_anchor + lengthdir_y(carol_tail_offset_x*xdir,angle_a)
                                    }
                                break;
                            }
                        case anim_carol_sitting:           {carol_tail_sprite_frame = 12; break;}
                        case anim_carol_goldenclaws:       {carol_tail_sprite_frame = 12; break;}

                        //In every other case, the tail should be animated
                        default:
                            {
                                carol_tail_sprite_frame += 0.2004
                                //Reset Tail Animations After They Have Completed
                                if carol_tail_sprite_frame &gt; carol_tail_animation_end+0.8 and carol_tail_sprite = spr_carols_tail_idle
                                    carol_tail_sprite_frame = 0;
                                //Freeze animation if we were animating the jump tail
                                if carol_tail_sprite_frame &gt; carol_tail_animation_end and 
                                    (carol_tail_sprite = spr_carols_tail_jump
                                or
                                    carol_tail_sprite = spr_carols_old_tail_jump)
                                    carol_tail_sprite_frame = carol_tail_animation_end;
                                //Set rotation axis for tail sprites
                                carol_tail_x_anchor = px + lengthdir_x(carol_tail_offset_y,angle_a+90)
                                carol_tail_y_anchor = py + lengthdir_y(carol_tail_offset_y,angle_a+90)
                                //Set rotation axis for tail sprites
                                carol_tail_x = carol_tail_x_anchor + lengthdir_x(carol_tail_offset_x*xdir,angle_a)
                                carol_tail_y = carol_tail_y_anchor + lengthdir_y(carol_tail_offset_x*xdir,angle_a)
        
                                //-----------------------------------------//
                                //Modify offsets of tail based on animation//
                                //-----------------------------------------//
                                
                                //Wall Jump
                                if anim_current = anim_carol_wall_jump
                                    {
                                        carol_tail_offset_x         = 4
                                        carol_tail_offset_y         = 20
                                    }
                                //Cover most other cases the lazy way. :^P
                                else
                                    {
                                        carol_tail_offset_x         = -4
                                        carol_tail_offset_y         = 18
                                    }
                                //We'll deal with the other exceptional cases here
                                if anim_current = anim_hanging_idle
                                    {
                                        carol_tail_offset_x         = -6
                                        carol_tail_offset_y         = 14
                                    }
                                if anim_current = anim_ducking
                                    {
                                        carol_tail_offset_x         = -8
                                        carol_tail_offset_y         = 13
                                    }
                                if anim_current = anim_skidding
                                    {
                                        carol_tail_offset_x         = 8
                                        carol_tail_offset_y         = 18
                                    }                        
                                break;
                            }
                    }
                //Modify tail's facing direction based on which animations are playing 
                if anim_current = anim_skidding carol_tail_dir = -xdir;
                else                            carol_tail_dir = xdir;
        
                //===========Death Animation===========//
        
                //If we have died, override normal animations
                if death[0] = 1
                    {
                        //Disable FOF collisions
                        tile_surface_id[5] = 0
                        tile_surface_asset = 0
                        //Disable the bike
                        bike = 0
                        //Stay on this frame of animation while we are not touching the ground
                        if ground = 0 frame = anim_carol[anim_death,0];
                        //Complete the animation once we are
                        if ground = 1
                            {
                                if frame &lt; anim_carol[anim_death,0] frame = anim_carol[anim_death,0];
                                if frame &lt; anim_carol[anim_death,1] frame += anim_carol[anim_current,3];
                            }
                    }
        
                //==========Victory Animation==========//
        
                //If we have landed after breaking all the targets, trigger the victory animation
                if targets_ready = 3 and ground = 1
                    {
                        if bike = 0
                            {
                                //Set the current animation frame to the beginning of the animation, if it wasn't before
                                if frame &lt; anim_carol[anim_victory,0] frame = anim_carol[anim_victory,0];
                                //Play the animation to the end
                                if frame &lt; anim_carol[anim_victory,1] frame += anim_carol[anim_victory,3];
                            }
                        //Hard-coded fix for Carol's bike
                        else
                            {
                                //Set the current animation frame to the beginning of the animation, if it wasn't before
                                if frame &lt; 170 frame = 170;
                                //Play the animation to the end
                                frame += 0.668; if frame &gt; 171.8 frame = 170;  
                            }
                    }

                //Block-Pushing Animations
                if xcompass = 0 and ground = 1 and attack[0]=0 and gravity_rail_check = 0
                    scr_set_block_pushing();

                //If we are swimming, accelerate animation speeds
                //based on the player's movement speed
                if above_water = 0
                    {
                        if gravity_rail_check = 0 and anim_current = anim_carol_rail_grinding
                            {
                                if hsp = 0 anim_current = anim_standing;
                                else       anim_current = anim_walking;
                                scr_set_rail_grinding_stop();
                            }
                        var sink_yes = 0;
                        if instance_exists(water_ID)
                            {
                                if water_ID.object_index = obj_mud_cube
                                or water_ID.object_index = obj_mud_water
                                    {
                                        sink_yes = 1;
                                        if ground = 0 and Animations_Override = 0 and attack[0]=0
                                        and hurt[0] = 0 and gravity_ladder = 0
                                        and anim_current != anim_falling
                                            anim_current = anim_falling;
                                    }
                            }
                        if ground = 0 and Animations_Override = 0 and attack[0]=0
                        and hurt[0] = 0 and gravity_ladder = 0
                        and sink_yes = 0
                            {
                                var anim_swim_speed = abs(hsp/24);
                                if hsp &gt; -dec and hsp &lt; dec
                                    anim_swim_speed = 0.125;
                                if anim_current != anim_swimming anim_current = anim_swimming;
                                if frame &lt; anim_carol[anim_swimming,0] or frame &gt; anim_carol[anim_swimming,1]+0.8
                                    frame = anim_carol[anim_swimming,0];
                                frame += 0.15+anim_swim_speed
                                if frame &gt; anim_carol[anim_swimming,1]+0.8
                                    frame = anim_carol[anim_swimming,2];
                                //"Rest" mechanic
                                if (stamina &lt; 96) stamina += 0.2;
                            }
                    }
                if above_water = 1 and anim_current = anim_swimming
                    {
                        if ground = 1 anim_current = anim_standing;
                        else          anim_current = anim_jump;
                    }
                
                //          Active Attack Framing          //
                //=========================================//
        
                //If we are in a normal or special attack state, enable hitboxes based on frame data
                if attack[0] = 1
                    {
                        //Check which frames should have a hitbox
                        switch(anim_current)
                            {
                                //Carol Attack 1
                                case anim_carol_attack_1:
                                    {
                                        if (floor(frame)=122 or floor(frame)=123) //Normal attack
                                        or (floor(frame)=213 or floor(frame)=214) //Bike Attack
                                            {
                                                active_frame=1;
                                                action_confirm=1;
                                                action_distance = 40;
                                            }
                                        else active_frame=0;
                                        break;
                                    }
                                //Carol Attack 2
                                case anim_carol_attack_2:
                                    {
                                        if (floor(frame)=126 or floor(frame)=127) //Normal attack
                                        or (floor(frame)=219 or floor(frame)=220) //Bike Attack
                                            {
                                                active_frame=1;
                                                action_confirm=1;
                                                action_distance = 20;
                                            }
                                        else active_frame=0;
                                        break;
                                    }
                                //Carol Attack 3
                                case anim_carol_attack_3:
                                    {
                                        if (floor(frame)=130 or floor(frame)=131) //Normal attack
                                        or (floor(frame)=225 or floor(frame)=226) //Bike Attack
                                            {
                                                active_frame=1;
                                                action_confirm=1;
                                                action_distance = 40;
                                            }
                                        else active_frame=0;
                                        break;
                                    }
                                //Carol Attack 4
                                case anim_carol_attack_4:
                                    {
                                        if (floor(frame) &gt;= 286 and floor(frame) &lt;= 288) //Normal attack
                                            {
                                                active_frame=1;
                                                action_confirm=1;
                                                action_distance = 40;
                                            }
                                        else active_frame=0;
                                        break;
                                    }
                                //Carol Attack 5
                                case anim_carol_attack_5:
                                    {
                                        if (floor(frame) = 291 or floor(frame) = 292) //Normal attack
                                            {
                                                active_frame=1;
                                                action_confirm=1;
                                                action_distance = 40;
                                            }
                                        else active_frame=0;
                                        break;
                                    }
                                //Carol Wildclaws
                                case anim_carol_wildclaws:
                                    {
                                        if (floor(frame)&gt;=141 and floor(frame)&lt;=149) //Normal attack
                                        or (floor(frame)&gt;=230 and floor(frame)&lt;=237) //Bike Attack
                                            {
                                                active_frame=1;
                                                action_confirm=0;
                                            }
                                        else active_frame=0;
                                        break;
                                    }
                                //Carol Golden Claws
                                case anim_carol_goldenclaws:
                                    {
                                        if (floor(frame)=130 or floor(frame)=131) //Normal attack
                                        or (floor(frame)=225 or floor(frame)=226) //Bike Attack
                                            {
                                                active_frame=1;
                                                action_confirm=1;
                                                action_distance = 40;
                                            }
                                        else active_frame=0;
                                        break;
                                    }
                                //Carol Golden Claws
                                case anim_carol_attack_super_wild_claw:
                                    {
                                        if (floor(frame)=286 or floor(frame)=287) //Normal attack
                                            {
                                                active_frame=1;
                                                action_confirm=1;
                                                action_distance = 40;
                                            }
                                        else active_frame=0;
                                        break;
                                    }
                                //Carol Rolling
                                case anim_carol_rolling:
                                    {
                                        if floor(frame)&gt;=133 and floor(frame)&lt;=140
                                            {
                                                active_frame=1;
                                                action_confirm=0;
                                            }
                                        else active_frame=0;
                                        break;
                                    }
                                //Carol Bike Rolling
                                case anim_carol_bike_roll:
                                    {
                                        if floor(frame)&gt;=238 and floor(frame)&lt;=245
                                            {
                                                active_frame=1;
                                                action_confirm=0;
                                            }
                                        else active_frame=0;
                                        break;
                                    }
                                //Carol Bike Rolling
                                case anim_carol_attack_boot_swipe:
                                    {
                                        if floor(frame)&gt;=271 and floor(frame)&lt;=273
                                            {
                                                active_frame=1;
                                                action_confirm=0;
                                            }
                                        else active_frame=0;
                                        break;
                                    }
                                //Carol Bike Rolling
                                case anim_carol_attack_jump_kick:
                                    {
                                        if floor(frame)&gt;=276 and floor(frame)&lt;=280
                                            {
                                                active_frame=1;
                                                action_confirm=0;
                                            }
                                        else active_frame=0;
                                        break;
                                    }
                                //Carol Bike Rolling
                                case anim_carol_attack_claw_swipe:
                                    {
                                        if floor(frame)&gt;=282 and floor(frame)&lt;=284
                                            {
                                                active_frame=1;
                                                action_confirm=0;
                                            }
                                        else active_frame=0;
                                        break;
                                    }
                                //Carol Non-Attack Animations
                                default:
                                    {
                                        active_frame=0;
                                        action_confirm=0;
                                        break;
                                    }
                            }
                    }
                //Allow the bike to deal passive damage to nearby item tiles and enemies, as long as we're at the desired speed
                if (bike = 1 and ground = 1 and attack[0] = 0 and hurt[0] = 0 and (anim_current &gt; 0 and anim_current &lt;=3) and abs(hsp) &gt; 5)
                or (anim_current = anim_carol_bike_roll or bike_boost_trigger &gt; 0)
                    {
                        var enemy_ID = collision_circle(universal_player_x,universal_player_y,15,obj_enemy_parent,false,true);
                        if enemy_ID != noone and pause_logic = 0 and pause_logic_gap = 0
                            {
                                if enemy_ID.heart &gt;= 0 and enemy_ID.alpha &lt; 0.7
                                    {
                                        audio_play_sound(snd_enemy_hit,50,false)
                                        enemy_ID.attacked = 1
                                        enemy_ID.attacked_damage = 2.5
                                        pause_logic = 5;
                                    }
                            }
                        var item_ID = collision_circle(universal_player_x,universal_player_y,32,obj_destructible,false,true);
                        if item_ID != noone and pause_logic = 0 and pause_logic_gap = 0
                            item_ID.attacked = 1;
                    }
                //Otherwise, disable passive damage
                else attack[3] = 0;

                //          Animation Overrides          //
                //=======================================//

                //Enforce an override of generic animations, to avoid
                //conflicts with the generic movement system

                switch(anim_current)
                    {
                        case anim_carol_wall_jump:     {Animations_Override = 1; attack_damage = 0; jump_override = 0; skidding_override = 1; skid_spawn_x = px; skid_spawn_y = py; break;}
                        case anim_carol_attack_1:      {Animations_Override = 1; attack_damage = 3; jump_override = 0; break;}
                        case anim_carol_attack_2:      {Animations_Override = 1; attack_damage = 4; jump_override = 0; break;}
                        case anim_carol_attack_3:      {Animations_Override = 1; attack_damage = 3; jump_override = 0; break;}
                        case anim_carol_attack_4:      {Animations_Override = 1; attack_damage = 4; jump_override = 0; break;}
                        case anim_carol_attack_5:      {Animations_Override = 1; attack_damage = 3; jump_override = 0; break;}
                        case anim_carol_crouch_attack: {Animations_Override = 1; attack_damage = 0;   active_attack = 1; jump_override = 0; break;}
                        case anim_carol_wildclaws:     {Animations_Override = 1; attack_damage = 3;   active_attack = 0; jump_override = 1; break;}
                        case anim_ducking:             {Animations_Override = 1; attack_damage = 0;   active_attack = 1; jump_override = 0; break;}
                        case anim_carol_rolling:       {Animations_Override = 1; attack_damage = 2.5; active_attack = 1; jump_override = 0; break;}
                        case anim_carol_goldenclaws:   {Animations_Override = 1; attack_damage = 5; break;}
                        case anim_carol_attack_boot_swipe: {Animations_Override = 1; attack_damage = 4; break;}
                        case anim_carol_attack_jump_kick:  {Animations_Override = 1; attack_damage = 2.5; break;}
                        case anim_carol_attack_claw_swipe: {Animations_Override = 1; attack_damage = 3; break;}
                        case anim_carol_attack_super_wild_claw: {Animations_Override = 1; attack_damage = 4.5; stamina-=4; break;}
                        case anim_carol_bike_roll:     {Animations_Override = 1; attack_damage = 2.5; skidding_override = 0; jump_override = 0; active_attack = 0; break;}
                        //Assume the override is disabled in every other case
                        default:
                            {
                                Animations_Override = 0;
                                active_attack = 0;
                                if bike = 0 skidding_override = 0;
                                carol_crouch_leap_timer = 0;
                                skid_animation_offset_x = 0;
                                skid_animation_offset_y = 0;
                                attack_damage = 0;
                                bike_gravity_speed = 0;
                                jump_override = 0;
                                break;
                            }
                    }
            }//End of Pause Check
    }//End of Carol Check
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Milla Action System

//Do not execute code if we are not Milla
if skin = spr_milla and pause = 0 and user_cursor_mode = 0
    {
        if anim_idle_timer &gt;= 120
            {
                var disco_id = collision_circle(universal_player_x,universal_player_y,256,obj_disco_ball,false,true);
                if instance_exists(disco_id)
                    {
                        if disco_id.fade_effect_target = 0.5
                            {
                                anim_current = anim_milla_dancing
                                if frame &lt; anim_milla[anim_milla_dancing,0]
                                    {
                                        frame = anim_milla[anim_milla_dancing,0]
                                        
                                    }
                            }
                    }
            }
        if sit = 1
            {
                var bench_id = collision_circle(px,py,24,obj_bench,false,true);
                if instance_exists(bench_id)
                    {
                        px = lerp(px,bench_id.x,0.25);
                        xdir = 1
                        anim_current = anim_milla_sitting
                        if frame &lt; anim_milla[anim_milla_sitting,0]
                            {
                                frame = anim_milla[anim_milla_sitting,0]
                            }
                    }
                else
                    sit = 0;
                sit_timer += 1
                //"Rest" mechanic
                if (stamina &lt; 96) stamina += 0.4;

                if (sit_timer &gt; 30)
                and (joy_input[0,0] = 1
                or joy_input[0,1] = 1
                or joy_input[0,2] = 1
                or joy_input[0,3] = 1
                or joy_input[1,0] = 1
                or joy_input[1,1] = 1
                or joy_input[1,2] = 1
                or joy_input[1,3] = 1
                or joy_input[1,4] = 1)
                    {
                        sit = 0
                        sit_timer = 0
                        anim_current=anim_standing
                    }
            }

        //================Post Speed Checks================//

        //Make sure we cannot go above 15px/f under any circumstances, by resetting movement to 15px/s
        //at the beginning of each step, if it is above 15px/f
        if hsp &gt;  15 hsp =  15;
        if hsp &lt; -15 hsp = -15;
        //Never allow the player to go above 15px/f upwards, either
        if gravity_speed &lt; -15 gravity_speed = -15;
        if gravity_speed &gt; 15  gravity_speed = floor(15);
        //Prevent player from leaving the boundaries of the camera
        if use_maps_multi_map_mode = 0 and (room != rm_campaign)
            {
                if px &lt; camera_boundary_left+15  {px = camera_boundary_left+15;  hsp = 0;}
                if px &gt; camera_boundary_right-15 {px = camera_boundary_right-15; hsp = 0;}
            }
        //Prevent player from infinitely flying above the ceiling
        if py &lt; camera_boundary_top-64
            py = camera_boundary_top-64;
        if (use_maps_multi_map_mode = 1) or (room = rm_campaign)
            {
                if px &lt; camera_boundary_left+15  {px = camera_boundary_left+15;  hsp = 0;}
                if (px &gt; camera_boundary_right-32 and room != rm_editor)
                    {
                        if (use_maps_boundary = 0)
                        or (room = rm_campaign and campaign_stage_select &lt; campaign_stage_section_limit)
                            {
                                //Fade to black after a certain period of time
                                transition_alpha+=0.1288
                                transition_timer += 1
                                px += 3
                                if ground = 1
                                    {
                                        anim_current=anim_walking;
                                        anim_previous=anim_walking;
                                    }
                                else
                                    {
                                        if px &lt; camera_boundary_right py += 2.5;
                                        anim_current=anim_falling;
                                    }
                                if transition_timer &gt;=114
                                    {
                                        transition_loading = 1;
                                        transition_alpha = 1;
                                        transition_timer = 0;
                                        now_loading = 1;
                                        use_maps_current_map += 1;
                                        checkpoint_x = 0
                                        checkpoint_y = 0
                                        if room = rm_campaign
                                            {
                                                dont_change_music = 1
                                                use_maps_current_map = 0
                                                campaign_stage_select += 1
                                                use_cuts_select = campaign_stage_section[campaign_stage_select]
                                            }
                                        use_maps_load = 1
                                    }
                                joy_input[2,6] = 30
                            }
                        else
                            {
                                if px &gt; camera_boundary_right-15
                                    {
                                        px = camera_boundary_right-15;
                                        hsp = 0;
                                    }
                            }
                    }
                if room = rm_editor
                    {
                        if px &gt; camera_boundary_right-15 {px = camera_boundary_right-15; hsp = 0;}
                    }
            }

        //============Milla HUD Elements============//

        //Paw Icon
        if anim_current=anim_ducking and gravity_ladder=0 milla_hud=3; //Set Paw Icon
        if anim_current=anim_standing and milla_hud=3
        or hsp!=0 and milla_hud=3                         milla_hud=0; //Return to Phantom Cube Icon
        //Phantom Cube Icon
        if milla_phantom_mode   = 2 milla_hud=1;
        if milla_phantom_mode   = 3
        or milla_phantom_mode   = 4
        or milla_special_attack &gt; 2 milla_hud=0;
        //Phantom Block Flash
        if milla_phantom_mode = 1
            {
                milla_hud_flash += 0.30
                //Reset animation iteration
                if milla_hud_flash &gt; 2 milla_hud_flash = 0;
            }
        else
            milla_hud_flash = 0;

        //Middle Mouse Button Substitute
        if joy_mouse_button_switch = 1
            {
                if milla_jump_press &gt; 8 and milla_phantom_mode = 2
                    joy_input[1,3] = 1;
            }

        //Bomb Cube Growth
        if joy_input[1,3] = 1
            {
                //if milla_phantom_attack_sprite=spr_cube_alt and hcap = 5
                //    milla_phantom_attack_sprite=spr_cube;
                if milla_phantom_attack_sprite=spr_cube_alt and milla_phantom_mode = 2
                    {
                        if milla_attack_bomb_cube_scale &lt; 3 milla_attack_bomb_cube_scale += 0.010;
                        if not audio_is_playing(milla_attack_bomb_cube_pitch)
                            audio_play_sound(milla_attack_bomb_cube_pitch,50,true);
                        audio_sound_pitch(milla_attack_bomb_cube_pitch,milla_attack_bomb_cube_scale)
                    }
            }
        else
            {
                if audio_is_playing(milla_attack_bomb_cube_pitch)
                    {
                        if milla_attack_bomb_cube_scale &gt; 1
                            audio_sound_pitch(milla_attack_bomb_cube_pitch,milla_attack_bomb_cube_scale);
                        if milla_attack_bomb_cube_scale &lt;= 1
                        audio_stop_sound(milla_attack_bomb_cube_pitch);
                        if milla_phantom_mode = 0
                            {
                                audio_stop_sound(milla_attack_bomb_cube_pitch);
                                milla_attack_bomb_cube_scale = 1;
                            }
                    }
                if milla_attack_bomb_cube_scale &gt; 1
                    milla_attack_bomb_cube_scale -= 0.010; 
            }

        //==============Input System==============//

        //Attack Button Locking
        if joy_input[1,0] = 1 joy_input[2,5]+= 1;
        if joy_input[1,0] = 0 joy_input[2,5] = 0;

        //Reset Attack Button Locking If An NPC Is Nearby
        if joy_input[2,5] &gt; 0
            {
                var npc_check = instance_nearest(universal_player_x,universal_player_y,obj_interact_parent);
                if instance_exists(npc_check)
                    {
                        if point_distance(npc_check.x,npc_check.y,universal_player_x,universal_player_y) &lt; 64
                            {
                                if ((px &gt; npc_check.x and xdir = -1)
                                or  (px &lt;= npc_check.x and xdir = 1))
                                    joy_input[2,5] = 0;
                            }
                    }
            }

        //Jump Button Locking
        if joy_input[1,2] = 1 milla_jump_press+= 1;
        if joy_input[1,2] = 0 milla_jump_press = 0;

        //Switch Button Locking
        if joy_input[1,4] = 1 milla_switch_button_timer += 1;
        else                  milla_switch_button_timer = 0;

        //Bomb Cube Type Switch
        if milla_switch_button_timer = 1 and milla_phantom_mode = 0
        and milla_special_attack = 0
            {
                milla_attack_skin_iterate += 1
                if milla_attack_skin_iterate &gt; 1
                    milla_attack_skin_iterate = 0;

                if milla_attack_skin_iterate = 0
                    {
                        milla_attack_skin = spr_cube
                        milla_phantom_attack_sprite = spr_cube                                                        
                    }
                if milla_attack_skin_iterate = 1
                    {
                        milla_attack_skin = spr_cube_alt
                        milla_phantom_attack_sprite = spr_cube_alt
                    }
                audio_play_sound(snd_change_weapon,50,false)
            }

        //Check if we are pressing the jump key again in mid-air
        if joy_input[1,2] = 1 and milla_jump_confirm_key = 0 milla_jump_confirm_key = 1;
        if joy_input[1,2] = 0 and milla_jump_confirm_key = 1 milla_jump_confirm_key = 2;

        //Hang Bar Jump Button Locking
        if gravity_ladder!=0              milla_hang_bar_jump  = 16;
        else {if milla_hang_bar_jump &gt;0   milla_hang_bar_jump -= 1};

        //If we have landed before performing the attack, reset confirm keys
        if (ground = 1 and milla_jump_confirm_key &gt; 0)
        or (above_water = 0)
            {
                milla_jump_confirm_key = 0
                milla_float_timer = 0
                milla_float_acceleration = 0
                milla_flutter_stamina_bar = 65
            }

        //Refresh flutter timer when on a hangbar or ladder
        if anim_current = anim_ladder_climbing
        or anim_current = anim_hanging_idle
        or anim_current = anim_spring
            {
                milla_float_timer = 0
                milla_float_sound_timer = 0
                milla_float_acceleration = 0
                milla_flutter_stamina_bar = 65
            }
        //Lock all directional movement after performing a super shield burst
        if milla_direction_override &gt; 0
            milla_direction_override += 1;
        if milla_direction_override = 20
            milla_direction_override = 0;

        //If we have landed on a spring, and the spring reset confirm keys, modify their value
        //so the player doesn't have to double tap the jump key to flutter
        if (spring_timer&gt;=0) and (milla_jump_confirm_key=0 or milla_jump_confirm_key=2) milla_jump_confirm_key=1;

        //If we are standing on top of an item, "copy" it before attempting to spawn a cube
        milla_item_id = collision_rectangle(px-8,py-4,px+8,py+8,obj_destructible,false,true)

        //==============Sentinel Animation Checks==============//

        //Do not allow the crouching or looking up animations to play if we are holding a cube
        if anim_milla[0,0] = 182 and (anim_current=anim_ducking or anim_current=anim_looking_up)
        or (anim_current=anim_wall_pushing and (milla_phantom_mode = 1 or milla_phantom_mode=2))
            anim_current=anim_standing;
            /*frame = 182;*/
        //Do not allow the skidding animation to play if we are holding a cube
        if anim_milla[0,0] = 182 and (anim_current=anim_skidding)
            {
                anim_current=anim_walking
                audio_stop_sound(character_skid)
                skid_animation_frame[0]=-128
                skid_animation_frame[1]=-128
                skid_animation_frame[2]=-128
                skid_animation_frame[3]=-128
                skid_animation_frame[4]=-128
                skid_animation_frame[5]=-128
                skid_animation_frame[6]=-128
                skid_animation_frame[7]=-128
                skid_animation_frame[8]=-128
                skid_animation_frame[9]=-128
            }
        //Prevent the player from getting stuck in their standing animation after landing, while holding a cube
        if anim_current = anim_standing and hsp!=0 anim_current=anim_walking;
        //Prevent Milla's wall pushing animation from playing after performing a shield burst
        if anim_current=anim_wall_pushing and (wall_collision_left = 0 and wall_collision_right = 0)
            anim_current = anim_standing
        //If we are swimming, hide the cube behind the player
        if above_water = 0 and ground = 0 and Animations_Override = 0 milla_phantom_cube_offset_y = 26;
        else                                                          milla_phantom_cube_offset_y = 0;
        //Force the player to drop their held item, when hurt
        if  (milla_phantom_mode = 2) and (gravity_ladder &gt; 0 or anim_current=anim_hurt)
            {
                //Return to generic movement behavior, and throw a remote phantom cube
                milla_phantom_mode = 0
                milla_special_attack = 0
                milla_phantom_cube_confirm = 0
                var cube_skin = obj_player_cube;
                if (milla_phantom_attack_sprite = spr_cube_alt) cube_skin = obj_player_cube_alt;
                //Set X/Y coordinates and angle of the remotely thrown phantom cube
                var cube_ID = instance_create(px+lengthdir_x(milla_phantom_cube_offset,angle_a+90),
                py+lengthdir_y(milla_phantom_cube_offset,angle_a+90),cube_skin);
                cube_ID.image = milla_phantom_attack_sprite
                cube_ID.angle = angle_a
                if  milla_phantom_attack_sprite!=spr_cube
                and milla_phantom_attack_sprite!=spr_cube_alt
                    cube_ID.frame = 0;
                //Set direction of remotely thrown cube
                cube_ID.xdir = xdir
                //Attack damage
                cube_ID.damage = 4
                //Reset flutter block trigger
                milla_flutter_block_trigger = 0

                //Determine the phantom cube's speed when thrown
                var cube_length_x = px+lengthdir_x(5+abs(hsp),angle_a)
                var cube_length_y = py+lengthdir_y(5+abs(hsp),angle_a)
                //Subtract the difference between the player's X/Y coordinates, and the direction of the throw
                var cube_difference_x = cube_length_x-px;
                var cube_difference_y = cube_length_y-py;
                //Apply horizontal and vertical speed to the player based on the difference
                cube_ID.cube_speed   = cube_difference_x *xdir;
                cube_ID.cube_gravity = cube_difference_y *xdir;
                
                //If we are on a flat surface, assign basic values to the phantom cube's speeds instead
                if angle_a = 0 or angle_a = 360 or hsp = 0
                    {
                        if xdir = -1 milla_phantom_cube_speed = -5 + hsp
                        if xdir =  1 milla_phantom_cube_speed =  5 + hsp
                        milla_phantom_cube_gravity = 0
                    }
                if gravity_ladder = 1 gravity_ladder = 0;
                milla_special_attack = 0
            }
        //Flutter blocking trigger
        if gravity_speed &gt; 0 and milla_flutter_block_trigger = 1 milla_flutter_block_trigger = 2;
        if ground = 1 milla_flutter_block_trigger = 0;

        //Flutter blocking timer
        if milla_flutter_block_trigger = 2 and anim_current=anim_falling
            {
                //Decrement timer
                milla_flutter_block_timer -=1
                //Once our 16 frame window to perform the flutter block ends, reset timer and trigger
                if milla_flutter_block_timer &lt;= 0
                    {
                        milla_flutter_block_trigger = 0
                        milla_flutter_block_timer = 0
                    }
            }

        //Do not execute code if we are on a ladder
        if gravity_ladder = 0
            {
                //==============Flutter==============//
                
                if  (anim_current = anim_jump or anim_current = anim_falling)
                and (joy_input[1,2] = 1 and above_water = 1)
                and (tile_surface_id[1] = -1 and tile_surface_id[2] = -1) and (milla_jump_confirm_key = 2 or (gravity_speed&gt;0 and milla_hang_bar_jump = 0))
                and (milla_hang_bar_jump = 0)
                and (milla_phantom_mode = 0)
                and (milla_flutter_stamina_bar &gt; 0)
                and (spring_timer = -1)
                    {
                        anim_current = anim_milla_flutter
                        audio_stop_sound(milla_flutter_voice)
                        audio_play_sound(milla_flutter_voice,50,false)
                    }
                //Flutter Animation
                if (anim_current=anim_milla_flutter) and (milla_flutter_stamina_bar &gt; 0)
                    {
                        //Iteration timer
                        if speed_boosted_timer = 0 and potion_feather_timer = 0 milla_flutter_stamina_bar -= 0.86666666666666666666666666666667;
                        else                                                    milla_flutter_stamina_bar -= 0.43333333333333333333333333333334;
                        //Sound iteration timer
                        milla_float_sound_timer+=1
                        //Animation iteration accelerator
                        if milla_float_acceleration &lt; 0.75 milla_float_acceleration+=0.008;
                        //Modify Y height
                        if (gravity_speed &gt; -2) gravity_speed-=0.50;
                        //Prevent Milla from escaping the boundaries of the normal walking speed while in mid-air
                        //var milla_dir = sign(hsp)
                        //if (abs(hsp) &gt;= 5.01 and abs(hsp) &lt;= 6) hsp = 5*milla_dir;
                        //Apply air drag if it wasn't applied already
                        if (abs(hsp) &gt; 5 and gravity_friction = 0) gravity_friction = 1;
                        //Smoothly clip against the ceiling, if we are touching it
                        if tile_collision_ceiling = 1
                            gravity_speed=0;
                        //Play sound
                        if milla_float_sound_timer &gt;= 6
                            {
                                audio_stop_sound(milla_flutter)
                                audio_play_sound(milla_flutter,50,false)
                                milla_float_sound_timer = 0
                            }
                    }
                //Disable floating if the timer has reached its endpoint
                if ((milla_flutter_stamina_bar &lt;= 0 or spring_timer &gt; 0) and anim_current=anim_milla_flutter)
                    {
                        anim_current=anim_falling
                        frame = anim_milla[anim_current,2]
                        milla_flutter_block_trigger = 0
                    }
                //Stop fluttering when there is no input
                if anim_current=anim_milla_flutter and (joy_input[1,2] = 0 or ground=1)
                    {
                        milla_jump_confirm_key = 1
                        anim_current=anim_falling
                        frame = anim_milla[anim_current,2]
                        milla_float_sound_timer = 0
                        milla_float_acceleration = 0
                        milla_flutter_block_trigger = 0
                    }

                //==============Digging==============//

                //If we were ducking and pressing the attack key, on a dirt tile, start digging
                if  anim_current=anim_ducking and joy_input[2,5] = 1
                    {
                        if tile_exists(tile_ramp_id)
                            {
                                if tile_ramp_id_debug = spr_dirt_0
                                or tile_ramp_id_debug = mu_slope_20
                                or tile_ramp_id_debug = mu_slope_21
                                or tile_ramp_id_debug = mu_slope_22
                                or tile_ramp_id_debug = mu_slope_23
                                or tile_ramp_id_debug = mu_slope_24
                                or tile_ramp_id_debug = mu_slope_25
                                or tile_ramp_id_debug = mu_slope_26
                                or tile_ramp_id_debug = mu_slope_27
                                or tile_ramp_id_debug = ll_slope_0
                                or tile_ramp_id_debug = ll_slope_1
                                or tile_ramp_id_debug = ll_slope_2
                                or tile_ramp_id_debug = ll_slope_3
                                or tile_ramp_id_debug = ll_slope_8
                                or tile_ramp_id_debug = ll_slope_9
                                or tile_ramp_id_debug = ll_slope_14
                                or tile_ramp_id_debug = ll_slope_15
                                or tile_ramp_id_debug = ll_slope_37
                                or tile_ramp_id_debug = ll_slope_38
                                or tile_ramp_id_debug = mnt_ramp_4
                                or tile_ramp_id_debug = mnt_ramp_5
                                or tile_ramp_id_debug = mnt_ramp_8
                                or tile_ramp_id_debug = mnt_ramp_9
                                or tile_ramp_id_debug = mnt_ramp_6
                                or tile_ramp_id_debug = mnt_ramp_7
                                or tile_ramp_id_debug = mnt_ramp_10
                                or tile_ramp_id_debug = mnt_ramp_11
                                or tile_ramp_id_debug = mnt_slope_20
                                or tile_ramp_id_debug = mnt_slope_21
                                or tile_ramp_id_debug = mnt_slope_22
                                or tile_ramp_id_debug = mnt_slope_23
                                or tile_ramp_id_debug = mnt_slope_16
                                or tile_ramp_id_debug = mnt_slope_17
                                or tile_ramp_id_debug = mnt_slope_18
                                or tile_ramp_id_debug = mnt_slope_19
                                or tile_ramp_id_debug = mnt_fof_3
                                or tile_ramp_id_debug = mnt_fof_4
                                    anim_current = anim_milla_digging;
                            }
                        if tile_exists(tile_surface_id[2])
                            {
                                var tile_dirt_id = tile_get_background(tile_surface_id[2]);
                                if tile_dirt_id = ll_flat_0
                                or tile_dirt_id = ll_flat_1
                                or tile_dirt_id = ll_flat_8
                                or tile_dirt_id = ll_flat_11
                                or tile_dirt_id = ll_flat_1
                                or tile_dirt_id = mnt_flat_18
                                or tile_dirt_id = mnt_flat_19
                                or tile_dirt_id = mnt_flat_20
                                or tile_dirt_id = mnt_flat_27
                                or tile_dirt_id = mnt_flat_30
                                or tile_dirt_id = mnt_flat_34
                                    anim_current = anim_milla_digging;
                            }
                    }
                //Digging action
                if anim_current=anim_milla_digging
                    {
                        //Iterate digging timer
                        milla_digging_timer+=1
                        //Iterate sound timer
                        milla_digging_sound+=1
                        //Iterate animation accelerator
                        if milla_digging_acceleration&lt;0.16 milla_digging_acceleration+=0.004;
                        //Reset digging timer if the player has pressed the button again
                        if joy_input[2,5] = 1 milla_digging_timer = 0;
                        //Reset digging sound timer if the player has played two sound effects
                        if milla_digging_sound &gt; 24 milla_digging_sound = 0;
                        //Hold the player still by using the override for the generic movement system
                        active_attack = 1
                        //Reset to the crouching animation if the digging timer has been reached
                        if milla_digging_timer &gt; 24
                            {
                                anim_current=anim_ducking           //Reset current animation to ducking
                                frame = anim_milla[anim_current,2]  //Reset current animation frame to ducking
                                milla_digging_acceleration = 0      //Reset digging animation accelerator
                                active_attack = 0                   //Reset active attack override for generic movement
                                milla_digging_tile_id = -1          //Reset digging tile ID
                                milla_digging_tile_stage = 0        //Reset digging tile stage
                                milla_hud = 0                       //Reset HUD icon graphics
                            }
                        //Place a digging tile
                        if milla_digging_sound = 24
                            {
                                //Which direction are we facing?
                                if xdir=1  milla_digging_direction = -8;
                                if xdir=-1 milla_digging_direction = -24;
                                //Place decorative tile
                                switch(milla_digging_tile_stage)
                                    {
                                        case 0: {milla_digging_index = spr_milla_dirt_0; milla_digging_x = px+milla_digging_direction; milla_digging_y = py-4; break;}
                                        case 1: {milla_digging_index = spr_milla_dirt_1; break;}
                                        case 2: {milla_digging_index = spr_milla_dirt_2; break;}
                                        case 3: {milla_digging_index = spr_milla_dirt_3; break;}
                                        case 4: {milla_digging_index = spr_milla_dirt_4; break;}
                                        case 5: {milla_digging_prompt_stop = 1;}
                                    }
                                //Spawn a useful item by chance
                                if milla_digging_tile_stage = 4
                                    {
                                        //Set randomized seed
                                        var random_item = random_range(0,5)
                                        //Spawn a bunch of gems
                                        if floor(random_item) = 0
                                            {
                                                //Create Gems
                                                scr_attack_tile(px+16+milla_digging_direction,py-16,obj_collectable,0,spr_gem,0)
                                                scr_attack_tile(px+16+milla_digging_direction,py-16,obj_collectable,0,spr_gem,-0.5)
                                                scr_attack_tile(px+16+milla_digging_direction,py-16,obj_collectable,0,spr_gem,-1)
                                                scr_attack_tile(px+16+milla_digging_direction,py-16,obj_collectable,0,spr_gem,-1.5)
                                                scr_attack_tile(px+16+milla_digging_direction,py-16,obj_collectable,0,spr_gem,0.5)
                                                scr_attack_tile(px+16+milla_digging_direction,py-16,obj_collectable,0,spr_gem,1)
                                                scr_attack_tile(px+16+milla_digging_direction,py-16,obj_collectable,0,spr_gem,1.5)
                                                //Play Sound
                                                audio_play_sound(milla_dig_successful,50,false)
                                                //Play Milla's Voice Clip "Shiny!"
                                                audio_play_sound(milla_dig_shiny,50,false)
                                            }
                                        //Spawn a flower petal
                                        if floor(random_item) = 1
                                            {
                                                scr_attack_tile(px+16+milla_digging_direction,py-16,obj_collectable,0,spr_petal_flower,0)
                                                //Play Sound
                                                audio_play_sound(milla_dig_successful,50,false)
                                                //Play Milla's Voice Clip "Ooh!"
                                                audio_play_sound(milla_dig_ooh,50,false)
                                            }
                                        //Spawn a gem
                                        if floor(random_item) = 2
                                            {
                                                scr_attack_tile(px+16+milla_digging_direction,py-16,obj_collectable,0,spr_gem,0)
                                                //Play Sound
                                                audio_play_sound(milla_dig_successful,50,false)
                                                //Play Milla's Voice Clip "Shiny!"
                                                audio_play_sound(milla_dig_shiny,50,false)
                                            }
                                        //Spawn flower petals
                                        if floor(random_item) = 3
                                            {
                                                scr_attack_tile(px+16+milla_digging_direction,py-16,obj_collectable,0,spr_petal_flower,0)
                                                scr_attack_tile(px+16+milla_digging_direction,py-16,obj_collectable,0,spr_petal_flower,-0.5)
                                                scr_attack_tile(px+16+milla_digging_direction,py-16,obj_collectable,0,spr_petal_flower,0.5)
                                                //Play Sound
                                                audio_play_sound(milla_dig_successful,50,false)
                                                //Play Milla's Voice Clip "Yay!"
                                                audio_play_sound(milla_dig_yay,50,false)
                                            }
                                        //Play sound if no items were spawned
                                        if floor(random_item) = 4
                                            {
                                                audio_play_sound(milla_dig_unsuccessful,50,false)
                                            }
                                    }
                                //Increment the digging state
                                milla_digging_tile_stage += 1
                            }
                        //Play sounds
                        switch(milla_digging_sound)
                            {
                                case 12: {audio_play_sound(milla_dig_1,50,false) break;}
                                case 24: {audio_play_sound(milla_dig_2,50,false) break;}
                            }
                    }
        
                //==============Shield Burst Attack==============//
        
                //If the player is holding the special key, and we are not currently holding an item, hold the shield burst animation
                if ((joy_input[1,3] = 1 and milla_phantom_cube_confirm = 0)
                or (joy_input[1,3] = 1 and milla_phantom_cube_confirm &gt;= 2))
                and milla_direction_override = 0
                and gravity_rail_check = 0
                and milla_phantom_mode != 1 //and milla_phantom_attack_sprite=spr_cube
                and milla_phantom_cube_confirm = 0
                and (milla_phantom_attack_sprite=spr_cube or
                (milla_phantom_attack_sprite=spr_cube_alt and milla_phantom_mode = 0))
                    {
                        //===Thoroughly examine player inputs for directions to aim in===//

                        //-----Facing Right-----//
                        //----------------------//
                        if milla_special_attack &lt; 3
                            {
                                //Direction: Up-Right ^&gt;
                                if joy_input[0,2] = 0 and joy_input[0,0] = 1 and joy_input[0,3] = 1 and joy_input[0,1] = 0
                                or joy_input[0,2] = 0 and joy_input[0,0] = 0 and joy_input[0,3] = 1 and joy_input[0,1] = 0 and xdir=1
                                    {
                                        milla_special_direction = anim_milla_north_east
                                        xdir=1
                                        milla_xdir = xdir
                                    }
                                //Direction: Right
                                if joy_input[0,2] = 0 and joy_input[0,0] = 1 and joy_input[0,3] = 0 and joy_input[0,1] = 0
                                or joy_input[0,2] = 0 and joy_input[0,0] = 0 and joy_input[0,3] = 0 and joy_input[0,1] = 0 and xdir=1
                                    {
                                        milla_special_direction = anim_milla_east
                                        xdir=1
                                        milla_xdir = xdir
                                    }
                                //Direction: Down-Right v&gt;
                                if joy_input[0,2] = 0 and joy_input[0,0] = 1 and joy_input[0,3] = 0 and joy_input[0,1] = 1
                                or joy_input[0,2] = 0 and joy_input[0,0] = 0 and joy_input[0,3] = 0 and joy_input[0,1] = 1 and xdir=1
                                    {
                                        milla_special_direction = anim_milla_south_east
                                        xdir=1
                                        milla_xdir = xdir
                                    }
        
                                //-----Facing Left-----//
                                //---------------------//
        
                                //Direction: Up-Left &lt;^
                                if joy_input[0,2] = 1 and joy_input[0,0] = 0 and joy_input[0,3] = 1 and joy_input[0,1] = 0
                                or joy_input[0,2] = 0 and joy_input[0,0] = 0 and joy_input[0,3] = 1 and joy_input[0,1] = 0 and xdir=-1
                                    {
                                        milla_special_direction = anim_milla_north_west
                                        xdir=-1
                                        milla_xdir = xdir
                                    }
                                //Direction: Left &lt;
                                if joy_input[0,2] = 1 and joy_input[0,0] = 0 and joy_input[0,3] = 0 and joy_input[0,1] = 0
                                or joy_input[0,2] = 0 and joy_input[0,0] = 0 and joy_input[0,3] = 0 and joy_input[0,1] = 0 and xdir=-1
                                    {
                                        milla_special_direction = anim_milla_west
                                        xdir=-1
                                        milla_xdir = xdir
                                    }
                                //Direction: Down-Left &lt;v
                                if joy_input[0,2] = 1 and joy_input[0,0] = 0 and joy_input[0,3] = 0 and joy_input[0,1] = 1
                                or joy_input[0,2] = 0 and joy_input[0,0] = 0 and joy_input[0,3] = 0 and joy_input[0,1] = 1 and xdir=-1
                                    {
                                        milla_special_direction = anim_milla_south_west
                                        xdir=-1
                                        milla_xdir = xdir
                                    }
                            }
                        
                        //===Now that we have determined the character player's facing direction, change animations===//

                        //After determining facing direction, determine size of shield
                        if milla_special_attack = 0
                            {
                                //If we are not holding a cube
                                if milla_phantom_mode = 0
                                    {
                                        //Set special attack mode to normal shield
                                        milla_special_attack = 1
                                        //Set orbital distance of shield to 24,
                                        //so it's a fair distance from Milla's hands
                                        milla_action_distance_param = 24
                                        audio_play_sound(milla_shield_small_up,50,false)
                                    }
                                //If we are holding a cube
                                if milla_phantom_mode = 2 and milla_phantom_attack_sprite=spr_cube
                                    {
                                        //Set special attack mode to super shield
                                        milla_special_attack = 2
                                        //Set orbital distance of super shield to 0,
                                        //so it's perfectly against Milla's hands
                                        milla_action_distance_param = 0
                                        //Play sound
                                        audio_play_sound(milla_shield_large_up,50,false)
                                    }
                            }

                        //Mid-air attacks
                        if ground = 0
                            {
                                switch(milla_special_direction)
                                    {
                                        case anim_milla_north_east: {anim_current = anim_milla_midair_up_right;   if frame &lt; 147 frame = 147; milla_special_shield_angle = 40;  milla_action_distance = milla_action_distance_param;  break;}
                                        case anim_milla_east:       {anim_current = anim_milla_midair_right;      if frame &lt; 148 frame = 148; milla_special_shield_angle = 0;   milla_action_distance = milla_action_distance_param;  break;}
                                        case anim_milla_south_east: {anim_current = anim_milla_midair_down_right; if frame &lt; 147 frame = 149; milla_special_shield_angle = -40; milla_action_distance = milla_action_distance_param;  break;}
                                        case anim_milla_north_west: {anim_current = anim_milla_midair_up_right;   if frame &lt; 147 frame = 147; milla_special_shield_angle = -40; milla_action_distance = -milla_action_distance_param; break;}
                                        case anim_milla_west:       {anim_current = anim_milla_midair_right;      if frame &lt; 148 frame = 148; milla_special_shield_angle = 0;   milla_action_distance = -milla_action_distance_param; break;}
                                        case anim_milla_south_west: {anim_current = anim_milla_midair_down_right; if frame &lt; 149 frame = 149; milla_special_shield_angle = 40;  milla_action_distance = -milla_action_distance_param; break;}
                                    }
                            }
                        //Ground attacks
                        if ground = 1
                            {
                                switch(milla_special_direction)
                                    {
                                        case anim_milla_north_east: {anim_current = anim_milla_attack_up_right;   if frame &lt; 144 frame = 144; milla_special_shield_angle = 40;  milla_action_distance = milla_action_distance_param;  break;}
                                        case anim_milla_east:       {anim_current = anim_milla_attack_right;      if frame &lt; 145 frame = 145; milla_special_shield_angle = 0;   milla_action_distance = milla_action_distance_param;  break;}
                                        case anim_milla_south_east: {anim_current = anim_milla_attack_down_right; if frame &lt; 146 frame = 146; milla_special_shield_angle = -40; milla_action_distance = milla_action_distance_param;  break;}
                                        case anim_milla_north_west: {anim_current = anim_milla_attack_up_right;   if frame &lt; 144 frame = 144; milla_special_shield_angle = -40; milla_action_distance = -milla_action_distance_param; break;}
                                        case anim_milla_west:       {anim_current = anim_milla_attack_right;      if frame &lt; 145 frame = 145; milla_special_shield_angle = 0;   milla_action_distance = -milla_action_distance_param; break;}
                                        case anim_milla_south_west: {anim_current = anim_milla_attack_down_right; if frame &lt; 146 frame = 146; milla_special_shield_angle = 40;  milla_action_distance = -milla_action_distance_param; break;}
                                    }
                            }

                        //Disable vertical controls only while swimming during the attack
                        //if py &gt; water_height {active_attack = 1}
                        //else                 {active_attack = 0}
                        //Apply friction to player on the ground
                        //============Friction============//
                        if stagger_backwards = 0 and ground = 1
                            {
                                //Left
                                if hsp &lt; -dec hsp += dec;
                                //Right
                                if hsp &gt;  dec hsp -= dec;
                                //Stop moving completely if we are slower than the base friction speed (Only on the ground, though.)
                                if abs(hsp) &lt; dec+1 {hsp=0; acc_time=0;}
                            }
                    }
                //If we have released the special key, perform the shield burst attack and return to normal generic movement
                if (joy_input[1,3] = 0) and (milla_special_attack = 1 or milla_special_attack = 2)
                and (milla_phantom_attack_sprite=spr_cube or milla_phantom_attack_sprite=spr_cube_alt)
                    {
                        //Reset shield animations
                        milla_special_shield_frame = 0

                        //If we were not holding a cube, perform the normal shield burst
                        if (milla_phantom_mode = 0)
                            {
                                milla_special_attack = 3
                                //Iterate Attack State
                                attack[0]    = 1                //Set Attack State
                                active_frame = 1                //Set Attack Frame
                                attack_range = 48               //Horizontal Hitbox Range
                                attack_width = 64               //Angular Hitbox Range
                                travel_length = 0               //Horizontal offset for Hitbox
                                travel_height = 0               //Vertical offset for Hitbox
                                attack_shape  = 1               //Shape of the hitbox (Rectangular)
                                attack_offset = 0               //Attack offset
                                attack_damage = 4               //Attack damage
                                milla_cube_override = 0         //Disable attack override (Modifies attack hitbox location,
                                                                //so it is where the cube is, instead of the player's)
                                milla_direction_override = 1
                                attack_x = px                   //X coordinate of attack hitbox
                                attack_y = py                   //Y coordinate of attack hitbox
                                x_traveling = 0
                                y_traveling = 0
                                audio_play_sound(milla_small_shield_burst,50,false)
                            }
                        //If we were holding a cube, perform the super shield burst
                        if milla_phantom_mode = 2 and milla_phantom_attack_sprite=spr_cube
                            {
                                milla_special_attack = 4
                                //Reset phantom cube modes
                                milla_phantom_mode          = 0
                                milla_phantom_cube_gravity  = 0
                                milla_phantom_cube_collided = 0
                                if xcompass = 0
                                    {
                                        //Set vertical knockback speed, based on aim
                                        if (milla_special_direction = anim_milla_north_east
                                        or milla_special_direction = anim_milla_north_west)
                                        and (ground = 0)
                                            gravity_speed += 5;
                                        //Determine how fast we should fly upwards
                                        if (milla_special_direction = anim_milla_south_east or milla_special_direction = anim_milla_south_west)
                                            {
                                                if gravity_speed &gt;= 0 milla_phantom_rocket_speed = 5;
                                                if gravity_speed &lt;  0 milla_phantom_rocket_speed = 5 + abs(gravity_speed);
                                            }
                                        if tile_collision_ceiling = 1 milla_phantom_rocket_speed = 0;
                                        if ground= 0 hsp += 7 * -milla_xdir; //Set Horizontal Knockback Speed (Mid-air)
                                        if ground= 1
                                            {
                                                if hsp = 0 hsp  = 1.5 * -milla_xdir; //Set Horizontal Knockback Speed (Ground)
                                                else hsp = 0;
                                            }
                                    }
                                attack[0]    = 1                //Set Attack State
                                active_frame = 1                //Set Attack Frame
                                attack_range = 48               //Horizontal Hitbox Range
                                attack_width = 172              //Angular Hitbox Range
                                travel_length = 0               //Horizontal offset for Hitbox
                                travel_height = 0               //Vertical offset for Hitbox
                                attack_shape  = 1               //Shape of the hitbox (Rectangular)
                                attack_offset = 0               //Attack offset
                                attack_damage = 6               //Attack damage
                                milla_cube_override = 0         //Disable Attack Override
                                view_shake    = 28              //Set Camera Shake
                                view_shake_mod= 3               //Reset Camera Shake Modifier
                                spring_timer  = -1              //Reset Spring Timer
                                milla_flutter_block_trigger = 1 //Set Flutter Block Trigger
                                milla_flutter_block_timer = 16  //Set Flutter Block Timer
                                milla_float_timer = 0           //Reset Float Timer
                                milla_float_sound_timer = 0     //Reset Float Sound Timer
                                milla_float_acceleration = 0    //Reset Float Acceleration
                                milla_flutter_stamina_bar = 65  //Reset Float Stamina
                                milla_direction_override = 1
                                audio_play_sound(milla_shield_large_burst,50,false)
                            }
                    }
                //Only allow the first four frames of the shield burst animation to be active attack frames
                if milla_special_shield_frame &gt; 0 and milla_special_shield_frame &lt; 3.9 active_frame = 1;
                else                                                                   active_frame = 0;

                //If we have touched a ceiling, disable further speed boosting
                if tile_collision_ceiling = 1 or spring_timer != -1
                or xcompass != 0
                    milla_phantom_rocket_speed = 0
                //Boost the player into the air
                if milla_phantom_rocket_speed &gt; 0
                    {
                        gravity_speed = -milla_phantom_rocket_speed
                        milla_phantom_rocket_speed-=gravity_accel
                    }

                //==============Phantom Cubes==============//

                //Check attack button for inputs
                if (joy_input[1,0] = 1 and milla_phantom_mode &lt; 3
                and anim_current!=anim_milla_flutter
                and anim_current!=anim_milla_digging
                and anim_current!=anim_ducking
                and anim_current!=anim_looking_up
                and anim_current!=anim_hurt
                and anim_current!=anim_milla_attack_up_right
                and anim_current!=anim_milla_attack_right
                and anim_current!=anim_milla_attack_down_right
                and anim_current!=anim_milla_midair_up_right
                and anim_current!=anim_milla_midair_right
                and anim_current!=anim_milla_midair_down_right
                and gravity_ladder = 0)
                //Or check if we are flutter blocking
                or (anim_current=anim_milla_flutter and milla_flutter_block_trigger = 2)
                    {
                        if instance_exists(milla_item_id) and milla_phantom_mode = 0 and joy_input[2,5] = 1
                            {
                                switch(milla_item_id.sprite_index)
                                    {
                                        case spr_crate_0_copy : {milla_phantom_attack_sprite = spr_crate_0_copy;  milla_phantom_cube_confirm = 1; break;}
                                        case spr_crystal_gem_flower:  {milla_phantom_attack_sprite = spr_crystal_gem_flower; milla_phantom_cube_confirm = 1; break;}
                                        case spr_crystal_gold_flower: {milla_phantom_attack_sprite = spr_crystal_gold_flower; milla_phantom_cube_confirm = 1; break;}
                                        case spr_crystal_green_flower: {milla_phantom_attack_sprite = spr_crystal_green_flower; milla_phantom_cube_confirm = 1; break;}
                                        case spr_health_petal_flower: {milla_phantom_attack_sprite = spr_health_petal_flower; milla_phantom_cube_confirm = 1; break;}
                                        case spr_flower_2_copy: {milla_phantom_attack_sprite = spr_flower_2_copy; milla_phantom_cube_confirm = 1; break;}
                                        case spr_flower_3_copy: {milla_phantom_attack_sprite = spr_flower_3_copy; milla_phantom_cube_confirm = 1; break;}
                                        case spr_flower_4_copy: {milla_phantom_attack_sprite = spr_flower_4_copy; milla_phantom_cube_confirm = 1; break;}
                                        case spr_flower_5_copy: {milla_phantom_attack_sprite = spr_flower_5_copy; milla_phantom_cube_confirm = 1; break;}
                                        case spr_flower_6_copy: {milla_phantom_attack_sprite = spr_flower_6_copy; milla_phantom_cube_confirm = 1; break;}
                                        case spr_flower_7_copy: {milla_phantom_attack_sprite = spr_flower_7_copy; milla_phantom_cube_confirm = 1; break;}
                                        case spr_flower_10_copy: {milla_phantom_attack_sprite = spr_flower_10_copy; milla_phantom_cube_confirm = 1; break;}
                                        case spr_bomb_flower:   {milla_phantom_attack_sprite = spr_bomb_flower; milla_phantom_cube_confirm = 1; break;}
                                        case spr_chibililac_cage: {milla_phantom_attack_sprite = spr_chibimilla_cage; milla_phantom_cube_confirm = 1; break;}
                                        case spr_gascan_0_copy: {milla_phantom_attack_sprite = spr_gascan_0_copy; milla_phantom_cube_confirm = 1; break;}
                                        case spr_potion_chest:  {milla_phantom_attack_sprite = spr_potion_chest; milla_phantom_cube_confirm = 1; break;}
                                        case spr_treasure_chest: {milla_phantom_attack_sprite = spr_treasure_chest; milla_phantom_cube_confirm = 1; break;}
                                        //If we have not found an item tile, spawn a cube instead
                                        default:           {milla_phantom_attack_sprite = milla_attack_skin;     milla_phantom_cube_confirm = 0; break;}
                                    }
                            }
                        //If we were never standing on an item in the first place, reset phantom sprites and confirmation
                        if milla_phantom_cube_confirm = 0
                            {
                                milla_phantom_attack_sprite = milla_attack_skin;
                                milla_phantom_cube_confirm = 0;
                            }
                        //If we were not standing on top of an item, attempt to spawn a cube instead
                        if milla_phantom_cube_confirm = 0
                            {
                                //Enable spawning of cube
                                if milla_phantom_mode = 0
                                    {
                                        milla_phantom_mode = 1
                                        //Set offset of the cube
                                        milla_phantom_cube_offset = 42
                                    }
                                //Spawn timer for phantom cube
                                if milla_phantom_mode = 1
                                    {
                                        //Iterate phantom timer
                                        milla_phantom_timer += 1
                                            
                                        //Initialize phantom variables
                                        if milla_phantom_timer = 1
                                            {
                                                //Reset animation frames
                                                milla_phantom_attack_frame = 0
                                                //Play sound
                                                audio_play_sound(milla_draw_cube,50,false)
                                            }
                                        var turbo = 39;
                                        if user_turbo_mode = 1 or speed_boosted_timer != 0 turbo = 19;
                                        //If the timer has been reached, spawn the cube (See animation code for displaying of sprites)
                                        if milla_phantom_timer &gt;= turbo
                                            {
                                                milla_phantom_attack_sprite = milla_attack_skin
                                                milla_phantom_mode = 2;
                                                milla_phantom_attack_frame = 0;
                                                milla_phantom_timer = 0;
                                                //Set offset of the cube
                                                milla_phantom_cube_offset = 42
                                                //Stop cube drawing sound
                                                audio_stop_sound(milla_draw_cube)
                                                //Play sound
                                                audio_play_sound(milla_drawn_cube,50,false)
                                            }
                                    }
                            }//End of cube spawning check

                        //If we were standing on top of an item, "copy" the perceived item and then delete the item
                        if milla_phantom_cube_confirm = 1 and milla_phantom_mode = 0
                            {
                                milla_phantom_mode = 2;
                                milla_phantom_attack_frame  = 0
                                milla_phantom_attack_frame2 = 0
                                milla_phantom_attack_framed = 0
                                //Delete item
                                if room != rm_editor and instance_exists(milla_item_id) instance_destroy(milla_item_id);
                            }

                    }

            }//End of Ladder Safety Check

                //Modify and override animations relevant to holding our cubes
                if (milla_phantom_mode &gt; 0 and milla_phantom_mode &lt; 3 and anim_milla[0,0] != 182) scr_set_milla_state_holding_cube();
                //Undo overrides when not in use
                if ((milla_phantom_mode = 0) and anim_milla[0,0] = 182) scr_set_milla_state_without_cube();
                //If we have released button inputs before completing the spawning animation, cancel spawning of the phantom cube
                if joy_input[1,0] = 0 and milla_phantom_mode = 1
                or (milla_phantom_mode = 1 and gravity_ladder &gt; 0)
                    {
                        milla_phantom_mode = 0
                        //Reset animation frames
                        milla_phantom_attack_frame = 0
                        //Reset spawning timer
                        milla_phantom_timer = 0
                        milla_hud_flash = 0
                        //Stop sound
                        audio_stop_sound(milla_draw_cube)
                    }

                //Animations for held items
                if milla_phantom_attack_sprite!=spr_cube
                and milla_phantom_attack_sprite!=spr_cube_alt
                    {
                        switch(milla_phantom_attack_sprite)
                            {
                                case spr_crate_0_copy :     {milla_phantom_attack_frame=0; break;}
                                case spr_crystal_gem_flower:
                                    {
                                        if milla_phantom_attack_framed = 0 milla_phantom_attack_frame+=0.1;    //Play animations forward
                                        if milla_phantom_attack_framed = 1 milla_phantom_attack_frame-=0.1;    //Play animations backward
                                        if milla_phantom_attack_frame &gt;= 4.8 milla_phantom_attack_framed = 1;  //Reverse animation speed
                                        if milla_phantom_attack_frame &lt;= 0   milla_phantom_attack_framed = 0;  //Reset animation speed
                                        //Advance Animation Frames
                                        milla_gem_flower_particle-=0.2
                                        //Float Upward
                                        milla_gem_flower_z-=1
                                        
                                        //Reset Particle Animation and Position
                                        if milla_gem_flower_particle &lt;= 0
                                            {
                                                flower_particle_x = px+lengthdir_x(48,angle_a+90) //X position rotation
                                                flower_particle_y = py+lengthdir_y(48,angle_a+90) //Y position rotation
                                                milla_gem_flower_x          = flower_particle_x   //X position
                                                milla_gem_flower_y          = flower_particle_y   //Y position
                                                milla_gem_flower_particle   = 7    //Reset Animation Frame
                                                milla_gem_flower_z          = 0    //Reset Vertical Offset
                                                milla_gem_flower_x2+=8             //Change Horizontal Position
                                                //If Horizontal Position Is Past The Tile, Reset Horizontal Offset
                                                if milla_gem_flower_x2&gt;=32 milla_gem_flower_x2=0;
                                            }
                                        break;
                                    }
                                case spr_crystal_gold_flower:
                                    {
                                        if milla_phantom_attack_framed = 0 milla_phantom_attack_frame+=0.1;    //Play animations forward
                                        if milla_phantom_attack_framed = 1 milla_phantom_attack_frame-=0.1;    //Play animations backward
                                        if milla_phantom_attack_frame &gt;= 4.8 milla_phantom_attack_framed = 1;  //Reverse animation speed
                                        if milla_phantom_attack_frame &lt;= 0   milla_phantom_attack_framed = 0;  //Reset animation speed
                                        //Advance Animation Frames
                                        milla_gem_flower_particle-=0.2
                                        //Float Upward
                                        milla_gem_flower_z-=1
                                        
                                        //Reset Particle Animation and Position
                                        if milla_gem_flower_particle &lt;= 0
                                            {
                                                flower_particle_x = px+lengthdir_x(48,angle_a+90) //X position rotation
                                                flower_particle_y = py+lengthdir_y(48,angle_a+90) //Y position rotation
                                                milla_gem_flower_x          = flower_particle_x   //X position
                                                milla_gem_flower_y          = flower_particle_y   //Y position
                                                milla_gem_flower_particle   = 7    //Reset Animation Frame
                                                milla_gem_flower_z          = 0    //Reset Vertical Offset
                                                milla_gem_flower_x2+=8             //Change Horizontal Position
                                                //If Horizontal Position Is Past The Tile, Reset Horizontal Offset
                                                if milla_gem_flower_x2&gt;=32 milla_gem_flower_x2=0;
                                            }
                                        break;
                                    }
                                case spr_health_petal_flower: {milla_phantom_attack_frame=0; break;}
                                case spr_flower_2_copy:       {milla_phantom_attack_frame3+=0.24 if milla_phantom_attack_frame3 &gt; 10.8 milla_phantom_attack_frame3=0; break;}
                                case spr_flower_3_copy:       {milla_phantom_attack_frame3+=0.24 if milla_phantom_attack_frame3 &gt; 7.8  milla_phantom_attack_frame3=0; break;}
                                case spr_flower_4_copy:       {milla_phantom_attack_frame3+=0.12 if milla_phantom_attack_frame3 &gt; 8.8  milla_phantom_attack_frame3=0; break;}
                                case spr_flower_5_copy:       {milla_phantom_attack_frame3+=0.24 if milla_phantom_attack_frame3 &gt; 8.8  milla_phantom_attack_frame3=0; break;}
                                case spr_flower_6_copy:       {milla_phantom_attack_frame3+=0.75 if milla_phantom_attack_frame3 &gt; 17.8 milla_phantom_attack_frame3=0; break;}
                                case spr_flower_7_copy:       {milla_phantom_attack_frame=0; break;}
                                case spr_bomb_flower:
                                    {
                                        if milla_phantom_mode=2 or milla_phantom_mode=3
                                            {
                                                //Advance Frames
                                                milla_bomb_frame_timer+=1
                                                //
                                                if milla_bomb_frame_timer&gt;milla_bomb_frame_decay
                                                    {
                                                        //Advance Animation Frame
                                                        milla_phantom_attack_frame += 1
                                                        //Reset Animation Frame If Above Maximum
                                                        if milla_phantom_attack_frame &gt; 2
                                                            {
                                                                milla_phantom_attack_frame = 0
                                                                milla_bomb_frame_decay -= 1    //Decay Maximum Time
                                                                milla_bomb_frame_timer  = 0    //Reset Timer
                                                                //Play Sound
                                                                audio_play_sound(snd_bomb_beep,50,false)
                                                            }
                                                    }
                                            }
                                        //Detonate bomb if player waits too long to throw it
                                        if milla_bomb_frame_decay &lt;= 0 and milla_phantom_mode=2
                                            {
                                                milla_phantom_attack_frame = 0 //Reset Attack Frame
                                                milla_bomb_frame_decay = 14    //Decay Maximum Time
                                                milla_bomb_frame_timer = 0     //Reset Timer
                                                milla_phantom_mode     = 0     //Reset Phantom Mode
                                                milla_phantom_cube_confirm = 0 //Reset Phantom Mode Confirm
                                                //Reset phantom cube sprite so we don't have infinitely looping explosions :^P
                                                milla_phantom_attack_sprite = spr_cube
                                                //Create bomb object
                                                milla_bomb_create_x = px+lengthdir_x(48,angle_a+90) //X position rotation
                                                milla_bomb_create_y = py+lengthdir_y(48,angle_a+90) //Y position rotation
                                                bomb_id = instance_create(milla_bomb_create_x,milla_bomb_create_y,obj_bomb)
                                                bomb_id.detonate = 1
                                                bomb_id.detonate_delay = 1
                                                bomb_id.detonate_for_milla = 1
                                            }
                                        break;
                                    }
                                case spr_chibimilla_cage:   {milla_phantom_attack_frame+=0.40 if milla_phantom_attack_frame &gt; 7.8 milla_phantom_attack_frame=0; break;}
                                case spr_gascan_0_copy:     {milla_phantom_attack_frame+=0.15 if milla_phantom_attack_frame &gt; 6.8 milla_phantom_attack_frame=0; break;}
                                case spr_potion_chest:      {milla_phantom_attack_frame+=0.24 if milla_phantom_attack_frame &gt; 6.8 milla_phantom_attack_frame=0; break;}
                                case spr_treasure_chest:    {milla_phantom_attack_frame+=0.24 if milla_phantom_attack_frame &gt; 6.8 milla_phantom_attack_frame=0; break;}
                                default:                    {break;}
                            }
                    }
                //Prepare to toss cube if attack button inputs are detected again, or we are on a hangbar, or we are hurt
                if ((milla_phantom_mode = 2 and milla_phantom_cube_confirm = 0) and (joy_input[2,5] = 1)
                or (milla_phantom_mode = 2 and milla_phantom_cube_confirm = 2 and joy_input[2,5] = 1))
                and anim_current != anim_milla_attack_up_right
                and anim_current != anim_milla_attack_right
                and anim_current != anim_milla_attack_down_right
                and anim_current != anim_milla_midair_up_right
                and anim_current != anim_milla_midair_right
                and anim_current != anim_milla_midair_down_right
                    {
                        //Play sound
                        audio_play_sound(milla_throw,50,false)
                        //Return to generic movement behavior, and throw a remote phantom cube
                        milla_phantom_mode = 0
                        milla_special_attack = 0
                        milla_phantom_cube_confirm = 0
                        //Set X/Y coordinates and angle of the remotely thrown phantom cube
                        var cube_skin = obj_player_cube;
                        if (milla_phantom_attack_sprite = spr_cube_alt) cube_skin = obj_player_cube_alt;
                        var cube_ID = instance_create(px+lengthdir_x(milla_phantom_cube_offset,angle_a+90),
                        py+lengthdir_y(milla_phantom_cube_offset,angle_a+90),cube_skin);
                        cube_ID.image = milla_phantom_attack_sprite
                        cube_ID.angle = angle_a
                        if milla_phantom_attack_sprite!=spr_cube
                        and milla_phantom_attack_sprite!=spr_cube_alt
                        cube_ID.frame = 0;
                        if milla_phantom_attack_sprite=spr_cube_alt
                            {
                                cube_ID.cube_health = milla_attack_bomb_cube_scale;
                                cube_ID.cube_growth = milla_attack_bomb_cube_scale;
                            }
                        //Set direction of remotely thrown cube
                        cube_ID.xdir = xdir
                        //Attack damage
                        cube_ID.damage = 4
                        //Reset flutter block trigger
                        milla_flutter_block_trigger = 0

                        //Determine the phantom cube's speed when thrown
                        var cube_length_x = px+lengthdir_x(5+abs(hsp),angle_a)
                        var cube_length_y = py+lengthdir_y(5+abs(hsp),angle_a)
                        //Subtract the difference between the player's X/Y coordinates, and the direction of the throw
                        var cube_difference_x = cube_length_x-px;
                        var cube_difference_y = cube_length_y-py;
                        //Apply horizontal and vertical speed to the player based on the difference
                        cube_ID.cube_speed   = cube_difference_x *xdir;
                        cube_ID.cube_gravity = cube_difference_y *xdir;
                        
                        //If we are on a flat surface, assign basic values to the phantom cube's speeds instead
                        if angle_a = 0 or angle_a = 360
                            {
                                if xdir = -1 milla_phantom_cube_speed = -5 + hsp
                                if xdir =  1 milla_phantom_cube_speed =  5 + hsp
                                milla_phantom_cube_gravity = 0
                            }
                    }
                //Prepare to toss item if input keys are released
                if (milla_phantom_mode = 2 and milla_phantom_cube_confirm = 1 and joy_input[2,5] = 0)
                    milla_phantom_cube_confirm = 2;

        //          Animation System Core          //
        //=========================================//

        //Make sure we aren't dead, before allowing normal animations
        if death[0] = 0 and not (targets_ready = 3 and ground = 1)
            {
                //---Character Sprites---//
                //-----------------------//

                if gravity_rail_check = 1
                    {
                        anim_current = anim_milla_rail_grinding;
                        if above_water = 0 and ground = 0
                            {
                                anim_current = anim_swimming
                                scr_set_rail_grinding_stop()
                            }
                    }
                //Perpetually advance frames based on provided speed,
                //if we are not using aerial attacks
                if  anim_current!=anim_ladder_climbing
                and anim_current!=anim_swimming
                and anim_current!=anim_milla_flutter
                and anim_current!=anim_milla_digging
                and anim_current!=anim_spring
                    frame += anim_milla[anim_current,3]+milla_animation_speed_mod;
                //If a new animation has started, initialize the new animation
                if anim_previous!=anim_current
                    {
                        frame = anim_milla[anim_current,0]  //Set starting frame of animation
                        anim_previous=anim_current          //Disable triggered breakpoint
                    }
        
                //---Shield Sprites---//
                //--------------------//
        
                //Animations for attack sprites
                if milla_special_attack != 0
                    {
                        //Iterate attack animations
                        milla_special_shield_frame += 0.48
                        //Disable attack override
                        milla_cube_override = 0
                        xdir = milla_xdir
                        //Reset small attack animations
                        if milla_special_shield_frame &gt; 8.8 and milla_special_attack = 1
                            milla_special_shield_frame = 5;
                        //Reset large attack animations
                        if milla_special_shield_frame &gt; 5.8 and milla_special_attack = 2
                            milla_special_shield_frame = 4;
                        //Set shield burst attack animations
                        if milla_special_shield_frame &gt; 5.8 and milla_special_attack = 3
                        or milla_special_shield_frame &gt; 5.8 and milla_special_attack = 4
                            {
                                milla_special_shield_frame = 0
                                //Return to normal animations
                                if ground = 0 anim_current=anim_falling frame=86;
                                if ground = 1 anim_current=anim_standing;
                                //Spawn small shield burst particle
                                if milla_special_attack = 4
                                    {
                                        milla_particle_frame_6 = 0
                                        milla_particle_x_6_ang = angle_a+milla_special_shield_angle
                                    }
                                //Reset attack mode
                                milla_special_attack = 0
                                //Reset attack variables
                                milla_cube_override = 0
                                attack[0] = 0
                                //Reset Milla's animation states
                                scr_set_milla_state_without_cube();
                            }
                        //Distance from Origin Point (Player's X/Y Coordinates)
                        milla_special_length_x1 = px+lengthdir_x(24,angle_a+90)
                        milla_special_length_y1 = py+lengthdir_y(24,angle_a+90)
                        //Orbital Point
                        milla_special_length_x2 = milla_special_length_x1+lengthdir_x(milla_action_distance,angle_a+milla_special_shield_angle)
                        milla_special_length_y2 = milla_special_length_y1+lengthdir_y(milla_action_distance,angle_a+milla_special_shield_angle)
                    }
        
                //---Phantom Cube Sprites---//
                //--------------------------//
        
                //Animations for attack sprites
                if milla_phantom_mode = 1 or milla_phantom_mode = 2
                    {
                        if milla_phantom_attack_sprite=spr_cube
                        or milla_phantom_attack_sprite=spr_cube_alt
                            {
                                //Iterate attack animations
                                milla_phantom_attack_frame += 1
                                //Reset attack animations (Spawning Cube)
                                if milla_phantom_attack_frame &gt; 11.8 and milla_phantom_mode = 1 milla_phantom_attack_frame = 0;
                                //Set attack animations (Spawned Cube)
                                if milla_phantom_attack_frame &gt; 6.8 and milla_phantom_mode = 2 milla_phantom_attack_frame = 6;
                            }
                        //Distance from Origin Point (Player's X/Y Coordinates)
                        milla_phantom_length_x = px+lengthdir_x(milla_phantom_cube_offset-milla_phantom_cube_walkset,angle_a+90)
                        milla_phantom_length_y = py+lengthdir_y(milla_phantom_cube_offset-milla_phantom_cube_walkset,angle_a+90)
                        //If we are holding an item instead of a cube, rotate it around the player's head
                        milla_item_length_x = milla_phantom_length_x+lengthdir_x(milla_phantom_cube_offset_x,angle_a)
                        milla_item_length_y = milla_phantom_length_y+lengthdir_y(milla_phantom_cube_offset_x,angle_a)
                        
                        //Modify the phantom cube's offset based on the character's animations
                        switch(floor(frame))
                            {
                                //Standing Animation
                                case 182: {milla_phantom_cube_walkset = 2; break;}
                                case 183: {milla_phantom_cube_walkset = 1; break;}
                                case 184: {milla_phantom_cube_walkset = 0; break;}
                                case 185: {milla_phantom_cube_walkset = 1; break;}
                                //Walking animation
                                case 49: {milla_phantom_cube_walkset = 3; break;}
                                case 50: {milla_phantom_cube_walkset = 2; break;}
                                case 51: {milla_phantom_cube_walkset = 2; break;}
                                case 52: {milla_phantom_cube_walkset = 3; break;}
                                case 53: {milla_phantom_cube_walkset = 5; break;}
                                case 54: {milla_phantom_cube_walkset = 3; break;}
                                case 55: {milla_phantom_cube_walkset = 2; break;}
                                case 56: {milla_phantom_cube_walkset = 2; break;}
                                case 57: {milla_phantom_cube_walkset = 3; break;}
                                case 58: {milla_phantom_cube_walkset = 5; break;}
                                case 130: {milla_phantom_cube_walkset = 10; break;}
                                case 131: {milla_phantom_cube_walkset = 10; break;}
                                case 132: {milla_phantom_cube_walkset = 10; break;}
                                case 133: {milla_phantom_cube_walkset = 10; break;}
                                case 134: {milla_phantom_cube_walkset = 10; break;}
                                case 135: {milla_phantom_cube_walkset = 10; break;}
                                case 136: {milla_phantom_cube_walkset = 10; break;}
                                case 137: {milla_phantom_cube_walkset = 10; break;}
                                //Reset in every other case
                                default: {milla_phantom_cube_walkset = 0; break;}
                            }
                    }
        
                        //============Speed Modifiers============//
        
                        //If we are bouncing on a spring, increase animation
                        //speed based on a timer
                        if anim_current=anim_spring
                            {
                                frame += spring_anim_mod*1.67
                                //Decrement animation modifier
                                if spring_anim_mod &gt; 0.16 spring_anim_mod -= 0.025;
                                //End springing animation if it hasn't already
                                if spring_timer=-1
                                    anim_current=anim_falling;
                            }

                        //For walking, running, and running faster animations, apply animation speed based on horizontal moving speed
                        milla_animation_speed_mod = abs(hsp)/56
        
                        //If we are fluttering, accelerate animation speeds over time
                        if anim_current=anim_milla_flutter frame += anim_milla[anim_current,3]+milla_float_acceleration*1.67;
        
                        //If we are digging, accelerate animation speeds over time
                        if anim_current=anim_milla_digging frame += anim_milla[anim_current,3]+milla_digging_acceleration*1.67;
        
                        //============Special Actions============//
                
                        //Key Release for Wall Pushing Animation
                        if (anim_current=anim_wall_pushing and hsp!=0 and ground=1)
                        or (anim_current=anim_wall_pushing and joy_input[0,0] = 0 and joy_input[0,2] = 0 and ground=1)
                        or (anim_current=anim_wall_pushing and ground=0)
                            anim_current=anim_standing;
                        //If we are on a ladder, animations should play forwards or in reverse based on input
                        if ladder_state = 0
                            {
                                if gravity_ladder = 1 and attack[2] &gt; 0 anim_current=anim_ladder_climbing;
                                if anim_current=anim_ladder_climbing
                                    {
                                        //Keep Milla's Attack States Empty
                                        attack[0] = 0
                                        milla_phantom_rocket_speed = 0
                                        //Climbing up
                                        if joy_input[0,3] = 1 and joy_input[0,1] = 0 frame += anim_milla[anim_current,3];
                                        //Climbing Down
                                        if joy_input[0,3] = 0 and joy_input[0,1] = 1
                                            {
                                                frame -= anim_milla[anim_current,3]
                                                //If we are playing frames below the current animation, restart animation loop from
                                                //its endpoint instead
                                                if frame &lt; anim_milla[anim_current,0]+0.40 frame = anim_milla[anim_current,1];
                                            }
                                    }
                            }
                        //Idle Animation
                        if anim_current = anim_standing and anim_milla[0,0] != 182
                            {
                                //Iterate idle timer
                                anim_idle_timer += 1

                                //If the timer has reached its limit, start the idle animation
                                if anim_idle_timer = 530
                                    {
                                        anim_current = anim_idle_1
                                        frame = anim_milla[anim_idle_1,0]
                                    }
                                //If the timer has exceeded its limit, reset the timer
                                if anim_idle_timer &gt; 530
                                    anim_idle_timer = 0;
                            }
                        //If we have moved or attacked at all, reset iteration timer
                        if hsp!=0 or gravity_speed!=0 or attack[0]!=0 anim_idle_timer = 0;
                        //If we have reached the end of the animation, reset idle timer and return to the standing animation
                        if anim_current = anim_idle_1 and frame &gt; anim_milla[anim_idle_1,1]+0.8
                            {
                                anim_idle_timer = 0
                                anim_current = anim_standing
                            }
                //If we are above the ending frame, restart the animation at the desired loop point
                if frame &gt; anim_milla[anim_current,1]+0.8 frame = anim_milla[anim_current,2];
            }

        //---Tail Sprites---//
        //------------------//
        
        //Perpetually advance tail frames based on provided speed
        switch(anim_current)
            {
                //For the animations that don't have tail sprites baked into the main sprite, animate the tail
                case anim_standing:                 {milla_tail_visible = 1; break;}
                case anim_idle_1:                   {milla_tail_visible = 1; break;}
                case anim_wall_pushing:             {milla_tail_visible = 1; break;}
                case anim_hanging_idle:             {milla_tail_visible = 1; break;}
                case anim_looking_up:               {milla_tail_visible = 1; break;}
                case anim_milla_attack_up_right:    {milla_tail_visible = 1; break;}
                case anim_milla_attack_right:       {milla_tail_visible = 1; break;}
                case anim_milla_attack_down_right:  {milla_tail_visible = 1; break;}
                case anim_milla_midair_up_right:    {milla_tail_visible = 1; break;}
                case anim_milla_midair_right:       {milla_tail_visible = 1; break;}
                case anim_milla_midair_down_right:  {milla_tail_visible = 1; break;}
                case anim_milla_standing_with_cube: {milla_tail_visible = 1; break;}
                case anim_victory:                  {milla_tail_visible = 1; break;}
                //In every other case, the tail should be invisible
                default:                            {milla_tail_visible = 0; break;}
            }
        //Iterate Tail Animations If The Tail Is Visible
        if milla_tail_visible = 1 milla_tail_sprite_frame += 0.2004;
        //Reset Tail Animations After They Have Completed
        if milla_tail_sprite_frame &gt; 7.8 milla_tail_sprite_frame = 0;
        //Set rotation axis for tail sprites
        milla_tail_x = px + lengthdir_x(milla_tail_offset,angle_a+90)
        milla_tail_y = py + lengthdir_y(milla_tail_offset,angle_a+90)
        //Modify tail sprite offsets based on which animations are playing
        if anim_current = anim_hanging_idle milla_tail_offset = 9;
        else                                milla_tail_offset = 16;
        //Modify tail's facing direction based on which animations are playing, but not if we are holding (or throwing) a cube
        if anim_current = anim_wall_pushing and (milla_phantom_mode=0 or milla_phantom_mode=3) milla_tail_dir = -xdir;
        else                                                                                   milla_tail_dir = xdir;

        //===========Death Animation===========//

        //If we have died, override normal animations
        if death[0] = 1
            {
                //Disable FOF collisions
                tile_surface_id[5] = 0
                tile_surface_asset = 0
                //Stay on this frame of animation while we are not touching the ground
                if frame &lt; anim_milla[anim_death,0] frame = anim_milla[anim_death,0];
                if ground = 0 frame = anim_milla[anim_death,0];
                //Complete the animation once we are
                if ground = 1
                    {
                        if frame &lt; anim_milla[anim_death,0] frame = anim_milla[anim_death,0];
                        if frame &lt; anim_milla[anim_death,1]+0.9 frame += anim_milla[anim_current,3];
                    }
            }

        //==========Victory Animation==========//

        //If we have landed after breaking all the targets, trigger the victory animation
        if targets_ready = 3 and ground = 1
            {
                //Set the current animation frame to the beginning of the animation, if it wasn't before
                if frame &lt; anim_milla[anim_victory,0] or frame &gt; anim_milla[anim_victory,1]+1 frame = anim_milla[anim_victory,0];
                //Play the animation to the end
                if frame &lt; anim_milla[anim_victory,1] frame += anim_milla[anim_victory,3];
            }

        //Block-Pushing Animations
        if xcompass = 0 and ground = 1 and hcap = 5 and joy_input[1,3] = 0 and gravity_rail_check = 0
            scr_set_block_pushing();

        //If we are swimming, accelerate animation speeds
        //based on the player's movement speed
        if above_water = 0
            {
                if gravity_rail_check = 0 and anim_current = anim_milla_rail_grinding
                    {
                        if hsp = 0 anim_current = anim_standing;
                        else       anim_current = anim_walking;
                        scr_set_rail_grinding_stop();
                    }
                var sink_yes = 0;
                if instance_exists(water_ID)
                    {
                        if water_ID.object_index = obj_mud_cube
                        or water_ID.object_index = obj_mud_water
                            {
                                sink_yes = 1;
                                if ground = 0 and Animations_Override = 0 and attack[0]=0
                                and hurt[0] = 0 and gravity_ladder = 0 and milla_special_attack = 0
                                and anim_current != anim_falling
                                    anim_current = anim_falling;
                            }
                    }
                if ground = 0 and Animations_Override = 0 and attack[0]=0
                and hurt[0] = 0 and gravity_ladder = 0
                and sink_yes = 0
                    {
                        var anim_swim_speed = abs(hsp/24);
                        if hsp &gt; -dec and hsp &lt; dec
                            anim_swim_speed = 0.125;
                        if anim_current != anim_swimming and joy_input[1,3] = 0 anim_current = anim_swimming;
                        if frame &lt; anim_milla[anim_swimming,0] or frame &gt; anim_milla[anim_swimming,1]+0.8
                            frame = anim_milla[anim_swimming,0];
                        frame += 0.12+anim_swim_speed
                        if frame &gt; anim_milla[anim_swimming,1]+0.8
                            frame = anim_milla[anim_swimming,2];
                    }
            }
        if above_water = 1 and anim_current = anim_swimming
            {
                if ground = 1 anim_current = anim_standing;
                else          anim_current = anim_jump;
            }

        //          Animation Overrides          //
        //=======================================//
        
        //Enforce an override of generic animations, to avoid
        //conflicts with the generic movement system
        
        switch(anim_current)
            {
                case anim_milla_digging:            {Animations_Override = 1; break;}
                case anim_milla_attack_up_right:    {Animations_Override = 1; break;}
                case anim_milla_attack_right:       {Animations_Override = 1; break;}
                case anim_milla_attack_down_right:  {Animations_Override = 1; break;}
                case anim_milla_midair_up_right:    {Animations_Override = 1; break;}
                case anim_milla_midair_right:       {Animations_Override = 1; break;}
                case anim_milla_midair_down_right:  {Animations_Override = 1; break;}
                case anim_milla_standing_with_cube: {Animations_Override = 1; break;}
                case anim_milla_walking_with_cube:  {Animations_Override = 1; break;}
                case anim_milla_jumping_with_cube:  {Animations_Override = 1; break;}
                case anim_milla_falling_with_cube:  {Animations_Override = 1; break;}
                case anim_milla_flutter:            {Animations_Override = 1; break;}
                //Assume the override is disabled in every other case
                default:
                    {
                        Animations_Override = 0;
                        active_attack = 0;
                        milla_special_attack = 0;
                        milla_special_shield_frame = 0;
                        break;
                    }
            }
}//End of Milla Check
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Spade Action System

//Do not execute code if we are not Spade
if skin = spr_spade and user_cursor_mode = 0 and pause = 0
    {
        if anim_idle_timer &gt;= 120 and tile_angle = 0
            {
                var disco_id = collision_circle(universal_player_x,universal_player_y,256,obj_disco_ball,false,true);
                if instance_exists(disco_id)
                    {
                        anim_current = anim_spade_dancing
                        if frame &lt; anim_spade[anim_spade_dancing,0]
                            {
                                frame = anim_spade[anim_spade_dancing,0]
                                
                            }
                    }
            }
        if sit = 1
            {
                var bench_id = collision_circle(px,py,24,obj_bench,false,true);
                if instance_exists(bench_id)
                    {
                        px = lerp(px,bench_id.x,0.25);
                        xdir = 1
                        anim_current = anim_spade_sitting
                        if frame &lt; anim_spade[anim_spade_sitting,0]
                            {
                                frame = anim_spade[anim_spade_sitting,0]
                            }
                    }
                else
                    sit = 0;
                sit_timer += 1

                if (sit_timer &gt; 30)
                and (joy_input[0,0] = 1
                or joy_input[0,1] = 1
                or joy_input[0,2] = 1
                or joy_input[0,3] = 1
                or joy_input[1,0] = 1
                or joy_input[1,1] = 1
                or joy_input[1,2] = 1
                or joy_input[1,3] = 1
                or joy_input[1,4] = 1)
                    {
                        sit = 0
                        sit_timer = 0
                        anim_current=anim_standing
                    }
            }
        //================Post Speed Checks================//

        //Make sure we cannot go above 15px/f under any circumstances, by resetting movement to 15px/s
        //at the beginning of each step, if it is above 15px/f
        if hsp &gt;  15 hsp =  15;
        if hsp &lt; -15 hsp = -15;
        //Never allow the player to go above 15px/f upwards, either
        if gravity_speed &lt; -15 gravity_speed = -15;
        if gravity_speed &gt; 15  gravity_speed = floor(15);
        //Prevent player from leaving the boundaries of the camera
        if use_maps_multi_map_mode = 0 and (room != rm_campaign)
            {
                if px &lt; camera_boundary_left+15  {px = camera_boundary_left+15;  hsp = 0;}
                if px &gt; camera_boundary_right-15 {px = camera_boundary_right-15; hsp = 0;}
            }
        //Prevent player from infinitely flying above the ceiling
        if py &lt; camera_boundary_top-64
            py = camera_boundary_top-64;
        if (use_maps_multi_map_mode = 1) or (room = rm_campaign)
            {
                if px &lt; camera_boundary_left+15  {px = camera_boundary_left+15;  hsp = 0;}
                if (px &gt; camera_boundary_right-32 and room != rm_editor)
                    {
                        if (use_maps_boundary = 0)
                        or (room = rm_campaign and campaign_stage_select &lt; campaign_stage_section_limit)
                            {
                                //Fade to black after a certain period of time
                                transition_alpha+=0.1288
                                transition_timer += 1
                                px += 3
                                if ground = 1
                                    {
                                        anim_current=anim_walking;
                                        anim_previous=anim_walking;
                                    }
                                else
                                    {
                                        if px &lt; camera_boundary_right py += 2.5;
                                        anim_current=anim_falling;
                                    }
                                if transition_timer &gt;=114
                                    {
                                        transition_loading = 1;
                                        transition_alpha = 1;
                                        transition_timer = 0;
                                        now_loading = 1;
                                        use_maps_current_map += 1;
                                        checkpoint_x = 0
                                        checkpoint_y = 0
                                        if room = rm_campaign
                                            {
                                                dont_change_music = 1
                                                use_maps_current_map = 0
                                                campaign_stage_select += 1
                                                use_cuts_select = campaign_stage_section[campaign_stage_select]
                                            }
                                        use_maps_load = 1
                                    }
                                joy_input[2,6] = 30
                            }
                        else
                            {
                                if px &gt; camera_boundary_right-15
                                    {
                                        px = camera_boundary_right-15;
                                        hsp = 0;
                                    }
                            }
                    }
                if room = rm_editor
                    {
                        if px &gt; camera_boundary_right-15 {px = camera_boundary_right-15; hsp = 0;}
                    }
            }

        //================Manage Spade HUD Elements================//

        if card_flip_frame &lt; 12
            card_flip_frame += 0.5;

        card_shine_frame += 0.45
        if card_shine_frame &gt; 30
            card_shine_frame = 0;
        if cards &lt; 16
            {
                cards += 0.025;
                if cards = 2
                or cards = 4
                or cards = 6
                or cards = 8
                or cards = 10
                or cards = 12
                or cards = 14
                or cards = 16
                    {
                        card_flip_x = 12*(cards/2)
                        card_flip_frame = 0
                    }
            }
        if cards &gt; 16
            cards = 16;

        //Increment stamina faster while on the ground, on ladders/hangbars, or swimming inside water
        if (ground = 1 or above_water = 0 or gravity_ladder &gt; 0)
            {
                if stamina &lt; 96
                    stamina += 0.4;
                spade_dash_hor_limit = 0
                spade_dash_ver_limit = 0
                spade_dual_crash_sfx = 0
            }

        //           Action System Core           //
        //========================================//

        //Input Locking
        if joy_input[1,0] = 1 spade_attack_button += 1;  else spade_attack_button = 0;
        if joy_input[1,2] = 1 spade_jump_button += 1;    else spade_jump_button = 0;
        if joy_input[1,3] = 1 spade_special_button += 1; else spade_special_button = 0;
        if joy_input[1,4] = 1 spade_switch_button += 1;  else spade_switch_button = 0;

        if spade_card_toss_cooldown_timer &gt; 0
            spade_card_toss_cooldown_timer -= 1;

        //Hang Bar Jump Button Locking
        if gravity_ladder != 0            spade_hang_bar_jump  = 16;
        else {if spade_hang_bar_jump &gt; 0  spade_hang_bar_jump -= 1;}

        //Reset Attack Button Locking If An NPC Is Nearby
        if spade_attack_button &gt; 0
            {
                var npc_check = instance_nearest(universal_player_x,universal_player_y,obj_interact_parent);
                if instance_exists(npc_check)
                    {
                        if point_distance(npc_check.x,npc_check.y,universal_player_x,universal_player_y) &lt; 64
                            {
                                if ((px &gt; npc_check.x and xdir = -1)
                                or  (px &lt;= npc_check.x and xdir = 1))
                                    spade_attack_button = 0;
                            }
                    }
            }

        //==================================== Card Toss ====================================//

        if gravity_ladder = 0 and spade_hang_bar_jump = 0
            {
                //Card Toss
                if spade_attack_button = 1 and spade_card_toss_cooldown_timer = 0
                and hurt[0] = 0
                    {
                        if ground = 1
                            {
                                if anim_current = anim_ducking 
                                    anim_current = anim_spade_crouch_attack;
                                else
                                    anim_current = anim_spade_attack;
                            }
                        else
                            anim_current = anim_spade_midair_attack;

                        frame = anim_spade[anim_current,0]

                        var spade_card_0 = instance_create(universal_player_x,universal_player_y,obj_player_card);
                        var spade_card_1 = instance_create(universal_player_x,universal_player_y,obj_player_card);
                        var spade_card_2 = instance_create(universal_player_x,universal_player_y,obj_player_card);
                        var spade_card_3 = instance_create(universal_player_x,universal_player_y,obj_player_card);
                        if xdir = -1
                            {
                                //Up-Left
                                if joy_input[0,3] = 1 and joy_input[0,1] = 0
                                    {
                                        spade_card_0.direction = angle_a+180-45
                                        spade_card_1.direction = angle_a+180-60
                                        spade_card_2.direction = angle_a+180-65
                                        spade_card_3.direction = angle_a+180-30
                                    }
                                //Neutral
                                if joy_input[0,3] = 0 and joy_input[0,1] = 0
                                    {
                                        spade_card_0.direction = angle_a+180
                                        spade_card_0.damage = 4
                                        spade_card_1.direction = angle_a+180-15
                                        spade_card_2.direction = angle_a+180-20
                                        spade_card_3.direction = angle_a+180+15
                                    }
                                //Down-Left
                                if joy_input[0,3] = 0 and joy_input[0,1] = 1
                                    {
                                        spade_card_0.direction = angle_a+180+45
                                        spade_card_1.direction = angle_a+180+60
                                        spade_card_2.direction = angle_a+180+65
                                        spade_card_3.direction = angle_a+180+30
                                    }
                            }
                        if xdir = 1
                            {
                                //Up-Right
                                if joy_input[0,3] = 1 and joy_input[0,1] = 0
                                    {
                                        spade_card_0.direction = angle_a+45
                                        spade_card_1.direction = angle_a+60
                                        spade_card_2.direction = angle_a+65
                                        spade_card_3.direction = angle_a+30
                                    }
                                //Neutral
                                if joy_input[0,3] = 0 and joy_input[0,1] = 0
                                    {
                                        spade_card_0.direction = angle_a
                                        spade_card_0.damage = 4
                                        spade_card_1.direction = angle_a+15
                                        spade_card_2.direction = angle_a+20
                                        spade_card_3.direction = angle_a-15
                                    }
                                //Down-Right
                                if joy_input[0,3] = 0 and joy_input[0,1] = 1
                                    {
                                        spade_card_0.direction = angle_a-45
                                        spade_card_1.direction = angle_a-60
                                        spade_card_2.direction = angle_a-65
                                        spade_card_3.direction = angle_a-30
                                    }
                            }
                        spade_card_0.bak_speed = abs(hsp)+5
                        spade_card_1.bak_speed = abs(hsp)+5
                        spade_card_2.bak_speed = abs(hsp)+5
                        spade_card_3.bak_speed = abs(hsp)+5
                        //Play Voice Sample
                        var voice_sample = random_range(0,3.9)
                        switch(floor(voice_sample))
                            {
                                case 0: {audio_play_sound(spade_attack_1,50,false); break;}
                                case 1: {audio_play_sound(spade_attack_2,50,false); break;}
                                case 2: {audio_play_sound(spade_attack_1,50,false); break;}
                                case 3: {break;}
                            }
                        audio_play_sound(spade_card_toss,50,false)
                        spade_card_toss_cooldown_timer = 20
                    }

                //==================================== Dash Attack ====================================//

                if (spade_jump_button = 1 or spade_switch_button = 1) and ground = 0 and above_water = 1
                and stamina &gt; 35 and anim_current != anim_spade_dual_crash and hurt[0] = 0
                    {
                        spade_dash_hor_limit += 1
                        spade_dash_ver_limit += 0.50

                        if spade_dash_hor_limit &gt; 2
                            spade_dash_hor_limit = 2;

                        if spade_dash_ver_limit &gt; 2
                            spade_dash_ver_limit = 2;
                        
                        //Down-Left
                        if  joy_input[0,3] = 0 and joy_input[0,1] = 1
                        and joy_input[0,0] = 0 and joy_input[0,2] = 1
                            {
                                hsp = -gravity_jump + spade_dash_hor_limit
                                gravity_speed = gravity_jump
                                scr_set_spade_dash();
                            }
                        //Left
                        if (joy_input[0,3] = 0 and joy_input[0,1] = 0
                        and joy_input[0,0] = 0 and joy_input[0,2] = 1)
                        or (joy_input[0,3] = 0 and joy_input[0,1] = 0
                        and joy_input[0,0] = 0 and joy_input[0,2] = 0
                        and xdir = -1)
                            {
                                if (hsp &gt; -12 and hsp &lt; -5)  hsp = -12;
                                if (hsp &gt; -10) hsp = -10;
                                if (hsp &lt; -12) hsp = -16;
                                hsp = hsp + spade_dash_hor_limit;
                                gravity_speed = 0
                                scr_set_spade_dash();
                            }
                        //Up-Left
                        if  joy_input[0,3] = 1 and joy_input[0,1] = 0
                        and joy_input[0,0] = 0 and joy_input[0,2] = 1
                            {
                                hsp = -gravity_jump*1.25 + spade_dash_hor_limit
                                gravity_speed = -gravity_jump + spade_dash_ver_limit
                                scr_set_spade_dash();
                                spade_dash_ver_speed = -gravity_jump + spade_dash_ver_limit
                            }
                        //Up
                        if  joy_input[0,3] = 1 and joy_input[0,1] = 0
                        and joy_input[0,0] = 0 and joy_input[0,2] = 0
                            {
                                hsp = 0
                                gravity_speed = -gravity_jump + spade_dash_ver_limit
                                scr_set_spade_dash();
                                spade_dash_ver_speed = -gravity_jump + spade_dash_ver_limit
                                anim_current = anim_spade_dashing_ver
                                spade_animation_dash_timer = 0
                            }
                        //Up-Right
                        if  joy_input[0,3] = 1 and joy_input[0,1] = 0
                        and joy_input[0,0] = 1 and joy_input[0,2] = 0
                            {
                                hsp = gravity_jump - spade_dash_hor_limit
                                gravity_speed = -gravity_jump + spade_dash_ver_limit
                                scr_set_spade_dash();
                                spade_dash_ver_speed = -gravity_jump + spade_dash_ver_limit
                            }
                        //Right
                        if (joy_input[0,3] = 0 and joy_input[0,1] = 0
                        and joy_input[0,0] = 1 and joy_input[0,2] = 0)
                        or (joy_input[0,3] = 0 and joy_input[0,1] = 0
                        and joy_input[0,0] = 0 and joy_input[0,2] = 0
                        and xdir = 1)
                            {
                                if (hsp &gt; 5 and hsp &lt; 12)  hsp = 12;
                                if (hsp &lt; 10) hsp = 10;
                                if (hsp &gt; 12) hsp = 16;
                                hsp = hsp - spade_dash_hor_limit
                                gravity_speed = 0
                                scr_set_spade_dash();
                            }
                        //Down-Right
                        if  joy_input[0,3] = 0 and joy_input[0,1] = 1
                        and joy_input[0,0] = 1 and joy_input[0,2] = 0
                            {
                                hsp = gravity_jump - spade_dash_hor_limit
                                gravity_speed = gravity_jump
                                scr_set_spade_dash();
                            }
                        //Down
                        if  joy_input[0,3] = 0 and joy_input[0,1] = 1
                        and joy_input[0,0] = 0 and joy_input[0,2] = 0
                            {
                                hsp = 0
                                gravity_speed = 10
                                scr_set_spade_dash();
                            }
                    }
                //Ground Dash
                if spade_switch_button = 1 and ground = 1 and stamina &gt; 35
                and anim_current != anim_spade_dual_crash and hurt[0] = 0
                    {
                        //Left
                        if (joy_input[0,3] = 0 and joy_input[0,1] = 0
                        and joy_input[0,0] = 0 and joy_input[0,2] = 1)
                        or (joy_input[0,3] = 0 and joy_input[0,1] = 0
                        and joy_input[0,0] = 0 and joy_input[0,2] = 0
                        and xdir = -1)
                            {
                                if (hsp &gt; -10 and hsp &lt; -5) hsp = -10;
                                if (hsp &gt; -10) hsp = -10;
                                //if (hsp &lt; -10) hsp = -10;
                                scr_set_spade_dash();
                            }
                        //Right
                        if (joy_input[0,3] = 0 and joy_input[0,1] = 0
                        and joy_input[0,0] = 1 and joy_input[0,2] = 0)
                        or (joy_input[0,3] = 0 and joy_input[0,1] = 0
                        and joy_input[0,0] = 0 and joy_input[0,2] = 0
                        and xdir = 1)
                            {
                                if (hsp &gt; 5 and hsp &lt; 10) hsp = 10;
                                if (hsp &lt; 10) hsp = 10;
                                //if (hsp &gt; 10) hsp = 10;
                                scr_set_spade_dash();
                            }
                    }
                if anim_current = anim_spade_dashing_ver
                    {
                        if gravity_speed &gt; -2.5
                            anim_current = anim_falling;
                        if spade_jump_button &gt; 0 and spade_dash_ver_timer &lt; 15
                        and tile_collision_ceiling = 0
                            {
                                spade_dash_ver_timer += 1
                                hsp = 0
                                gravity_speed = spade_dash_ver_speed
                            }
                    }
                if spade_animation_dash_timer &gt; 0
                    {
                        anim_current = anim_spade_dashing_hor
                        if spade_animation_dash_direction = 1
                            gravity_speed = 0;

                        if spade_jump_button &gt; 0
                        and tile_collision_ceiling = 0
                        and wall_collision_left = 0
                        and wall_collision_right = 0
                        and ground = 0 and spring_timer = -1
                            {
                                spade_dash_ver_timer += 1
                                hsp = spade_dash_hor_speed
                                gravity_speed = spade_dash_ver_speed
                            }

                        spade_animation_dash_timer -= 1
                        if spade_animation_dash_timer &lt;= 0
                            {
                                anim_current = anim_falling
                                spade_animation_dash_timer = 0
                            }
                    }
                spade_affect_effects_timer += 1
                switch(spade_affect_effects_timer)
                    {
                        case 0: {break;}
                        case 1: {hurt_invuln = 0; spade_explosion_effect_frame = 0; spade_explosion_effect_x = universal_player_x; spade_explosion_effect_y = universal_player_y; break;}
                        case 2: {break;}
                        case 3: {spade_affect_effects_x[0] = px; spade_affect_effects_y[0] = py; spade_affect_effects_alpha[0] = 0.8 spade_affect_effects_xdir[0] = xdir; spade_affect_effects_angle[0] = angle_a; break;}
                        case 4: {spade_sparkle_effects_x[0] = universal_player_x+random_range(-16,16); spade_sparkle_effects_y[0] = universal_player_y+random_range(-16,16); spade_sparkle_effects_frame[0] = 0; break;}
                        case 5: {break;}
                        case 6: {break;}
                        case 7: {spade_affect_effects_x[1] = px; spade_affect_effects_y[1] = py; spade_affect_effects_alpha[1] = 0.8 spade_affect_effects_xdir[1] = xdir; spade_affect_effects_angle[1] = angle_a; break;}
                        case 8: {spade_sparkle_effects_x[1] = universal_player_x+random_range(-16,16); spade_sparkle_effects_y[1] = universal_player_y+random_range(-16,16); spade_sparkle_effects_frame[1] = 0; break;}
                        case 9: {break;}
                        case 10: {spade_sparkle_effects_x[2] = universal_player_x+random_range(-16,16); spade_sparkle_effects_y[2] = universal_player_y+random_range(-16,16); spade_sparkle_effects_frame[2] = 0; break;}
                        case 11: {spade_affect_effects_x[2] = px; spade_affect_effects_y[2] = py; spade_affect_effects_alpha[2] = 0.8 spade_affect_effects_xdir[2] = xdir; spade_affect_effects_angle[2] = angle_a; break;}
                        case 12: {break;}
                        case 13: {spade_sparkle_effects_x[3] = universal_player_x+random_range(-16,16); spade_sparkle_effects_y[3] = universal_player_y+random_range(-16,16); spade_sparkle_effects_frame[3] = 0; break;}
                        case 14: {break;}
                        case 15: {spade_affect_effects_x[3] = px; spade_affect_effects_y[3] = py; spade_affect_effects_alpha[3] = 0.8 spade_affect_effects_xdir[3] = xdir; spade_affect_effects_angle[3] = angle_a; break;}
                    }
                if spade_affect_effects_timer &gt; 0 and spade_affect_effects_timer &lt; 12
                    {
                        //Bomb Cube
                        var instance_ID = collision_circle(universal_player_x,universal_player_y,32,obj_player_cube_alt,false,true);
                        if instance_ID != noone
                            {
                                if instance_ID.cube_jiggle_timer = 0
                                    {
                                        instance_ID.cube_jiggle_timer = 10
                                        instance_ID.cube_health += 0.50
                                        instance_ID.cube_speed = 5*xdir
                                    }
                            }
                        //Mega Items
                        var instance_ID = collision_circle(universal_player_x,universal_player_y,32,obj_mega_item_parent,false,true);
                        if instance_ID != noone
                            {
                                instance_ID.attacked = 2
                            }
                        //Items
                        var instance_ID = collision_circle(universal_player_x,universal_player_y,32,obj_destructible,false,true);
                        if instance_ID != noone
                            {
                                instance_ID.attacked = 1
                            }
                        //Attack other enemies within range of the boxing glove
                        instance_ID = collision_circle(universal_player_x,universal_player_y,32,obj_enemy_parent,false,true);
                        if instance_exists(instance_ID)
                            {
                                if instance_ID.attacked = 0 and instance_ID.alpha = 0
                                    {
                                        instance_ID.attacked = 1
                                        instance_ID.attacked_damage = 6
                                        //Deal more damage, if we are crashing straight down
                                        if hsp = 0 and gravity_speed &gt; 0
                                            {
                                                instance_ID.attacked_damage = 8
                                                scr_set_screen_shake(4,3)
                                                audio_play_sound(spade_dual_crash,50,false)
                                            }
                                        if user_freeze_frames = 1
                                            pause_logic = 5;
                                        else
                                            milla_pause_logic = 5;
                                    }
                            }
                    }

                //==================================== Dual Crash ====================================//

                //Middle Mouse Button Substitute
                if joy_mouse_button_switch = 1
                    {
                        if spade_attack_button &gt; 12
                            spade_special_button += 1;
                    }
                if spade_special_button_cooldown_timer &gt; 0
                    spade_special_button_cooldown_timer -= 1;
                if spade_special_button &gt; 0 and cards &gt; 2 and spade_special_button_cooldown_timer = 0 and hurt[0] = 0
                    {
                        if anim_current = anim_swimming
                            {
                                anim_current = anim_spade_dual_crash
                                frame = anim_spade[39,0]
                            }
                        anim_current = anim_spade_dual_crash
                        spade_special_button_cooldown_timer = 10
                        if ground = 1 and gravity_slope = 0 and gravity_fof = 0
                            spade_dual_crash_air_timer = 3;
                        //If we were on a slope, influence the jump speed based on angle
                        if (gravity_slope = 1 or tile_surface_wall_xcompass != 0 or gravity_fof &gt; 0)
                            {
                                //Determine the general direction of the jump by the player's X/Y coordinates
                                var jump_length_x = lengthdir_x(gravity_jump,tile_angle+90)
                                var jump_length_y = lengthdir_y(gravity_jump,tile_angle+90)
                                //Determine the additional speed of the jump by another orbit
                                var speed_length_y = lengthdir_y(hsp,tile_angle)
                                //Apply horizontal and vertical speed to the player based on the difference
                                if tile_angle != 0 hsp = jump_length_x+hsp
                                gravity_speed = jump_length_y+speed_length_y
                                //Set fling timer to prevent the player from overriding their horizontal speed
                                if xcompass != 0 and not (angle_a &lt;= 90 and xdir=-1) and not (angle_a &gt;= 270 and xdir=1)
                                    {
                                        hsp = jump_length_x;
                                        fling_timer = 8;
                                        fling_hsp=hsp;
                                    }
                                //If we were jumping off of a flat wall, reset direction of gravity speed
                                if (tile_angle = 270 and xdir = -1) or (tile_angle = 90 and xdir = 1)
                                    {
                                        fling_ver_timer = 8
                                        fling_vsp = -abs(jump_length_y+speed_length_y)
                                    }
                                if (tile_angle = 270 and xdir = 1 or tile_angle = 90 and xdir = -1)
                                    {
                                        fling_ver_timer = 8
                                        fling_vsp = abs(jump_length_y+speed_length_y)
                                    }
                                //If we were on a one-way platform, jump from it with extra speed
                                if (gravity_fof&gt;0)
                                    {
                                        gravity_fof=0 gravity_speed = -gravity_jump-0.75
                                    }
                                //Override slope clipping for this one frame
                                gravity_slope = 0
                                xcompass = 0                        //Override current tile compass direction
                                tile_check_slope_priority = 0       //Slope Priority For Flat Surface Running
                                tile_surface_wall_xcompass = 0      //Tile Compass For Flat Surface Running
                            }
                        if ground = 0
                            {
                                //Override slope clipping for this one frame
                                gravity_slope = 0
                                ground = 0
                                xcompass = 0                        //Override current tile compass direction
                                tile_check_slope_priority = 0       //Slope Priority For Flat Surface Running
                                tile_surface_wall_xcompass = 0      //Tile Compass For Flat Surface Running
                                if tile_collision_ceiling = 0
                                    gravity_speed = -2;
                            }
                        var spade_card_0 = instance_create(universal_player_x,universal_player_y+4,obj_player_card);
                        if xdir = -1
                            spade_card_0.direction = 225;
                        if xdir = 1
                            spade_card_0.direction = 315;
                        spade_card_0.sprite_index = spr_special_card
                        spade_card_0.power_level = 1
                        //Base card toss speeds
                        if hsp &lt;= 5
                            spade_card_0.bak_speed = 12
                        //Scattershot effect at higher speeds
                        if abs(hsp) &gt; 5
                            spade_card_0.bak_speed = abs(hsp)+12
                        if spade_dual_crash_sfx = 0
                            {
                                //Play Voice Sample
                                var voice_sample = random_range(0,3.9)
                                switch(floor(voice_sample))
                                    {
                                        case 0: {audio_play_sound(spade_attack_1,50,false); break;}
                                        case 1: {audio_play_sound(spade_attack_2,50,false); break;}
                                        case 2: {audio_play_sound(spade_attack_1,50,false); break;}
                                        case 3: {break;}
                                    }
                                spade_dual_crash_sfx = 1;
                            }
                        audio_play_sound(spade_whistle,50,false)
                        cards -= 1
                        spade_dual_crash_second_draw_timer = 1
                    }
                if anim_current = anim_spade_dual_crash and spade_dual_crash_second_draw_timer &gt; 0
                    {
                        spade_dual_crash_second_draw_timer += 1
                        //Cancel second card draw early
                        if spade_special_button = 0 and spade_dual_crash_second_draw_timer &lt; 2
                        or cards &lt; 2
                            {
                                spade_dual_crash_second_draw_timer = 0
                            }
                        if spade_dual_crash_second_draw_timer = 11
                            {
                                var spade_card_1 = instance_create(universal_player_x,universal_player_y+4,obj_player_card);
                                if xdir = -1
                                    spade_card_1.direction = 225;
                                if xdir = 1
                                    spade_card_1.direction = 315;
                                spade_card_1.sprite_index = spr_special_card
                                spade_card_1.power_level = 1
                                //Base card toss speeds
                                if hsp &lt;= 5
                                    spade_card_1.bak_speed = 12;
                                //Scattershot effect at higher speeds
                                if abs(hsp) &gt; 5
                                    spade_card_1.bak_speed = abs(hsp)+12;
                                audio_play_sound(spade_whistle,50,false)
                                cards -= 1
                                spade_dual_crash_second_draw_timer = 0
                            }
                    }
            }
        else
            {
                if spade_dash_hor_speed != 0
                or spade_dash_ver_speed != 0
                    scr_set_spade_dash_disable();
            }
        if spade_dual_crash_air_timer &gt; 0
            {
                gravity_speed -= 4
                spade_dual_crash_air_timer -=1
                if spring_timer &gt; 0
                    spade_dual_crash_air_timer = 0;
            }

        //End of attack animations
        var spade_attack_check = 0;
        if (anim_current=anim_spade_attack
        or  anim_current=anim_spade_crouch_attack
        or  anim_current=anim_spade_midair_attack
        or  anim_current=anim_spade_dual_crash)
            {
                spade_attack_check = 1
                if (frame &gt;= anim_spade[anim_current,1])
                    {
                        if anim_current = anim_spade_dual_crash
                            anim_current = anim_falling;
                        //Wait to cancel animations first
                        spade_animation_loop_delay += 1
                        if spade_animation_loop_delay &gt; 16
                            {
                                if anim_current=anim_spade_crouch_attack
                                    anim_current=anim_ducking;
                                else
                                    anim_current = anim_standing;
                                spade_animation_loop_delay = 0
                            }
                    }
            }

        //          Animation System Core          //
        //=========================================//
        //Make sure we aren't dead, before allowing normal animations
        if death[0] = 0 and not (targets_ready = 3 and ground = 1)
            {
                if gravity_rail_check = 1 and spade_attack_check = 0
                    {
                        anim_current = anim_spade_rail_grinding;
                        if frame &lt; anim_spade[anim_spade_rail_grinding,0] or frame &gt; anim_spade[anim_spade_rail_grinding,1]+0.8
                            frame = anim_spade[anim_spade_rail_grinding,0];
                        if above_water = 0 and ground = 0
                            {
                                anim_current = anim_swimming
                                scr_set_rail_grinding_stop()
                            }
                    }
                //Perpetually advance frames based on provided speed,
                //if we are not using aerial attacks
                if  anim_current!=anim_ladder_climbing
                and anim_current!=anim_swimming
                and anim_current!=anim_spring
                and anim_current!=anim_faster
                and anim_current!=anim_walking
                    frame += anim_spade[anim_current,3]
                //If a new animation has started, initialize the new animation
                if anim_previous!=anim_current
                    {
                        frame = anim_spade[anim_current,0]  //Set starting frame of animation
                        anim_previous=anim_current          //Disable triggered breakpoint
                    }

                //============Speed Modifiers============//
        
                //If we are bouncing on a spring, increase animation
                //speed based on a timer
                if anim_current=anim_spring
                    {
                        frame += spring_anim_mod*1.67
                        //Decrement animation modifier
                        if spring_anim_mod &gt; 0.16 spring_anim_mod -= 0.025;
                        //End springing animation if it hasn't already
                        if spring_timer=-1 anim_current=anim_falling;
                    }
                //If we are running, increase animation speed based on horizontal speed
                if anim_current=anim_faster or anim_current=anim_walking
                    frame += anim_spade[anim_current,3]+abs(hsp)/56;
        
                //============Special Actions============//
        
                //Key Release for Wall Pushing Animation
                if (anim_current=anim_wall_pushing and hsp!=0 and ground=1)
                or (anim_current=anim_wall_pushing and joy_input[0,0] = 0 and joy_input[0,2] = 0 and ground=1)
                or (anim_current=anim_wall_pushing and ground=0)
                    anim_current=anim_standing;
                //If we are on a ladder, animations should play forwards or in reverse based on input
                //Enforce ladder climbing state, if we are in the cyclone state
                if ladder_state = 0
                    {
                        if gravity_ladder = 1 and attack[2] &gt; 0 anim_current=anim_ladder_climbing;
                        if anim_current=anim_ladder_climbing
                            {
                                //Climbing up
                                if joy_input[0,3] = 1 and joy_input[0,1] = 0 frame += anim_spade[anim_current,3];
                                //Climbing Down
                                if joy_input[0,3] = 0 and joy_input[0,1] = 1
                                    {
                                        frame -= anim_spade[anim_current,3]
                                        //If we are playing frames below the current animation, restart animation loop from
                                        //its endpoint instead
                                        if frame &lt; anim_spade[anim_current,0]+0.40 frame = anim_spade[anim_current,1];
                                    }
                            }
                    }
                //Idle Animation
                if anim_current = anim_standing
                    {
                        //Iterate idle timer
                        anim_idle_timer += 1
        
                        //If the timer has reached its limit, start the idle animation
                        if anim_idle_timer = 530
                            {
                                anim_current = anim_idle_1
                                frame = anim_spade[anim_idle_1,0]
                            }
                        //If the timer has exceeded its limit, reset the timer
                        if anim_idle_timer &gt; 530 anim_idle_timer = 0;
                    }
                //If we have moved or attacked at all, reset iteration timer
                if hsp!=0 or gravity_speed!=0 anim_idle_timer = 0;
                //If we have reached the end of the animation, reset idle timer and return to the standing animation
                if anim_current = anim_idle_1 and frame &gt; anim_spade[anim_idle_1,2]+0.8
                    {
                        anim_idle_timer = 0
                        anim_current = anim_standing
                    }
        
                //If we are above the ending frame, restart the animation at the desired loop point
                if frame &gt; anim_spade[anim_current,1]+0.8 frame = anim_spade[anim_current,2];
            }

        //===========Death Animation===========//

        //If we have died, override normal animations
        if death[0] = 1
            {
                //Disable FOF collisions
                tile_surface_id[5] = 0
                tile_surface_asset = 0
                //Stay on this frame of animation while we are not touching the ground
                if ground = 0 frame = anim_spade[anim_death,0];
                //Complete the animation once we are
                if (ground = 1)
                    {
                        if frame &lt; anim_spade[anim_death,0] frame = anim_spade[anim_death,0];
                        if frame &lt; anim_spade[anim_death,1] frame += anim_spade[anim_death,3];
                    }
            }

        //==========Victory Animation==========//

        //If we have landed after breaking all the targets, trigger the victory animation
        if targets_ready = 3 and ground = 1
            {
                //Set the current animation frame to the beginning of the animation, if it wasn't before
                if frame &lt; anim_spade[anim_victory,0] frame = anim_spade[anim_victory,0];
                //Play the animation to the end
                if frame &lt; anim_spade[anim_victory,1] frame += anim_spade[anim_victory,3];
            }

        //Block-Pushing Animations
        if xcompass = 0 and ground = 1 and attack[0]=0 and gravity_rail_check = 0
            scr_set_block_pushing();

        //          Animation Overrides          //
        //=======================================//
        
        //Enforce an override of generic animations, to avoid
        //conflicts with the generic movement system
        
        switch(anim_current)
            {
                case anim_spade_attack:         {Animations_Override = 1; break;}
                case anim_spade_crouch_attack:  {Animations_Override = 1; break;}
                case anim_spade_midair_attack:  {Animations_Override = 1; break;}
                case anim_spade_dual_crash:     {Animations_Override = 1; break;}
                //Assume the override is disabled in every other case
                default:                        {Animations_Override = 0; active_attack = 0; gravity_override = 0; break;}
            }

        //If we are swimming, accelerate animation speeds
        //based on the player's movement speed
        if above_water = 0
            {
                if gravity_rail_check = 0 and anim_current = anim_spade_rail_grinding
                    {
                        if hsp = 0 anim_current = anim_standing;
                        else       anim_current = anim_walking;
                        scr_set_rail_grinding_stop();
                    }
                var sink_yes = 0;
                if instance_exists(water_ID)
                    {
                        if water_ID.object_index = obj_mud_cube
                        or water_ID.object_index = obj_mud_water
                            {
                                sink_yes = 1;
                                if ground = 0 and Animations_Override = 0 and attack[0]=0
                                and hurt[0] = 0 and gravity_ladder = 0 and lilac_boost_cancel = 0
                                and anim_current != anim_falling
                                    anim_current = anim_falling;
                            }
                    }
                if ground = 0 and Animations_Override = 0
                and hurt[0] = 0 and gravity_ladder = 0
                and sink_yes = 0
                and spade_special_button_cooldown_timer = 0
                    {
                        var anim_swim_speed = abs(hsp/24);
                        if hsp &gt; -dec and hsp &lt; dec
                            anim_swim_speed = 0.125;
                        if anim_current != anim_swimming anim_current = anim_swimming;
                        if frame &lt; anim_spade[anim_swimming,0] or frame &gt; anim_spade[anim_swimming,1]+0.8
                            frame = anim_spade[anim_swimming,0];
                        frame += 0.08+anim_swim_speed
                        if frame &gt; anim_spade[anim_swimming,1]+0.8
                            frame = anim_spade[anim_swimming,0];
                    }
            }
        if above_water = 1 and anim_current = anim_swimming
            {
                if ground = 1 anim_current = anim_standing;
                else          anim_current = anim_jump;
            }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Load Audio Groups
if room = rm_disclaimer
    {
        if !audio_group_is_loaded(Menu_Sounds) audio_group_load(Menu_Sounds)
        if !audio_group_is_loaded(Milla_Sounds) audio_group_load(Milla_Sounds)
        if !audio_group_is_loaded(Enemies) audio_group_load(Enemies)
        if !audio_group_is_loaded(General_Character_Sounds) audio_group_load(General_Character_Sounds)
        if !audio_group_is_loaded(Character_Sounds) audio_group_load(Character_Sounds)
        if !audio_group_is_loaded(Item_Sounds) audio_group_load(Item_Sounds)
        if !audio_group_is_loaded(Music) audio_group_load(Music);
        if !audio_group_is_loaded(Music_Extended) audio_group_load(Music_Extended);
        if !audio_group_is_loaded(Sounds_Extended) audio_group_load(Sounds_Extended);
        if !audio_group_is_loaded(Sounds_Extended_2) audio_group_load(Sounds_Extended_2);
        if !audio_group_is_loaded(Ambiance) audio_group_load(Ambiance);
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Music Playback and Master Playlist

switch(room)
    {
        //Title Screen
        case rm_title_screen:
            {
                scr_stop_music()
                music_index = ost_title_screen_stringtunes
                boss_index = 0
                break;
            }
        //Play Mode
        case rm_main_menu:
            {
                scr_stop_music()
                music_index = ost_shang_mu_white_alestance
                boss_index = 0
                break;
            }
        //Editor Mode
        case rm_editor:
            {
                if use_maps_load = 0
                    {
                        scr_stop_music()
                        //Play Current Song
                        music_index = ost_titlescreen_aqua_surface_woofle
                        boss_index = 0
                        obj_level_editor.music_index = ost_titlescreen_aqua_surface_woofle
                    }
                break;
            }
        //Play No Music If None Is Assigned For This Room
        default: {music_index = 0; boss_index = 0; break;}
    }

//Play Music
if music_index != 0 music_play_timer = 32;

//Disable All Sounds If They Were Still Playing
scr_stop_sounds();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Player Mode White List
user_cursor_mode = 1

switch(room)
    {
        case rm_test:     {user_cursor_mode = 1; break;}
        case rm_player:   {user_cursor_mode = 0; break;}
        case rm_campaign: {user_cursor_mode = 0; break;}
        case rm_template: {user_cursor_mode = 0; break;}
        case rm_west_district_0: {user_cursor_mode = 0; break;}
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Determine Play Mode For This Room

//Clear Attack And Damage States
scr_attack_variables()
hurt[0]         = 0         //Are We Hurt?
hurt[1]         = 0         //Invulnerability Timer
hurt[2]         = 0         //Background ID For Spikes
hurt[3]         = 0         //How Much Damage Should We Apply To The Player?
anim_current=anim_standing  //Reset Player Animation State
if performance_profile = 0
    {
        current_pal_allowed = 0
    }
if performance_profile = 1 and current_pal &gt; 0
    {
        current_pal_allowed = 1
    }
water_type = 0
water_index = spr_water
water_alpha = 0.25
waterline_index = spr_waterline
hide_hud = 0
///Make sure Milla's health bar is not overfilled
if skin = spr_milla and petals &gt; 10 {petals = 10; petalsmax = 10;}
scr_reset_gem_particles()
scr_reset_warp_points()
scr_stop_all_ambiance_fx()
view_top_lock = 0
boss_gate_open = 0
try_again_menu_selection = 0
try_again_menu_press = 0
shop_menu_movement_override = 0
death_not_really = 0
pause_sub_menu = 0
pause_sub_menu_timer = 0
pause_sub_menu_button = 0
potion_petal_timer = 0
potion_feather_timer = 0
potion_mystery_timer = 0
potion_mystery_effect = 0
jump_override = 0
Animations_Override = 0
active_attack = 0
gravity_override = 0
gravity_ladder = 0
gravity_rail_check = 0
gravity_rail_timer = 0
ladder_moving = 0
use_zoom_x_view = 426
use_zoom_y_view = 240
use_zoom_multiplier = 1
use_zoom_scale_factor = 1
tail_frame = 0
key_has = 0
view_shake_iterations =  0
view_shake            = -1
view_shake_mod        =  3
breath_offset = -14
now_loading = 0
stamina_target = 0
stamina_boosted = 0
transition_loading = 0
transition_game_over = 0
transition_game_over_x = -256
fof_disable = 0
invuln_hud_time = 0
invuln_hud_acti = 0
invuln_hud_modi = 0
title_room_timer = 0
transition_return = 0
HUD_offset = -56
hud_petals = spr_hud_petal
hud_new_record = 0
accident_forgiveness = 1
anim_sound_timer = 0
slope_layer = 0
death[0] = 0
stamina = 100
cards = 0
use_up = 0
use_down = 0
use_left = 0
use_right = 0
use_a = 0
use_b = 0
use_c = 0
use_d = 0
use_start = 0
sit = 0
sit_timer = 0
water_ID = 0
swimming = 0
alt_swimming = 0
above_water = 0
use_weather_conditions = 0
use_weather_x_0 = 0
use_weather_y_0 = 0
use_weather_direction = 0
use_weather_fade_effect = 0
use_weather_fade_target = 0
use_weather_timer = 5
use_thunder_timer = 0
cube_rain_timer = 0
use_flood_timer = 0
use_flood_fill_speed = 1
use_thunder_fade_effect = 0
use_thunder_fade_target = 0
use_win_conditions = 0
use_win_conditions_string = "Break the Targets!"
petal_heal_timer = 0
hud_bar_asset = spr_hud_bar
hud_bar_asset_alt = spr_hud_bar_alt
speed_boosted_timer = 0
boss_boundary_top       = -10000
boss_boundary_left      = -10000
boss_boundary_right     = -10000
boss_boundary_bottom    = -10000
lock_boundary_top       = -10000
lock_boundary_left      = -10000
lock_boundary_right     = -10000
lock_boundary_bottom    = -10000
scr_reset_gem_particles()
if alt_skin = 1 and (skin != spr_lilac and skin != spr_carol and skin != spr_milla)
    alt_skin = 0;
if alt_skin = 0
    {
        if skin = spr_lilac
            lives_spr = 0;
        if skin = spr_carol
            lives_spr = 4;
    }

if skin = spr_lilac
    {
        if alt_skin &lt; 2
            lives_spr = 0;
        if alt_skin = 2
            {
                lives_spr = 11;
                my_pal_sprite = spr_lilac_new_palette
                ui_pal_sprite = spr_lilac_new_palette
            }
    }

if skin = spr_carol
    {
        if alt_skin = 0
            {
                if bike = 0 {Animations_Carol(); scr_set_carol_state_without_bike();}
                if bike = 1 {Animations_Carol_Bike(); scr_set_carol_state_riding_bike();}
            }
        if alt_skin = 1
            scr_spawn_carrie();
        if alt_skin = 2
            {
                if scooter = 0
                    scr_spawn_chiasa();
                else
                    {
                        alt_skin = 2;
                        scr_spawn_chiasa();
                        scr_set_carols_bike();
                        lives_spr = 10
                        scooter = 0
                        my_pal_sprite = spr_chiasa_palette
                        ui_pal_sprite = spr_chiasa_palette
                        snd_player_hurt_0 = snd_carrie_hurt_1    //Hurt Sound 1
                        snd_player_hurt_1 = snd_carrie_hurt_2    //Hurt Sound 2
                        snd_player_death  = snd_carrie_death     //Death Sound
                        push_sound = snd_carrie_attack_leap
                        swimming_frame = obj_game_logic.anim_carol[obj_game_logic.anim_swimming,0]
                    }
            }
            
    }
bike_x = -64
bike_y = -64

//Reset Collision Sensors
scr_set_reset_collision_sensors();

if gamepad_is_connected(joy_modern_id)
    {
        gamepad_set_axis_deadzone(joy_modern_id,deadzone_mod);
        joy_input_descrip = gamepad_get_description(joy_modern_id);
        if joy_input_descrip = "Sony DualShock 4"
            {
                user_joystick_left = scr_set_display_button_ps4(joy_left_mod)
                user_joystick_right = scr_set_display_button_ps4(joy_right_mod)
                user_joystick_up = scr_set_display_button_ps4(joy_up_mod)
                user_joystick_down = scr_set_display_button_ps4(joy_down_mod)
                user_joystick_a = scr_set_display_button_ps4(joy_a_mod)
                user_joystick_b = scr_set_display_button_ps4(joy_b_mod)
                user_joystick_c = scr_set_display_button_ps4(joy_c_mod)
                user_joystick_d = scr_set_display_button_ps4(joy_d_mod)
                user_joystick_start = scr_set_display_button_ps4(joy_start_mod)
            }
        else
            {
                user_joystick_left = scr_set_display_button(joy_left_mod)
                user_joystick_right = scr_set_display_button(joy_right_mod)
                user_joystick_up = scr_set_display_button(joy_up_mod)
                user_joystick_down = scr_set_display_button(joy_down_mod)
                user_joystick_a = scr_set_display_button(joy_a_mod)
                user_joystick_b = scr_set_display_button(joy_b_mod)
                user_joystick_c = scr_set_display_button(joy_c_mod)
                user_joystick_d = scr_set_display_button(joy_d_mod)
                user_joystick_start = scr_set_display_button(joy_start_mod)
            }
    }

//Reset Particle Variables
lilac_particle_frame[0]   = -128
lilac_particle_frame[1]   = -128
lilac_particle_frame[2]   = -128
lilac_particle_frame[3]   = -128
lilac_particle_frame[4]   = -128
lilac_particle_frame[5]   = -128
lilac_particle_frame[6]   = -128
lilac_particle_frame[7]   = -128
lilac_particle_frame[8]   = -128
lilac_particle_frame[9]   = -128
lilac_particle_frame[10]  = -128
lilac_particle_frame[11]  = -128
lilac_particle_frame[12]  = -128
lilac_particle_frame[13]  = -128
lilac_particle_frame[14]  = -128
lilac_particle_frame[15]  = -128
lilac_particle_frame[16]  = -128
lilac_particle_frame[17]  = -128
lilac_particle_frame[18]  = -128
lilac_particle_frame[19]  = -128
lilac_particle_frame[20]  = -128
lilac_particle_frame[21]  = -128
lilac_particle_frame[22]  = -128
lilac_particle_frame[23]  = -128
lilac_particle_frame[24]  = -128
lilac_particle_frame[25]  = -128
lilac_particle_frame[26]  = -128
lilac_particle_frame[27]  = -128
lilac_particle_frame[28]  = -128
lilac_particle_frame[29]  = -128
lilac_particle_frame[30]  = -128

//Carol's Bike Particles
carol_particle_frame[0]   = -128
carol_particle_frame[1]   = -128
carol_particle_frame[2]   = -128
carol_particle_frame[3]   = -128
carol_particle_frame[4]   = -128
carol_particle_frame[5]   = -128
carol_particle_frame[6]   = -128
carol_particle_frame[7]   = -128
carol_particle_frame[8]   = -128
carol_particle_frame[9]   = -128
carol_particle_frame[10]  = -128

//Milla Phantom Cube Particles
milla_particle_frame_1  = -128    //Animation Frame for Particle 1
milla_particle_frame_2  = -128    //Animation Frame for Particle 2
milla_particle_frame_3  = -128    //Animation Frame for Particle 3
milla_particle_frame_4  = -128    //Animation Frame for Particle 4
milla_particle_frame_5  = -128    //Animation Frame for Particle 5
milla_particle_frame_6  = -128    //Animation Frame for Particle 5

//Animation Frame Positions
skid_animation_frame[0] = -128
skid_animation_frame[1] = -128
skid_animation_frame[2] = -128
skid_animation_frame[3] = -128
skid_animation_frame[4] = -128
skid_animation_frame[5] = -128
skid_animation_frame[6] = -128
skid_animation_frame[7] = -128
skid_animation_frame[8] = -128
skid_animation_frame[9] = -128

particle_frame_1  = -128    //Animation Frame for Particle 1
particle_frame_2  = -128    //Animation Frame for Particle 2
particle_frame_3  = -128    //Animation Frame for Particle 3
particle_frame_4  = -128    //Animation Frame for Particle 4
particle_frame_5  = -128    //Animation Frame for Particle 5

//If we have entered the title screen, then files in the maps folder
//have likely recently been modified, so let's rebuild the maps' folder's
//file list
if room = rm_title_screen
    user_changed_files = 1;

//Reset Campaign-Specific Parameters
if room = rm_sm_character_select
    {
        hud_gem_value = 0;
        use_maps_current_map = 0
        campaign_stage_select = 0

        stage_transition_timer = 0
        stage_transition_title_y = internal_res_height+32
        stage_transition_alpha = 1
        stage_transition_title_x = internal_res_width/2
        stage_transition_title_x_offset = 0
        ostage_transition_subtitle_x_offset = 0
        stage_transition_subtitle_y = internal_res_height+78
    }

//Enable the use of the main menu, or the title screen
if room = rm_main_menu
or room = rm_title_screen
or room = rm_cutscene
    {
        debug_hud = 1
        debug_hud_mode = 0
        debug_hud_sensors = 0
        use_menu = 1
        classic_mode = 0
        transition_alpha = 1
        user_cursor_mode = 1
        scooter = 0
        //Reset the timer on the HUD
        hud_timer_mil = 0
        hud_timer_sec = 0
        hud_timer_min = 0
        hud_gem_value = 0
        //Reset the checkpoint
        checkpoint_timer_mil = 0
        checkpoint_timer_sec = 0
        checkpoint_timer_min = 0
        timer_stop = 1
        draw_timer = 1
        //Reset checkpoint starting positions
        start_x = 0
        start_y = 0
        checkpoint_x = 0
        checkpoint_y = 0
        px = 0
        py = -64
        if room != rm_cutscene
            {
                //Reset campaign mode variables
                campaign_stage_select = 0
                campaign_stage_section_limit = 1
                story_mode = 0
                dont_change_music = 0
                campaign_stage_section[0] = ""
                campaign_stage_section[1] = ""
                campaign_stage_section[2] = ""
                campaign_stage_section[3] = ""
                potion_petal_potion = 0
                potion_petal_core = 0
                potion_petal_timer = 0
                potion_stamina_drink = 0
                potion_stamina_core = 0
                potion_feather_potion = 0
                potion_feather_timer = 0
                potion_mystery_potion = 0
            }
        //Reset gem counter
        gems = 250
        lives = 5
        invuln_hud_time = 0
        //Remove shield
        shield_active = 0
        shield_timer = -8
        //Lower water height
        water_height = 2400
        water_line = 2400
        //Reset turbo mode check
        user_turbo_mode_used = 0
        if user_turbo_mode = 1 user_turbo_mode_used = 1;
        use_maps_load = 0
        use_maps_select = ""
        use_maps_current_map = 0
        campaign_stage_select = 0
        shield_timer = -8
        shield_active = 0
        now_loading = 0
        //Multi-Map Variables
        scr_multi_map_reset();
    }

//Show the disclaimer screen
if room = rm_disclaimer
    {
        use_menu = 1
        use_editor = 2
        debug_hud = 1
        pause = 0
        pause_lock = 0
        Jpause[1]=0
        user_cursor_mode = 1
        camera_boundary_top = 0
        camera_boundary_left = 0
        camera_boundary_right = room_width
        camera_boundary_bottom = room_height
        px = 0
        py = -64
        //Lower water height
        water_height = 2400
        water_line = 2400
        //Reset turbo mode check
        user_turbo_mode_used = 0
        if user_turbo_mode = 1 user_turbo_mode_used = 1;
    }

//Enable the use of the editor
if room = rm_editor
    {
        player_current = 4;
        player_gems[4] = 0;
        player_shards[4] = 0
        use_editor = 1
        use_menu = 0
        user_cursor_mode = 1
        debug_hud = 1
        transition_alpha = 1
        view_xview[view_port] = 0
        view_yview[view_port] = 0
        //Center cursor on our current camera position
        use_cursor_x = view_xview[view_port]+internal_resolution[0]/2
        use_cursor_y = view_yview[view_port]+internal_resolution[1]/2
        debug_characters_x = 164            //What is our drawing X position for the characters HUD display?
        debug_characters_y = 8              //What is our drawing Y position for the characters HUD display?
        debug_highlight_x1 = 165
        debug_highlight_x2 = 185
        debug_highlight_x3 = 205
        debug_highlight_x4 = 225
        debug_highlight_x5 = 245
        debug_highlight_y1 = 24
        camera_boundary_top = 0
        camera_boundary_left = 0
        camera_boundary_right = room_width
        camera_boundary_bottom = room_height
        if use_maps_load != 1 and not instance_exists(obj_bg_logic_alt) instance_create(0,0,obj_bg_logic_alt);
        //Lower water height
        water_height = 2400
        water_line = 2400
        //Reset turbo mode check
        user_turbo_mode_used = 0
        if user_turbo_mode = 1 user_turbo_mode_used = 1;
        //Disable mouse player mode
        joy_mouse_button_switch = 0
        joy_mouse_button_timer = 0
        joy_mouse_button_flash = 0
        joy_mouse_button_alpha = 0
        joy_mouse_button_counter = 0
        potion_petal_potion = 0
        potion_petal_core = 0
        potion_petal_timer = 0
        potion_stamina_drink = 0
        potion_stamina_core = 0
        potion_feather_potion = 0
        potion_mystery_potion = 0
    }
//Reset drawing positions for the debug HUD's character display otherwise
else
    {
        debug_characters_x = 327
        debug_characters_y = 55
        debug_highlight_x1 = 328
        debug_highlight_x2 = 348
        debug_highlight_x3 = 368
        debug_highlight_x4 = 388
        debug_highlight_x5 = 408
        debug_highlight_y1 = 71
        user_built_list = 0
    }
if (room != rm_campaign)
    {
        shield = spr_shield_wood    //Current Shield
        shield_health   = 2         //Current Shield Health
        shield_active   = 0         //Is Our Shield Active?
        shield_invuln   = 32        //How Long Before the Shield Accept Damage Again?
        shield_frame    = 0         //Current Shield Frame of Animation
        shield_speed    = 0         //Animation Speed of the Shield
        shield_timer    = -8        //How Long Before the Shield Is Active?
        shield_flash    = 0         //How Long Should the Shield Flash Last?
        shield_hold     = 0         //Next Shield in the Queue
        shield_rotate   = 0         //What Is Our Rotation? (Water Shield Only)
        shield_framemax = 0         //Maximum Number of Animated Shield Frames
        shield_rotate_x = 0         //X Position of the Shield
        shield_rotate_y = 0         //Y Position of the Shield
        shield_angle    = 0         //Angle of The Shield While Orbiting the Player
    }

//Disable debug mode and editor mode while in player mode
if room = rm_player
or room = rm_campaign
    {
        if room = rm_player
        and checkpoint_x = 0
        and checkpoint_y = 0
            {
                player_current = 4
                player_gems[4] = 0
                player_shards[4] = 0
            }
        targets_ready = 1
        targets = 0
        use_editor = 0
        use_menu = 0
        user_cursor_mode = 0
        timer_stop = 1
        if room = rm_campaign
            transition_timer = 0;
        //debug_hud = 1
        xdir = 1
        use_editor = 0
        use_menu   = 0
        pause = 0
        pause_lock = 0
        Jpause[1]=0
        debug_hud = 1
        debug_hud_sensors = 0
        camera_boundary_top = 0
        camera_boundary_left = 0
        camera_boundary_right = room_width
        camera_boundary_bottom = room_height
        //Boss stage variables
        stage_transition_alpha = 1
        stage_transition_timer = 0
        stage_transition_title_x = internal_res_width/2
        stage_transition_title_x_offset = 0
        stage_transition_title_y = internal_res_height+32
        stage_transition_subtitle_x = internal_res_width/2
        stage_transition_subtitle_x_offset = 0
        stage_transition_subtitle_y = internal_res_height+72
    }

//Lock all inputs for the first few frames of play
joy_input[2,6] = 8
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Load a New Stage If The Open Dialogue Was Triggered

//Disable Map Loading If We Entered The Level Select Menu, No Matter What Parameters Were Provided Previously
if (room = rm_title_screen or room = rm_main_menu)
    {
        use_maps_load = 0
        use_maps_select = ""
        use_cuts_select = ""
        use_maps_current_map = 0
        use_maps_multi_map_mode = 0
        use_maps_overwrite_protection = 0
        use_maps_transition = 0
        story_mode = 0
    }
//Only Load Stages If We Are In The Appropriate Rooms
if ((use_maps_load = 1) and (room = rm_editor or room = rm_player))
or (room = rm_cutscene or room = rm_campaign)
    {
        //Force clear story mode triggers if they weren't already
        if (room = rm_editor or room = rm_player)
            story_mode = 0;
        //Restore Previous Camera Positions
        view_xview[view_port] = use_maps_x
        view_yview[view_port] = use_maps_y
        //Set Camera Boundaries to Default If Camera Boundary Modifiers Were Not Applied
        camera_boundary_top = 0
        camera_boundary_left = 0
        camera_boundary_right = room_width
        camera_boundary_bottom = room_height
        //Which Section Are We Reading From Within The Map File?
        var map_offset = "";
        if use_maps_current_map &gt; 0
            {
                map_offset = string(use_maps_current_map)
            }
        //Open Level Map
        nsfs_init()
        if (room = rm_editor or room = rm_player)
            ini_open_ns(program_directory + "Maps\" + use_maps_select);
        if (room = rm_cutscene or room = rm_campaign)
            ini_open_ns(program_directory + "Campaign\" + use_cuts_select);
        //Enable Overwrite Protection For Multi-Map Stages
        if ini_section_exists("1lvl_hd")
            {
                //Enable Overwrite Protection While In Editor Mode
                if room = rm_editor
                    {
                        use_maps_overwrite_protection = 1;
                        if use_maps_current_map &gt; 0
                            {
                                var obj_editor = obj_level_editor;
                                obj_editor.use_write_keyboard_string_stage_name = ini_read_string(map_offset+"lvl_hd","lvl_name","")
                                obj_editor.use_write_keyboard_string_architect = ini_read_string(map_offset+"lvl_hd","lvl_author","")
                                obj_editor.use_write_keyboard_string_description = ini_read_string(map_offset+"lvl_hd","lvl_description","")
                                obj_editor.use_write_reserve_string_stage_name = obj_editor.use_write_keyboard_string_stage_name
                                obj_editor.use_write_reserve_string_architect = obj_editor.use_write_keyboard_string_architect
                                obj_editor.use_write_reserve_string_description = obj_editor.use_write_keyboard_string_description
                            }
                    }
                //Or Turn On Support For Multi-Map Mode In Player Mode
                else
                    use_maps_multi_map_mode = 1;
            }
        //If there are no additional maps, then treat the right-side of the map as a wall
        if !ini_section_exists(string(use_maps_current_map+1)+"lvl_hd")
            use_maps_boundary = 1;
        //Otherwise, allow map transitions
        else
            use_maps_boundary = 0;
        //Read Maximum Number Of Objects/Tiles Already Created In The Map File
        var use_max_tile_position = real(ini_read_string(map_offset+"lvl_hd","lvl_tile_count","16000"));
        //We can safely assume that launch week maps don't have more than 10,000 objects placed inside them, so let's start
        //placing *new* objects at this range
        var use_max_obj_position  = real(ini_read_string(map_offset+"lvl_hd","lvl_obj_count","10000"));
        //Update Map File If It's Out Of Date
        var ver_num = real(ini_read_string("lvl_hd","version_number","1000"));
        //Transfer all FOF tiles previously saved to the FOF layer, to the Slope surface layer instead
        if ver_num &gt; 1080 and ver_num &lt; 1094
            {
                var use_read_position = 0;
                //Look For Old FOF Tiles
                while(use_read_position &lt; use_max_tile_position)
                    {
                        if ini_section_exists("lvl_tiles_"+string(use_read_position))
                            {
                                var conversion_reference = real(ini_read_string("lvl_tiles_"+string(use_read_position),"tile_asset",0));
                                var depth_ID = ini_read_string("lvl_tiles_"+string(use_read_position),"tile_depth","0");
                                if depth_ID = "2"
                                    {
                                        //Look for FOF tiles
                                        var yes = 0;
                                        switch(conversion_reference)
                                            {
                                                case 52:  {yes = 1; break;}
                                                case 53:  {yes = 1; break;}
                                                case 54:  {yes = 1; break;}
                                                case 55:  {yes = 1; break;}
                                                case 196:  {yes = 1; break;}
                                                case 197:  {yes = 1; break;}
                                                case 526:  {yes = 1; break;}
                                                case 609:  {yes = 1; break;}
                                                case 610:  {yes = 1; break;}
                                                case 611:  {yes = 1; break;}
                                                case 612:  {yes = 1; break;}
                                                case 613:  {yes = 1; break;}
                                                case 621:  {yes = 1; break;}
                                                case 622:  {yes = 1; break;}
                                                case 623:  {yes = 1; break;}
                                                case 624:  {yes = 1; break;}
                                                case 657:  {yes = 1; break;}
                                                case 684:  {yes = 1; break;}
                                                case 685:  {yes = 1; break;}
                                                case 700:  {yes = 1; break;}
                                                case 701:  {yes = 1; break;}
                                            }
                                        //Change depth of these tiles if they exist
                                        if yes = 1 ini_write_string("lvl_tiles_"+string(use_read_position),"tile_depth",string(1));
                                    }
                            }
                        //Iterate Reading Position
                        use_read_position += 1
                    }
                //Update version header
                ini_write_string("lvl_hd","version_number",string(version_number))
                ini_close_ns()
            }
        //Do not attempt to launch map if it's a version number above our build number
        if ver_num &gt; version_number
            {
                scr_set_message("Incompatible map! Please update the game!")
                if room = rm_player
                    {
                        room_goto(rm_main_menu);
                        ini_close_ns()
                    }
            }
        else
            {
                //Which Section Are We Reading From Within The Map File?
                var map_offset = "";
                if use_maps_current_map &gt; 0
                    map_offset = string(use_maps_current_map)
                if (room = rm_editor or room = rm_player)
                    ini_open_ns(program_directory + "Maps\" + use_maps_select);
                if (room = rm_cutscene or room = rm_campaign)
                    ini_open_ns(program_directory + "Campaign\" + use_cuts_select);
                var use_read_position = 0;
                use_max_obj_position  = real(ini_read_string(map_offset+"lvl_hd","lvl_obj_count","16000"));
                //Read Level Data Until We Run Out of Sections
                while(use_read_position &lt; use_max_tile_position)
                    {
                        if ini_section_exists(map_offset+"lvl_tiles_"+string(use_read_position))
                            {
                                //Reference Current Tile's Asset
                                var conversion_reference = use_conversion_table[real(ini_read_string(map_offset+"lvl_tiles_"+string(use_read_position),"tile_asset","0"))];
                                //Place Tile Based On Provided Parameters
                                if real(ini_read_string(map_offset+"lvl_tiles_"+string(use_read_position),"tile_ignore","0")) = 0
                                    {
                                        tile_modify_properties_id = tile_add(conversion_reference,0,0,background_get_width(conversion_reference),background_get_height(conversion_reference),
                                        real(ini_read_string(map_offset+"lvl_tiles_"+string(use_read_position),"tile_x","0")),
                                        real(ini_read_string(map_offset+"lvl_tiles_"+string(use_read_position),"tile_y","0")),
                                        real(ini_read_string(map_offset+"lvl_tiles_"+string(use_read_position),"tile_depth","0")));
                                        //Modify The Tile's X/Y Scaling
                                        tile_set_scale(tile_modify_properties_id,real(ini_read_string(map_offset+"lvl_tiles_"+string(use_read_position),"tile_xscale","1")),
                                        real(ini_read_string(map_offset+"lvl_tiles_"+string(use_read_position),"tile_yscale","1")))
                                        //Modify The Tile's Alpha
                                        tile_set_alpha(tile_modify_properties_id,real(ini_read_string(map_offset+"lvl_tiles_"+string(use_read_position),"tile_alpha","1")))
                                    }
                            }
                        //Iterate Reading Position
                        use_read_position += 1
                    }
                //Reset Read Position
                use_read_position = 0
                //Read Level Data Until We Run Out of Sections
                while(use_read_position &lt; use_max_obj_position)
                    {
                        if ini_section_exists(map_offset+"lvl_objects_"+string(use_read_position))
                            {
                                //Reference Current Object's Asset
                                var conversion_reference = use_conversion_table[real(ini_read_string(map_offset+"lvl_objects_"+string(use_read_position),"obj_asset","0"))];
                                //Place Object Based On Provided Parameters
                                if real(ini_read_string(map_offset+"lvl_objects_"+string(use_read_position),"obj_ignore","0")) = 0
                                instance_create(real(ini_read_string(map_offset+"lvl_objects_"+string(use_read_position),"obj_x","0")),real(ini_read_string(map_offset+"lvl_objects_"+string(use_read_position),"obj_y","0")),conversion_reference);
                                //Create Item/Mod Chip, If We Have One
                                if real(ini_read_string(map_offset+"lvl_objects_"+string(use_read_position),"obj_item",0)) &gt; 0
                                instance_create(real(ini_read_string(map_offset+"lvl_objects_"+string(use_read_position),"obj_x","0")),real(ini_read_string(map_offset+"lvl_objects_"+string(use_read_position),"obj_y","0")),use_conversion_table_item[real(ini_read_string(map_offset+"lvl_objects_"+string(use_read_position),"obj_item","0"))]);
                            }
                        //Iterate Reading Position
                        use_read_position += 1
                    }
                //Stop Previous Song
                if dont_change_music = 0
                    {
                        scr_stop_music()
                        var backup_music = ost_city_center_groove_woofle;
                        if (room != rm_cutscene)
                            {
                                if instance_exists(obj_bg_city)                 {music_index = audio_play_sound(ost_city_center_groove_woofle,50,true); backup_index = ost_city_center_groove_woofle}
                                if instance_exists(obj_bg_logic_night)          {music_index = audio_play_sound(ost_shang_mu_green_blitz_lunar,50,true); backup_index = ost_shang_mu_green_blitz_lunar}
                                if instance_exists(obj_bg_logic)                {music_index = audio_play_sound(ost_shang_mu_white_alestance,50,true); backup_index = ost_shang_mu_white_alestance}
                                if instance_exists(obj_bg_logic_nighttime)      {music_index = audio_play_sound(ost_shang_mu_academy_night_string_alestance,50,true); backup_index = ost_shang_mu_academy_night_string_alestance}
                                if instance_exists(obj_bg_logic_alt)            {music_index = audio_play_sound(ost_titlescreen_aqua_surface_woofle,50,true); backup_index = ost_titlescreen_aqua_surface_woofle}
                                if instance_exists(obj_bg_logic_lagoon)         {music_index = audio_play_sound(ost_aqua_tunnel_dusky_remix,50,true); backup_index = ost_aqua_tunnel_dusky_remix}
                                if instance_exists(obj_bg_logic_lagoon_sunrise) {music_index = audio_play_sound(ost_aqua_tunnel_dusky_remix,50,true); backup_index = ost_aqua_tunnel_dusky_remix}
                                if instance_exists(obj_bg_city_day)             {music_index = audio_play_sound(ost_city_west_day_bobtheguy,50,true); backup_index = ost_city_west_day_bobtheguy}
                                if instance_exists(obj_bg_space)                {music_index = audio_play_sound(ost_space_dusky,50,true); backup_index = ost_space_dusky}
                                if instance_exists(obj_bg_space_night)          {music_index = audio_play_sound(ost_space_dusky,50,true); backup_index = ost_space_dusky}
                                if instance_exists(obj_bg_logic_mnt)            {music_index = audio_play_sound(ost_taishan_mountains_alestance,50,true); backup_index = ost_whispers_of_dragon_valley_string}
                                if instance_exists(obj_bg_city_sewers)          {music_index = audio_play_sound(ost_shade_armory_remix_bobtheguy,50,true); backup_index = ost_shade_armory_remix_bobtheguy}
                                if instance_exists(obj_bg_logic_mnt_nite)       {music_index = audio_play_sound(ost_taishan_mountain_dusky_alestance,50,true); backup_index = ost_taishan_mountain_dusky_alestance}
                                if instance_exists(obj_bg_logic_mnt_nighttime)  {music_index = audio_play_sound(ost_taishan_mountain_synx,50,true); backup_index = ost_taishan_mountain_synx}
                                if instance_exists(obj_bg_beihai_bay)           {music_index = audio_play_sound(ost_beihai_bay_benjistring,50,true); backup_index = ost_beihai_bay_benjistring}
                                if instance_exists(obj_bg_beihai_bay_sunset)    {music_index = audio_play_sound(ost_horizon_starport_arrangement_benjistring,50,true); backup_index = ost_horizon_starport_arrangement_benjistring}
                                if instance_exists(obj_bg_mnt_cave)             {music_index = audio_play_sound(ost_cave_jj_ghost,50,true); backup_index = ost_cave_jj_ghost}
                                if instance_exists(obj_bg_city_sewers_day)      {music_index = audio_play_sound(ost_aqua_tunnel_dusky_remix,50,true); backup_index = ost_aqua_tunnel_dusky_remix}
                                if instance_exists(obj_bg_jungle)               {music_index = audio_play_sound(ost_lotus_cascades_nick_nuwe,50,true); backup_index = ost_lotus_cascades_nick_nuwe}
                                if instance_exists(obj_bg_jungle_night)         {music_index = audio_play_sound(ost_lotus_cascades_nick_nuwe,50,true); backup_index = ost_lotus_cascades_nick_nuwe}
                                if instance_exists(obj_bg_rapids)               {music_index = audio_play_sound(ost_raging_rapids_dusky,50,true); backup_index = ost_raging_rapids_dusky}
                                if instance_exists(obj_bg_city_sewers_slime)    {music_index = audio_play_sound(ost_shade_armory_remix_bobtheguy,50,true); backup_index = ost_shade_armory_remix_bobtheguy}
                                if instance_exists(obj_bg_sushi_bar)            {music_index = audio_play_sound(ost_fortune_elevator,50,true); backup_index = ost_fortune_elevator}
                                if instance_exists(obj_bg_mall_day)             {music_index = audio_play_sound(ost_fortune_elevator,50,true); backup_index = ost_fortune_elevator}
                                if instance_exists(obj_bg_mall_night)           {music_index = audio_play_sound(ost_fortune_elevator,50,true); backup_index = ost_fortune_elevator}
                                if instance_exists(obj_bg_mnt_cave_dark)        {music_index = audio_play_sound(ost_pangu_theme_benjistring,50,true); backup_index = ost_pangu_theme_benjistring}
                                if instance_exists(obj_bg_wuzhen)               {music_index = audio_play_sound(ost_shang_mu_green_blitz_lunar,50,true); backup_index = ost_shang_mu_green_blitz_lunar}
                                if instance_exists(obj_bg_wuzhen_night)         {music_index = audio_play_sound(ost_shang_mu_green_blitz_lunar,50,true); backup_index = ost_shang_mu_green_blitz_lunar}
                                if instance_exists(obj_bg_wuzhen_sunset)        {music_index = audio_play_sound(ost_shang_mu_green_blitz_lunar,50,true); backup_index = ost_shang_mu_green_blitz_lunar}
                                if instance_exists(obj_bg_jiang_cruise)         {music_index = audio_play_sound(ost_tidalgate_bobtheguy,50,true); backup_index = ost_tidalgate_bobtheguy}
                                if instance_exists(obj_bg_jiang_cruise_storm)   {music_index = audio_play_sound(ost_tidalgate_bobtheguy,50,true); backup_index = ost_tidalgate_bobtheguy}
                                //Override all other songs if the train station has been spawned
                                if instance_exists(obj_bg_train_station) {scr_stop_music(); music_index = audio_play_sound(ost_shang_mu_railway_bob,50,true); backup_index = ost_shang_mu_railway_bob}
                            }
                        use_song = music_index
                        backup_index = music_index
                    }
                if dont_change_music = 1
                    dont_change_music = 0;
                //Check The Stage's Weather
                use_weather_conditions = real(ini_read_string("lvl_hd","lvl_weather",0));
                use_win_conditions = real(ini_read_string("lvl_hd","lvl_win_condition",0));
                //Set win conditions
                switch(use_win_conditions)
                    {
                        case 0:  {use_win_conditions_string = "Break the Targets!"; targets_mode = spr_hud_target; break;}
                        case 1:  {use_win_conditions_string = "Reach the Target!";  targets_mode = spr_hud_target_silver; break;}
                        case 2:  {use_win_conditions_string = "Defeat the Boss!";   targets_mode = spr_hud_target_boss; break;}
                        default: {use_win_conditions_string = "Break the Targets!"; targets_mode = spr_hud_target; break;}
                    }
                //If We Are In Editor Mode, Force Current Song To The One Assigned By The Map
                if room = rm_editor
                    {
                        obj_level_editor.music_index = music_index
                        obj_level_editor.backup_index = backup_music
                        obj_level_editor.use_current_song_iterations = use_song
                        obj_level_editor.use_write_reserve_string_stage_name = ini_read_string("lvl_hd","lvl_name","") 
                        obj_level_editor.use_write_reserve_string_architect = ini_read_string("lvl_hd","lvl_author","")
                        obj_level_editor.use_write_reserve_string_description = ini_read_string("lvl_hd","lvl_description","")
                        obj_level_editor.use_win_iterations = use_win_conditions
                        switch(use_win_conditions)
                            {
                                case 0:  {obj_level_editor.use_win_condition = "Break the Targets"; break;}
                                case 1:  {obj_level_editor.use_win_condition = "Reach the Target"; break;}
                                case 2:  {obj_level_editor.use_win_condition = "Defeat the Boss"; break;}
                                default: {obj_level_editor.use_win_condition = "Break the Targets"; break;}
                            }
                        obj_level_editor.use_weather_iterations = use_weather_conditions
                        switch(use_weather_conditions)
                            {
                                case 0:  {obj_level_editor.use_weather_conditions = "Clear"; break;}
                                case 1:  {obj_level_editor.use_weather_conditions = "Rainy"; break;}
                                case 2:  {obj_level_editor.use_weather_conditions = "Storm"; break;}
                                case 3:  {obj_level_editor.use_weather_conditions = "Tempest"; break;}
                                default: {obj_level_editor.use_weather_conditions = "Clear"; break;}
                            }
                    }
                //Adjust Current Song's Volume
                if music_mute = 0 scr_adjust_music_silent(music_volume/100,1000);
                else scr_adjust_music_silent(0,1000);
                //Adjust Player's Health
                petals = real(ini_read_string("lvl_health","health",14))
                if room = rm_editor obj_level_editor.use_health_petal_mod = petals;
                //Check Stage's Name
                use_stage_name = ini_read_string("lvl_hd","lvl_name","");
                //Check Stage's Description
                use_display_description = ini_read_string("lvl_hd","lvl_description","Defeat     the     Boss");
                if use_display_description = ""
                    use_display_description = "Defeat     the     Boss";
                //Close Level Map From Further Reading
                ini_close_ns()
        
                //Make sure Milla's health bar is not overfilled
                if skin = spr_milla and petals &gt; 10 {petals = 10; petalsmax = 10;}
        
                //Count number of targets
                targets += instance_number(obj_target)
                targets += instance_number(obj_checkpoint)
        
                //Set weather conditions
                if use_weather_conditions &gt; 0
                    audio_play_sound(snd_rain,50,true);
                if use_weather_conditions = 3
                    audio_play_sound(snd_tempest,50,true);

                //Set the game mode automatically, based on whether silver targets exist in this room
                if instance_exists(obj_checkpoint) and use_win_conditions = 0
                and (room != rm_cutscene)
                    {
                        targets_mode = spr_hud_target_silver;
                        use_win_conditions_string = "Reach the Target!";
                        scr_set_message("Checkpoint targets present; overriding objective")
                    }
                if !instance_exists(obj_checkpoint) and use_win_conditions = 1
                    {
                        targets_mode = spr_hud_target;
                        use_win_conditions_string = "Break the Targets";
                        scr_set_message("No checkpoint targets present; overriding objective")
                    }
                if use_win_conditions = 2 and room != rm_editor
                    {
                        targets_mode = spr_hud_target_boss
                        use_win_conditions_string = "Defeat     the     Boss!"
                        targets_ready = 4
                    }
                if room = rm_editor scr_set_message("Loading complete!")
                //Create NPC Spawner
                if (room != rm_cutscene) instance_create(x,y,obj_npc_spawner);
                //if (room != rm_editor) instance_create(x,y,obj_advanced_spawner)
                //If we are in a multi-map mode room, default to the room's left boundaries if the map is loaded without a spawner
                if use_maps_current_map &gt; 0 and room != rm_editor
                    px = 0;
            }
    }
use_maps_load = 2
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Debug HUD

if debug_hud != 1 and room != rm_editor
    {
        //           Debug HUD Interface           //
        //=========================================//
        
        //Set Font And Color
        draw_set_font(hud_font)
        draw_set_color(c_white)

        //Draw Highlights For Active Sensors
        if tile_exists(tile_surface_id[1]) draw_sprite(spr_debug_sensor_highlight,0,63,173); //Top Sensor
        if tile_exists(tile_surface_id[2]) draw_sprite(spr_debug_sensor_highlight,0,63,209); //Bottom Sensor
        if tile_exists(tile_surface_id[3]) draw_sprite(spr_debug_sensor_highlight,0,45,191); //Left Sensor
        if tile_exists(tile_surface_id[4]) draw_sprite(spr_debug_sensor_highlight,0,81,191); //Right
        //Slope Wall Collision Sensors
        if tile_wall_left_trig  = 1 draw_sprite(spr_debug_sensor_highlight_small,0,49,181);
        if tile_wall_right_trig = 1 draw_sprite(spr_debug_sensor_highlight_small,0,85,181);
        //Slope Ceiling Collision Sensors
        if tile_collision_ceiling_trigger = 1 draw_sprite(spr_debug_sensor_highlight_small,0,67,163);
        //Slope Floor Collision Sensors
        if gravity_slope = 1 or gravity_fof &gt; 0 draw_sprite(spr_debug_sensor_highlight_small,0,67,226);
        //Draw Current Character
        var debug_highlight_x_pos = 0;
        switch(skin)
            {
                case spr_lilac: {debug_highlight_x_pos = 318; break;}
                case spr_carol:
                    {
                        debug_highlight_x_pos = 338;
                        if alt_skin = 1 debug_highlight_x_pos = 398;
                        if alt_skin = 2 debug_highlight_x_pos = 418;
                        break;
                    }
                case spr_milla: {debug_highlight_x_pos = 358; break;}
                case spr_spade: {debug_highlight_x_pos = 378; break;}
            }
        draw_sprite(spr_debug_sensor_highlight,0,debug_highlight_x_pos,71);
        //Draw Character Hint
        if pause = 1 draw_sprite(spr_debug_hud_character_hint,0,326,90);

        //Draw Player Status Variables
        draw_text(30,52,string(px))             //Player's X Position
        draw_text(30,64,string(py))             //Player's Y Position
        draw_text(88,76,string(hsp))            //Player's Horizontal Speed
        draw_text(88,88,string(gravity_speed))  //Player's Gravity    Speed
        draw_text(68,100,string(tile_angle))    //Player's Angle
        draw_text(90,112,string(xcompass))      //Player's Compass Direction
        draw_text(70,124,string(frame))         //Player's Current Animation Frame
        draw_text(69,136,string(anim_current))  //Player's Current Animation
        //Draw Debug HUD Elements As One Image
        draw_sprite(spr_debug_hud_status,0,12,35)
        
        //Draw Performance Status Variables
        draw_text(189,223,string(fps))             //Number Of Frames Per Second
        draw_text(252,223,string(instance_count))  //Number Of Objects In The Room
        //Draw Debug HUD Elements As One Image
        draw_sprite(spr_debug_hud_performance,0,155,223)

        //Draw Debug HUD Elements As One Image
        draw_sprite(spr_debug_hud_characters,0,debug_characters_x,debug_characters_y)

        //Align Drawn Zoom Scaling Factor Notifications To The Right
        if  general_notifications[2] = 0
        and general_notifications[1] = 0
        and general_notifications[0] = 0
            {
                switch(use_zoom_iterate)
                    {
                        //Draw Zoom Scaling Factor At 0.5x Scales
                        case 0: {break;}
                        //50%
                        case 1:
                            {
                                draw_set_font(menu_font)
                                draw_text(2,222,"50%")
                                break;
                            }
                        //25%
                        case 2:
                            {
                                draw_set_font(menu_font)
                                draw_text(2,222,"25%")
                                break;
                            }
                        default: {break;}
                    }
            }
        //Draw Positions of Collision Sensors in "Advanced Mode"
        if debug_hud_sensors = 1
            {
                //Draw Sensors Hint
                if pause = 0 draw_sprite(spr_debug_hud_sensors_hint,0,329,90);
            }
    }
if room = rm_editor and user_cursor_mode = 0
    {
        //Set Font And Color
        draw_set_font(hud_font)
        draw_set_color(c_white)
        if obj_level_editor.use_debug_hud_mode = 1
            {
                //    Debug HUD Interface (Editor Mode)    //
                //=========================================//
        
                //Draw Highlights For Active Sensors
                if tile_exists(tile_surface_id[1]) draw_sprite(spr_debug_sensor_highlight,0,63,173); //Top Sensor
                if tile_exists(tile_surface_id[2]) draw_sprite(spr_debug_sensor_highlight,0,63,209); //Bottom Sensor
                if tile_exists(tile_surface_id[3]) draw_sprite(spr_debug_sensor_highlight,0,45,191); //Left Sensor
                if tile_exists(tile_surface_id[4]) draw_sprite(spr_debug_sensor_highlight,0,81,191); //Right
                //Slope Wall Collision Sensors
                if tile_wall_left_trig  = 1 draw_sprite(spr_debug_sensor_highlight_small,0,49,181);
                if tile_wall_right_trig = 1 draw_sprite(spr_debug_sensor_highlight_small,0,85,181);
                //Slope Ceiling Collision Sensors
                if tile_collision_ceiling_trigger = 1 draw_sprite(spr_debug_sensor_highlight_small,0,67,163);
                //Slope Floor Collision Sensors
                if gravity_slope = 1 or gravity_fof &gt; 0 draw_sprite(spr_debug_sensor_highlight_small,0,67,226);
                //Draw Player Status Variables
                draw_text(30,52,string(px))             //Player's X Position
                draw_text(30,64,string(py))             //Player's Y Position
                draw_text(88,76,string(hsp))            //Player's Horizontal Speed
                draw_text(88,88,string(gravity_speed))  //Player's Gravity    Speed
                draw_text(68,100,string(tile_angle))    //Player's Angle
                draw_text(90,112,string(xcompass))      //Player's Compass Direction
                draw_text(70,124,string(frame))         //Player's Current Animation Frame
                draw_text(69,136,string(anim_current))  //Player's Current Animation
                //Draw Debug HUD Elements As One Image
                draw_sprite(spr_debug_hud_status,0,12,35)
            }
        if pause = 1 draw_set_alpha(0.5);
        var bosses_check = 0
        bosses_check = scr_bosses_check();
        if obj_level_editor.use_npc_interaction_dialog_box_active = 0
        and bosses_check = 0
            {
                //Draw Current Character
                var debug_highlight_x_pos = 0;
                switch(skin)
                    {
                        case spr_lilac: {debug_highlight_x_pos = 155; break;}
                        case spr_carol:
                            {
                                debug_highlight_x_pos = 175;
                                if alt_skin = 1 debug_highlight_x_pos = 235;
                                if alt_skin = 2 debug_highlight_x_pos = 255;
                                break;
                            }
                        case spr_milla: {debug_highlight_x_pos = 195; break;}
                        case spr_spade: {debug_highlight_x_pos = 215; break;}
                    }
                draw_sprite(spr_debug_sensor_highlight,0,debug_highlight_x_pos,204);
                //Draw Debug HUD Elements As One Image
                draw_sprite(spr_debug_hud_characters,0,debug_characters_x,debug_characters_y+180)
                //Draw Performance Status Variables
                draw_text(189,224,string(fps))             //Number Of Frames Per Second
                draw_text(252,224,string(instance_count))  //Number Of Objects In The Room
                //Draw Debug HUD Elements As One Image
                draw_sprite(spr_debug_hud_performance,0,155,224)
            }

        draw_set_alpha(1)

        draw_set_font(number_font);
        draw_set_color(c_white);
        var HUD_offset_health_offset = 0;

        var hud_anchor_x = 143;
        if skin = spr_milla hud_anchor_x = 191;

        draw_sprite(spr_hud_pieces,lives_spr,hud_anchor_x,8+HUD_offset) //Lives Icon
        draw_sprite(spr_hud_pieces,1,hud_anchor_x+38,8+HUD_offset)      //Gems Icon

        if obj_level_editor.user_editor_hud_state = 2
            {
                draw_sprite(spr_hud_pieces,2,328,7+HUD_offset)         //Timer Icon
                draw_sprite(spr_hud_pieces,3,364,9+HUD_offset)         //Timer Colon Icon
                draw_sprite(spr_hud_pieces,3,390,9+HUD_offset)         //Timer Colon Icon
                //Milliseconds
                if hud_timer_mil&lt;10
                    {
                        draw_sprite(spr_number_font,0,395,8+HUD_offset)
                        draw_text(405,8+HUD_offset,floor(hud_timer_mil))
                    }
                if hud_timer_mil&gt;=10 draw_text(395,8+HUD_offset,floor(hud_timer_mil));
                //Seconds
                if hud_timer_sec&lt;10
                    {
                        draw_sprite(spr_number_font,0,369,8+HUD_offset)
                        draw_text(379,8+HUD_offset,floor(hud_timer_sec))
                    }
                if hud_timer_sec&gt;=10 draw_text(369,8+HUD_offset,floor(hud_timer_sec));
                //Minutes
                if hud_timer_min&lt;10
                    {
                        draw_sprite(spr_number_font,0,343,8+HUD_offset)
                        draw_text(353,8+HUD_offset,floor(hud_timer_min))
                    }
                if hud_timer_min&gt;=10 draw_text(343,8+HUD_offset,floor(hud_timer_min));
            }

        //Lives Counter
        //Less than Ten Lives
        if lives &lt; 0
            {
                draw_sprite(spr_number_font,0,hud_anchor_x+15,8+HUD_offset)
                draw_sprite(spr_number_font,0,hud_anchor_x+25,8+HUD_offset)
            }
        if lives &gt;= 0 and lives&lt;10
            {
                draw_sprite(spr_number_font,0,hud_anchor_x+15,8+HUD_offset)
                draw_text(hud_anchor_x+25,8+HUD_offset,lives)
            }
        if lives&gt;=10 and lives&lt;100 draw_text(hud_anchor_x+15,8+HUD_offset,lives);
        if lives &gt;= 100
            {
                draw_sprite(spr_number_font,9,hud_anchor_x+15,8+HUD_offset)
                draw_sprite(spr_number_font,9,hud_anchor_x+25,8+HUD_offset)
            }
        
        //Gem Counter
        if gems&lt;10
            {
                draw_sprite(spr_number_font,0,hud_anchor_x+47,8+HUD_offset)
                draw_sprite(spr_number_font,0,hud_anchor_x+57,8+HUD_offset)
                draw_sprite(spr_number_font,gems,hud_anchor_x+67,8+HUD_offset)
            }
        if gems&gt;=10 and gems&lt;100
            {
                draw_sprite(spr_number_font,0,hud_anchor_x+47,8+HUD_offset)
                draw_text(hud_anchor_x+57,8+HUD_offset,gems)
            }
        if gems&gt;=100 draw_text(hud_anchor_x+47,8+HUD_offset,gems);
        if obj_level_editor.use_debug_hud_mode = 0
            {
                //Draw Carol's HUD Graphics 
                if (skin = spr_carol)
                    {
                         if bike = 0 draw_sprite(spr_hud_carol,0,41,10+HUD_offset);
                         if bike = 1
                            {
                                draw_sprite(spr_hud_bike_gears,bike_gears,8,218+HUD_offset);
                                if user_move_list_control_type = 0
                                    draw_sprite(spr_keyboard_font,key_d,72,219+HUD_offset);
                                if user_move_list_control_type = 1
                                    draw_background(user_joystick_d,72,219+HUD_offset);
                            }
                    }
                var shield_hud_y_offset = 217;
                if key_has &gt; 0
                    {
                        var key_y_offset = 216;
                        var key_text_offset = 220;
                        if shield_active = 1 and bike = 0
                            {
                                key_y_offset = 190;
                                key_text_offset = 194;
                            }
                        if shield_active = 0 and bike = 1
                            {
                                key_y_offset = 198;
                                key_text_offset = 202;
                                shield_hud_y_offset = 199;
                            }
                        if shield_active = 1 and bike = 1
                            {
                                key_y_offset = 179;
                                key_text_offset = 183;
                                shield_hud_y_offset = 200;
                            }
                        draw_sprite(spr_hud_key,0,8,key_y_offset)
                        draw_text(30,key_text_offset,string(key_has))
                    }
                if key_has = 0
                    {
                        if shield_active = 1 and bike = 1
                            shield_hud_y_offset = 200;
                    }
                //Draw Shield Health
                if shield_active = 1 and targets_ready != 3
                    {
                        var shield_type = spr_hud_shield_wood;
                        switch(shield)
                            {
                                case spr_shield_water: {shield_type = spr_hud_shield_bubble; break;}
                                case spr_shield_earth: {shield_type = spr_hud_shield_earth; break;}
                                case spr_shield_fire_front: {shield_type = spr_hud_shield_fire; break;}
                                case spr_shield_metal: {shield_type = spr_hud_shield_metal; break;}
                                case spr_shield_rock: {shield_type = spr_hud_shield_rock; break;}
                                default: {shield_type = spr_hud_shield_wood; break;}
                            }
                        if skin = spr_milla
                                {
                                    if shield_health = 3 draw_sprite(shield_type,1,8,217);
                                    else draw_sprite(shield_type,shield_health,8,217);
                                }
                        else
                            draw_sprite(shield_type,shield_health+1,9,shield_hud_y_offset);
                    }
            }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw HUD

//===========================================================//
//                     Draw the game HUD                     //
//===========================================================//

//Make sure we are not using an alternative play mode before drawing
if use_menu = 0
    {
        if pause_sub_menu_transition &gt; 0.1
            draw_sprite_ext(spr_water,0,0,0,internal_res_width,internal_res_height,0,c_white,pause_sub_menu_transition);

        //Do not draw the left-hand side of the HUD if we are in editor mode
        if user_cursor_mode = 0
            {
                draw_set_font(number_font);
                draw_set_color(c_white);
                var HUD_offset_health_offset = 0;
                //Draw Main HUD
                if hud_graphics = spr_hud_main
                or hud_graphics = spr_hud_spa
                    {
                        var spade_offset_y = 10;
                        var spade_flash_y = 13;
                        if hud_graphics = spr_hud_spa
                            {
                                spade_offset_y = 7;
                                spade_flash_y = 10;
                            }
                        //HUD Decoration Bar
                        draw_sprite(hud_graphics,hud_flash,3,2+HUD_offset)
                        //Flash The Stamina Bar Once Upon Reaching 100%
                        var hud_bar_frame = 2;
                        switch(stamina_confirm)
                            {
                                case 1: {hud_bar_frame = 2; break;}
                                case 4: {hud_bar_frame = 2; break;}
                                case 5: {hud_bar_frame = 2; break;}
                                case 6: {hud_bar_frame = 1; break;}
                                case 7: {hud_bar_frame = 1; break;}
                                default: {hud_bar_frame = 3; break;}
                            }
                        var hud_flashing = spr_hud_flashing;
                        //Draw cards (If Spade)
                        if hud_graphics = spr_hud_spa
                            {
                                draw_sprite(spr_hud_cards,floor(cards/2),32,15+HUD_offset)
                                if card_flip_frame &lt; 9.8 draw_sprite(spr_hud_cards_flip,card_flip_frame,20+card_flip_x,15+HUD_offset);
                                if card_shine_frame &lt; 7.8
                                    {
                                        var count_cards = 0;
                                        while(count_cards &lt;= 7)
                                            {
                                                if count_cards*2 &lt; cards-0.8
                                                    draw_sprite(spr_hud_cards_shine,card_shine_frame,32+(12*count_cards),15+HUD_offset);
                                                count_cards += 1
                                            }
                                    }
                                draw_sprite(spr_hud_carol,0,67,7+HUD_offset)
                            }
                        //Draw Stamina Bar Line (If Carol)
                        if skin = spr_carol and bike = 0 draw_sprite(spr_hud_carol,0,41,10+HUD_offset);
                        //Draw Stamina Bar
                        if stamina &gt; 100
                            {
                                stamina_target = lerp(stamina_target,(stamina-100)*2,0.25)
                                hud_flashing = spr_hud_flashing_stamina;
                                draw_sprite_stretched(spr_hud_bar_stamina,0,32,spade_offset_y+HUD_offset,ceil(stamina_target),5);
                                if hud_bar_frame != 3 draw_sprite_stretched(spr_hud_bar_stamina,hud_bar_frame,32,spade_offset_y+HUD_offset,floor((stamina-100)*2),5);
                            }
                        if stamina &lt;= 100
                            {
                                draw_sprite_stretched(hud_bar_asset,0,32,spade_offset_y+HUD_offset,floor(stamina),5);
                                if hud_bar_frame != 3 draw_sprite_stretched(spr_hud_bar,hud_bar_frame,32,spade_offset_y+HUD_offset,stamina,5);
                            }
                        if (shine_frame&lt;=7 and (stamina=100 or stamina=150))
                            {
                                draw_sprite(spr_hud_shine,shine_frame,32,spade_offset_y+HUD_offset);
                                draw_sprite(hud_flashing,shine_frame,16,13+HUD_offset);
                            }
                        if speed_boosted_timer &gt; 0
                            {
                                draw_sprite(spr_hud_booster_timer,1,11,9+HUD_offset)
                                draw_sprite_part(spr_hud_booster_timer,0,0,0,floor(speed_boosted_timer),sprite_get_height(spr_hud_booster_timer),11,9+HUD_offset)
                            }
                        if potion_feather_timer &gt; 0
                            {
                                draw_sprite(spr_hud_feather_timer,1,11,9+HUD_offset)
                                draw_sprite_part(spr_hud_feather_timer,0,0,0,floor(potion_feather_timer),sprite_get_height(spr_hud_feather_timer),11,9+HUD_offset)
                            }
                        if potion_mystery_timer &gt; 0
                            {
                                draw_sprite(spr_hud_mystery_timer,1,11,9+HUD_offset)
                                draw_sprite_part(spr_hud_mystery_timer,0,0,0,floor(potion_mystery_timer),sprite_get_height(spr_hud_mystery_timer),11,9+HUD_offset)
                            }
                    }
                //Draw Milla's HUD Graphics
                if hud_graphics = spr_hud_alt
                    {
                        //HUD Decoration Bar
                        draw_sprite(hud_graphics,hud_flash,8,7+HUD_offset)
                        draw_sprite(spr_hud_milla,milla_hud,95,8+HUD_offset)
                        //HUD Action Icons
                        if milla_flutter_stamina_bar &lt;= 65
                            {   
                                draw_sprite_stretched(hud_bar_asset_alt,0,15,10+HUD_offset,clamp(0,65,milla_flutter_stamina_bar),5)
                            }
                        if milla_flutter_stamina_bar &gt; 65
                            {
                                draw_sprite_stretched(spr_hud_bar_stamina_alt,0,15,10+HUD_offset,(milla_flutter_stamina_bar-65)*2,5)
                            }
                        if (shine_frame&lt;=7 and milla_flutter_stamina_bar &gt;= 65) draw_sprite(spr_hud_shine_alt,shine_frame,15,10+HUD_offset);
                        //Draw Alt Cubes
                        if milla_phantom_attack_sprite = spr_cube_alt
                            draw_sprite(spr_hud_milla,7,95,8+HUD_offset);
                        if milla_phantom_attack_sprite = spr_cube_alt and hcap = 5
                            draw_sprite(spr_hud_milla,8,95,8+HUD_offset);
                        if milla_attack_skin_iterate = 0 draw_sprite(spr_hud_milla,9,95,8+HUD_offset);
                        if milla_attack_skin_iterate = 1 draw_sprite(spr_hud_milla,10,95,8+HUD_offset);
                        //Draw Flash Frame
                        if milla_hud_flash &gt; 1 draw_sprite(spr_hud_milla,5,95,8+HUD_offset);
                        if speed_boosted_timer &gt; 0
                            {
                                draw_sprite(spr_hud_booster_timer,1,7,3+HUD_offset)
                                draw_sprite_part(spr_hud_booster_timer,0,0,0,floor(speed_boosted_timer),sprite_get_height(spr_hud_booster_timer),7,3+HUD_offset)
                            }
                        if potion_feather_timer &gt; 0
                            {
                                draw_sprite(spr_hud_feather_timer,1,7,3+HUD_offset)
                                draw_sprite_part(spr_hud_feather_timer,0,0,0,floor(potion_feather_timer),sprite_get_height(spr_hud_feather_timer),7,3+HUD_offset)
                            }
                        if potion_mystery_timer &gt; 0
                            {
                                draw_sprite(spr_hud_mystery_timer,1,7,3+HUD_offset)
                                draw_sprite_part(spr_hud_mystery_timer,0,0,0,floor(potion_mystery_timer),sprite_get_height(spr_hud_mystery_timer),7,3+HUD_offset)
                            }
                        //Only Draw The Prompt If We Are Told To Remind The Player
                        if milla_digging_prompt_stop = 0
                            {
                                //Draw Digging Prompt
                                if (tile_ramp_id!=-1 and tile_ramp_id_debug=spr_dirt_0 and milla_digging_prompt_timer &lt;= 16)
                                    {
                                        draw_sprite(spr_hud_milla,6,94,27+HUD_offset);
                                        if user_move_list_control_type = 0
                                            draw_sprite(spr_keyboard_font,key_a,122,25+HUD_offset);
                                        else
                                            draw_background(user_joystick_a,122,25+HUD_offset);
                                    }
                                //Digging Prompt Timer
                                milla_digging_prompt_timer += 1
                                //Reset Digging Prompt Timer
                                if milla_digging_prompt_timer &gt; 32 milla_digging_prompt_timer = 0;
                            }
                        if user_move_list_control_type = 0
                            {
                                draw_sprite(spr_keyboard_font,key_a,88,8+HUD_offset)
                                draw_sprite(spr_keyboard_font,key_c,122,8+HUD_offset)
                                draw_sprite(spr_keyboard_font,key_d,156,8+HUD_offset)
                            }
                        else
                            {
                                draw_background(user_joystick_a,88,8+HUD_offset)
                                draw_background(user_joystick_c,122,8+HUD_offset)
                                draw_background(user_joystick_d,156,8+HUD_offset)
                            }
                        //Flash The Stamina Bar Once Upon Reaching 100%
                        if milla_flutter_stamina_bar &lt; 65
                            {
                                switch(stamina_gem)
                                    {
                                        case 1: {draw_sprite_stretched(spr_hud_bar_alt,2,15,10+HUD_offset,milla_flutter_stamina_bar,5);}
                                        case 4: {draw_sprite_stretched(spr_hud_bar_alt,2,15,10+HUD_offset,milla_flutter_stamina_bar,5);}
                                        case 5: {draw_sprite_stretched(spr_hud_bar_alt,2,15,10+HUD_offset,milla_flutter_stamina_bar,5);}
                                        case 6: {draw_sprite_stretched(spr_hud_bar_alt,1,15,10+HUD_offset,milla_flutter_stamina_bar,5);}
                                        case 7: {draw_sprite_stretched(spr_hud_bar_alt,1,15,10+HUD_offset,milla_flutter_stamina_bar,5);}
                                    }
                            }
                        HUD_offset_health_offset = -1
                    }
                //Draw Air Bar
                if breath_offset!=-14 and room != rm_editor draw_sprite(spr_air_bar,breath,breath_offset,96+HUD_offset);

                //Invulnerability Timer Icon
                if (invuln_hud_time &gt; 0 and invuln_hud_time &lt; 2680)
                    {
                        var invuln_x_pos = 218;
                        var invuln_x_off = 0;
                        if skin = spr_milla invuln_x_pos = 268;
                        if room = rm_campaign
                            {
                                if player_gems[player_current] &gt; 1000 and player_gems[player_current] &lt; 10000
                                    invuln_x_off = 12;
                                if player_gems[player_current] &gt; 10000 and player_gems[player_current] &lt; 100000
                                    invuln_x_off = 22;
                                if player_gems[player_current] &gt; 100000
                                    invuln_x_off = 32;
                            }
                        if invuln_hud_draw &lt; 0.5 draw_sprite(spr_hud_invuln,invuln_hud_fram,invuln_x_pos+invuln_x_off,5+HUD_offset);
                    }
        
                //Ready! Go!
                switch(targets_ready)
                    {
                        case 0: {break;}
                        //Ready Graphic And Progress Bar
                        case 1:
                            {
                                draw_sprite(spr_hud_ready,0,151,167)
                                draw_sprite_ext(spr_hud_ready_bar,0,155,196,floor(hud_ready_bar_length),1,0,c_white,1)
                                if room = rm_campaign
                                    {
                                        draw_set_font(menu_font)
                                        draw_set_color(c_white)
                                        draw_set_halign(fa_middle)
                                        draw_text(213,208,"By:     "+campaign_stage_description)
                                        draw_set_halign(fa_left)
                                        draw_set_font(number_font)
                                    }
                                break;
                            }
                        //Go
                        case 2:
                            {
                                draw_sprite(spr_hud_go,0,185+hud_go_shake,169+hud_go_shake)
                                break;
                            }
                        //Clear
                        case 3:
                            {
                                if hud_new_record = 1
                                    draw_sprite(spr_hud_new_record,0,156+hud_go_shake,25+hud_go_shake);
                                break;
                            }
                    }
                //Draw Health Petals
                var hud_anchor_x = 26;
                var hud_anchor_y = 21;
                if skin = spr_milla
                    {
                        hud_anchor_x = 10
                        hud_anchor_y = 19
                    }
                if skin = spr_spade
                    {
                        hud_anchor_x = 19
                        hud_anchor_y = 31
                    }
                var petals_anchor = 0;
                if frac(petals) != 0
                    petals_anchor = 0.45;
                clamp(petals,-14,14)
                var petals_combined = petals+petals_anchor;
                clamp(petals_combined,-14,14)
                draw_sprite(hud_petals,petals_combined,hud_anchor_x,hud_anchor_y+HUD_offset+HUD_offset_health_offset)
                //Draw health percentage
                if petals_anchor &gt; 0
                    draw_sprite_part(spr_hud_petal_bar,petals_combined,0,0,petals*7.714285,13,hud_anchor_x,hud_anchor_y+HUD_offset+HUD_offset_health_offset);
                else
                    draw_sprite(spr_hud_petal_bar,petals_combined,hud_anchor_x,hud_anchor_y+HUD_offset+HUD_offset_health_offset);
            }
        
        //=============Timers and Counters=============//

        if room != rm_editor
            {
                //=================HUD Elements==================//

                var hud_anchor_x = 143;
                if skin = spr_milla hud_anchor_x = 191; 

                script_execute(pal_swap_script,my_pal_sprite,current_pal,false)
                draw_sprite(spr_hud_pieces,lives_spr,hud_anchor_x,8+HUD_offset) //Lives Icon
                shader_reset();
                draw_sprite(spr_hud_pieces,1,hud_anchor_x+38,8+HUD_offset)      //Gems Icon

                //===============Shang Mu Targets================//
        
                //Draw Targets
                //(Only in player mode; this isn't necessary for either editor mode or story mode)
                if room != rm_editor
                    {
                        if targets &gt; 0
                            {
                                if targets &lt;= 16 draw_sprite(targets_mode,targets,288,21+HUD_offset);
                                else
                                    {
                                        draw_sprite(targets_mode,1,288,21+HUD_offset)
                                        draw_sprite(spr_hud_pieces,3,395,24+HUD_offset)
                                        draw_set_halign(fa_right)
                                        draw_text(394,23+HUD_offset,targets)
                                        draw_set_halign(fa_left)
                                    }
                            }
                    }

                //Lives Counter
                //Less than Ten Lives
                if lives &lt; 0
                    {
                        draw_sprite(spr_number_font,0,hud_anchor_x+15,8+HUD_offset)
                        draw_sprite(spr_number_font,0,hud_anchor_x+25,8+HUD_offset)
                    }
                if lives &gt;= 0 and lives&lt;10
                    {
                        draw_sprite(spr_number_font,0,hud_anchor_x+15,8+HUD_offset)
                        draw_text(hud_anchor_x+25,8+HUD_offset,lives)
                    }
                if lives&gt;=10 and lives&lt;100 draw_text(hud_anchor_x+15,8+HUD_offset,lives);
                if lives &gt;= 100
                    {
                        draw_sprite(spr_number_font,9,hud_anchor_x+15,8+HUD_offset)
                        draw_sprite(spr_number_font,9,hud_anchor_x+25,8+HUD_offset)
                    }
                
                //Gem Counter
                var gem_value = gems;
                if room = rm_campaign
                    gem_value = player_gems[player_current];
                if gem_value&lt;10
                    {
                        draw_sprite(spr_number_font,0,hud_anchor_x+47,8+HUD_offset)
                        draw_sprite(spr_number_font,0,hud_anchor_x+57,8+HUD_offset)
                        draw_sprite(spr_number_font,gem_value,hud_anchor_x+67,8+HUD_offset)
                    }
                if gem_value&gt;=10 and gem_value&lt;100
                    {
                        draw_sprite(spr_number_font,0,hud_anchor_x+47,8+HUD_offset)
                        draw_text(hud_anchor_x+57,8+HUD_offset,gem_value)
                    }
                if gem_value&gt;=100 draw_text(hud_anchor_x+47,8+HUD_offset,gem_value);

                if draw_timer = 1
                    {
                        draw_sprite(spr_hud_pieces,2,328,7+HUD_offset)         //Timer Icon
                        draw_sprite(spr_hud_pieces,3,364,9+HUD_offset)         //Timer Colon Icon
                        draw_sprite(spr_hud_pieces,3,390,9+HUD_offset)         //Timer Colon Icon
                        //Milliseconds
                        if hud_timer_mil&lt;10
                            {
                                draw_sprite(spr_number_font,0,395,8+HUD_offset)
                                draw_text(405,8+HUD_offset,floor(hud_timer_mil))
                            }
                        if hud_timer_mil&gt;=10 draw_text(395,8+HUD_offset,floor(hud_timer_mil));
                        //Seconds
                        if hud_timer_sec&lt;10
                            {
                                draw_sprite(spr_number_font,0,369,8+HUD_offset)
                                draw_text(379,8+HUD_offset,floor(hud_timer_sec))
                            }
                        if hud_timer_sec&gt;=10 draw_text(369,8+HUD_offset,floor(hud_timer_sec));
                        //Minutes
                        if hud_timer_min&lt;10
                            {
                                draw_sprite(spr_number_font,0,343,8+HUD_offset)
                                draw_text(353,8+HUD_offset,floor(hud_timer_min))
                            }
                        if hud_timer_min&gt;=10 draw_text(343,8+HUD_offset,floor(hud_timer_min));
                    }
                //Draw Carol's HUD Graphics 
                if (skin = spr_carol and debug_hud = 1)
                    {
                         if bike = 1
                            {
                                draw_sprite(spr_hud_bike_gears,bike_gears,8,218+HUD_offset);
                                if user_move_list_control_type = 0
                                    draw_sprite(spr_keyboard_font,key_d,72,219+HUD_offset);
                                if user_move_list_control_type = 1
                                    draw_background(user_joystick_d,72,219+HUD_offset);
                            }
                    }
                //Draw Keycards
                if debug_hud = 1
                    {
                        var shield_hud_y_offset = 217;
                        if key_has &gt; 0
                            {
                                var key_y_offset = 216;
                                var key_text_offset = 220;
                                if shield_active = 1 and bike = 0
                                    {
                                        key_y_offset = 190;
                                        key_text_offset = 194;
                                    }
                                if shield_active = 0 and bike = 1
                                    {
                                        key_y_offset = 198;
                                        key_text_offset = 202;
                                        shield_hud_y_offset = 199;
                                    }
                                if shield_active = 1 and bike = 1
                                    {
                                        key_y_offset = 179;
                                        key_text_offset = 183;
                                        shield_hud_y_offset = 200;
                                    }
                                draw_sprite(spr_hud_key,0,8,key_y_offset)
                                draw_text(30,key_text_offset,string(key_has))
                            }
                        if key_has = 0
                            {
                                if shield_active = 1 and bike = 1
                                    shield_hud_y_offset = 200;
                            }
                        //Draw Shield Health
                        if shield_active = 1 and targets_ready != 3
                            {
                                var shield_type = spr_hud_shield_wood;
                                switch(shield)
                                    {
                                        case spr_shield_water: {shield_type = spr_hud_shield_bubble; break;}
                                        case spr_shield_earth: {shield_type = spr_hud_shield_earth; break;}
                                        case spr_shield_fire_front: {shield_type = spr_hud_shield_fire; break;}
                                        case spr_shield_metal: {shield_type = spr_hud_shield_metal; break;}
                                        case spr_shield_rock: {shield_type = spr_hud_shield_rock; break;}
                                        default: {shield_type = spr_hud_shield_wood; break;}
                                    }
                                if skin = spr_milla
                                        {
                                            if shield_health = 3 draw_sprite(shield_type,1,8,217);
                                            else draw_sprite(shield_type,shield_health,8,217);
                                        }
                                else
                                    draw_sprite(shield_type,shield_health+1,9,shield_hud_y_offset);
                            }
                    }
            }

        //=============Particle Effects=============//

        if performance_profile = 1
            {
                //Draw Gem Particles
                if gem_particle_trigger = 1 and debug_hud = 1 and user_cursor_mode = 0
                    {
                        if gem_particle_trig_0 = 1  draw_sprite_ext(spr_hud_gem_plus,gem_particle_frame_0,13,53+gem_ispeed_0,1,1,0,c_white,gem_particle_alpha_0);
                        if gem_particle_trig_1 = 1  draw_sprite_ext(spr_hud_gem_plus,gem_particle_frame_1,13,65+gem_ispeed_1,1,1,0,c_white,gem_particle_alpha_1);
                        if gem_particle_trig_2 = 1  draw_sprite_ext(spr_hud_gem_plus,gem_particle_frame_2,13,77+gem_ispeed_2,1,1,0,c_white,gem_particle_alpha_2);
                        if gem_particle_trig_3 = 1  draw_sprite_ext(spr_hud_gem_plus,gem_particle_frame_3,13,89+gem_ispeed_3,1,1,0,c_white,gem_particle_alpha_3);
                        if gem_particle_trig_4 = 1  draw_sprite_ext(spr_hud_gem_plus,gem_particle_frame_4,13,101+gem_ispeed_4,1,1,0,c_white,gem_particle_alpha_4);
                        if gem_particle_trig_5 = 1  draw_sprite_ext(spr_hud_gem_plus,gem_particle_frame_5,13,113+gem_ispeed_5,1,1,0,c_white,gem_particle_alpha_5);
                        if gem_particle_trig_6 = 1  draw_sprite_ext(spr_hud_gem_plus,gem_particle_frame_6,13,125+gem_ispeed_6,1,1,0,c_white,gem_particle_alpha_6);
                        if gem_particle_trig_7 = 1  draw_sprite_ext(spr_hud_gem_plus,gem_particle_frame_7,13,137+gem_ispeed_7,1,1,0,c_white,gem_particle_alpha_7);
                        if gem_particle_trig_8 = 1  draw_sprite_ext(spr_hud_gem_plus,gem_particle_frame_8,13,149+gem_ispeed_8,1,1,0,c_white,gem_particle_alpha_8);
                        if gem_particle_trig_9 = 1  draw_sprite_ext(spr_hud_gem_plus,gem_particle_frame_9,13,161+gem_ispeed_9,1,1,0,c_white,gem_particle_alpha_9);
                        if gem_particle_trig_10 = 1 draw_sprite_ext(spr_hud_gem_plus,gem_particle_frame_10,13,173+gem_ispeed_10,1,1,0,c_white,gem_particle_alpha_10);
                        if gem_particle_trig_11 = 1 draw_sprite_ext(spr_hud_gem_plus,gem_particle_frame_11,13,185+gem_ispeed_11,1,1,0,c_white,gem_particle_alpha_11);
                        if gem_particle_trig_12 = 1 draw_sprite_ext(spr_hud_gem_plus,gem_particle_frame_12,13,197+gem_ispeed_12,1,1,0,c_white,gem_particle_alpha_12);
                        if gem_particle_trig_13 = 1 draw_sprite_ext(spr_hud_gem_plus,gem_particle_frame_13,13,209+gem_ispeed_13,1,1,0,c_white,gem_particle_alpha_13);
                    }
            }

        //===========================================================//
        //                      Settings Screen                      //
        //===========================================================//

        if pause = 1
            {
                if pause_sub_menu = 0
                    {
                        draw_sprite(spr_ui_stage_results_0,1,119,77)
                        draw_set_font(stage_title_font)
                        draw_set_color(c_white)
                        draw_set_halign(fa_middle)
                        draw_text(213,81,lang_gui[user_language_mode,19])
                        draw_set_halign(fa_left)
                        var checkpoint_alpha = 1;
                        var quit_string = lang_gui[user_language_mode,4];
                        if room != rm_editor
                            {
                                //Exceptions list for hub maps
                                var yes = 1;
                                if room = rm_campaign
                                    yes = scr_get_restart_map_exceptions_list();

                                if classic_mode = 1
                                    {
                                        quit_string = lang_gui[user_language_mode,20]
                                        if lives &lt;= 0 checkpoint_alpha = 0.5
                                    }
                                else
                                    {
                                        if lives &lt;= 0 checkpoint_alpha = 0.5;
                                        if yes = 0
                                            {
                                                quit_string = lang_gui[user_language_mode,20]
                                                checkpoint_alpha = 0.5
                                            }
                                    }
                                draw_sprite(spr_pause_menu_4,0,162,118)
                                draw_set_font(menu_font)
                                draw_set_color(c_white)
                                draw_set_halign(fa_left)
                                draw_text(184,118,lang_gui[user_language_mode,0])
                                draw_text(184,141,lang_gui[user_language_mode,1])
                                draw_set_alpha(checkpoint_alpha)
                                draw_text(184,164,lang_gui[user_language_mode,2])
                                draw_set_alpha(1)
                                draw_text(184,187,lang_gui[user_language_mode,3])
                                draw_text(184,211,quit_string)
                                if yy=24
                                or (joy_mouse_button_switch = 1 and room != rm_editor
                                and device_mouse_x_to_gui(0) &gt; 138 and device_mouse_x_to_gui(0) &lt; 428
                                and device_mouse_y_to_gui(0) &gt; 141 and device_mouse_y_to_gui(0) &lt; 157)
                                    {
                                        var display_amount = 10;
                                        var display_max = 10;
                                        var display_string = lang_gui[user_language_mode,5];
                                        switch(pause_potion_menu_select)
                                            {
                                                case 0: {display_string = lang_gui[user_language_mode,5];  display_amount = potion_petal_potion;   display_max = 10; break;}
                                                case 1: {display_string = lang_gui[user_language_mode,6];  display_amount = potion_stamina_drink;  display_max = 10; break;}
                                                case 2: {display_string = lang_gui[user_language_mode,7];  display_amount = potion_feather_potion; display_max = 2;  break;}
                                                case 3: {display_string = lang_gui[user_language_mode,8];  display_amount = potion_petal_core;     display_max = 2;  break;}
                                                case 4: {display_string = lang_gui[user_language_mode,9];  display_amount = potion_stamina_core;   display_max = 2;  break;}
                                                case 5: {display_string = lang_gui[user_language_mode,10]; display_amount = potion_mystery_potion; display_max = 12; break;}
                                            }
                                        draw_set_font(version_number_font)
                                        draw_set_halign(fa_right)
                                        draw_set_color(c_white)
                                        draw_text(419,130,string(display_amount) + " / "+string(display_max))
                                        draw_set_halign(fa_left)
                                        draw_text(283,129,display_string)
                                        var pause_potion_menu_x = pause_potion_menu_select*20;
                                        draw_sprite_ext(spr_pause_menu_potions,0,275+pause_potion_menu_offset,139,1,1,0,c_white,pause_potion_menu_alpha)
                                        draw_sprite(spr_pause_menu_potions,1,275+pause_potion_menu_offset+pause_potion_menu_x,139)
                                        pause_potion_menu_offset += 5
                                        if pause_potion_menu_offset &gt; 0
                                            pause_potion_menu_offset = 0;
                                        pause_potion_menu_alpha += 0.10
                                        if pause_potion_menu_alpha &gt; 1
                                            pause_potion_menu_alpha = 1;
                                    }
                                else
                                    {
                                        draw_sprite_ext(spr_pause_menu_potions,0,275+pause_potion_menu_offset,139,1,1,0,c_white,pause_potion_menu_alpha)
                                        pause_potion_menu_offset -= 5
                                        if pause_potion_menu_offset &lt; -32
                                            pause_potion_menu_offset = -32;
                                        pause_potion_menu_alpha -= 0.10
                                        if pause_potion_menu_alpha &lt; 0
                                            pause_potion_menu_alpha = 0;
                                    }
                            }
                        else
                            {
                                draw_sprite(spr_pause_menu_2,0,162,118)
                                draw_set_font(menu_font)
                                draw_set_color(c_white)
                                draw_set_halign(fa_left)
                                draw_text(184,118,lang_gui[user_language_mode,0])
                                draw_set_alpha(0.5)
                                draw_text(184,141,lang_gui[user_language_mode,2])
                                draw_set_alpha(1)
                                draw_text(184,164,lang_gui[user_language_mode,21])
                            }
                        draw_sprite(spr_pause_menu_3,pause_crystal_timer,138,119+yy);
                    }
                else
                    {
                        //Language Offset
                        var language_offset = 0;
                        if (user_language_mode = 0) language_offset = 32;
                        draw_sprite(spr_pause_menu_5,0,14+language_offset,53)
                        draw_sprite(spr_ui_stage_results_0,1,119,59)
                        draw_set_font(stage_title_font)
                        draw_set_color(c_white)
                        draw_set_halign(fa_middle)
                        draw_text(213,63,lang_gui[user_language_mode,3])
                        //Draw Options Text
                        draw_set_font(menu_font)
                        draw_set_color(c_white)
                        draw_set_halign(fa_left)
                        //Camera Shake
                        draw_text(52+language_offset,97,lang_gui[user_language_mode,11])
                        var zoom_string = lang_gui[user_language_mode,17];
                            if user_disable_zoom_gimmick = 1 zoom_string = lang_gui[user_language_mode,18];
                        //Camera Zoom
                        draw_text(52+language_offset,117,lang_gui[user_language_mode,12])
                        var display_moves_string = lang_gui[user_language_mode,17];
                            if user_move_list_display = 1 display_moves_string = lang_gui[user_language_mode,18];
                        draw_text(52+language_offset,137,lang_gui[user_language_mode,13])
                        var enemy_health_string = lang_gui[user_language_mode,17];
                            if user_enemy_health_display = 1 enemy_health_string = lang_gui[user_language_mode,18];
                        draw_text(52+language_offset,157,lang_gui[user_language_mode,14])
                        draw_text(52+language_offset,177,lang_gui[user_language_mode,15])
                        //Camera Shake
                        draw_set_halign(fa_middle)
                        draw_text(353,97,string(user_camera_shake_intensity*100)+"%")
                        draw_text(353,117,zoom_string)
                        draw_text(353,137,display_moves_string)
                        draw_text(353,157,enemy_health_string)
                        draw_text(353,177,string(string_format(o.deadzone_mod*100,2,0))+"%")
                        //Back
                        draw_text(213,197,lang_gui[user_language_mode,16])
                        //Pause Crystal Cursor
                        var pause_cursor_offset = 8;
                        if (yy = 120)
                            {
                                pause_cursor_offset = 148
                                language_offset = 0
                            }
                        draw_sprite(spr_pause_menu_3,pause_crystal_timer,language_offset+pause_cursor_offset,101+(yy/1.2));
                        draw_set_halign(fa_left)
                        draw_set_font(number_font);
                        draw_set_color(c_white);
                    }
                //Animate cursor
                pause_crystal_timer+=0.1 if pause_crystal_timer&gt;6.8 pause_crystal_timer=0;
            }
        //Moves List
        if user_move_list_display = 1 and debug_hud_mode = 0 and user_cursor_mode = 0
            {
                var anchor_x = 304;
                var anchor_y = 54;
                if room = rm_editor
                    {
                        anchor_x = 8;
                        if debug_hud_sensors = 1 anchor_x = 436;
                    }
                switch(skin)
                    {
                        //Lilac
                        case spr_lilac:
                            {
                                //Ground State True
                                if ground = 1
                                    {
                                        draw_sprite(spr_lilac_move_list_1,0,anchor_x,anchor_y);
                                        //Keyboard
                                        if user_move_list_control_type = 0
                                            {
                                                //Crouch Kick
                                                draw_sprite(spr_keyboard_font,key_down,anchor_x+4,anchor_y+28)
                                                draw_sprite(spr_keyboard_font,key_a,anchor_x+29,anchor_y+28)
                                                //Down Cyclone
                                                draw_sprite(spr_keyboard_font,key_down,anchor_x+4,anchor_y+55)
                                                draw_sprite(spr_keyboard_font,key_a,anchor_x+29,anchor_y+55)
                                                //Rising Slash
                                                draw_sprite(spr_keyboard_font,key_up,anchor_x+4,anchor_y+83)
                                                draw_sprite(spr_keyboard_font,key_a,anchor_x+29,anchor_y+83)
                                                //Dragon Boost
                                                draw_sprite(spr_keyboard_font,key_c,anchor_x+4,anchor_y+110)
                                                draw_sprite(spr_keyboard_font,key_c,anchor_x+36,anchor_y+110)
                                                draw_sprite(spr_keyboard_font,key_up,anchor_x+61,anchor_y+110)
                                                //Dragon Boost Cancel
                                                draw_sprite_ext(spr_keyboard_font,key_c,anchor_x+4,anchor_y+137,1,1,0,c_white,0.5)
                                            }
                                        else
                                            {
                                                //Crouch Kick
                                                draw_background(user_joystick_down,anchor_x+4,anchor_y+28)
                                                draw_background(user_joystick_a,anchor_x+29,anchor_y+28)
                                                //Down Cyclone
                                                draw_background(user_joystick_down,anchor_x+4,anchor_y+55)
                                                draw_background(user_joystick_a,anchor_x+29,anchor_y+55)
                                                //Rising Slash
                                                draw_background(user_joystick_up,anchor_x+4,anchor_y+83)
                                                draw_background(user_joystick_a,anchor_x+29,anchor_y+83)
                                                //Dragon Boost
                                                draw_background(user_joystick_c,anchor_x+4,anchor_y+110)
                                                draw_background(user_joystick_c,anchor_x+36,anchor_y+110)
                                                draw_background(user_joystick_up,anchor_x+61,anchor_y+110)
                                                //Dragon Boost Cancel
                                                draw_background_ext(user_joystick_c,anchor_x+4,anchor_y+137,1,1,0,c_white,0.5)
                                            }
                                    }
                                //Ground State False
                                else
                                    {
                                        if anim_current=anim_lilac_dragon_boost_2
                                            draw_sprite(spr_lilac_move_list_2,1,anchor_x,anchor_y);
                                        else
                                            draw_sprite(spr_lilac_move_list_2,0,anchor_x,anchor_y);
                                        //Keyboard
                                        if user_move_list_control_type = 0
                                            {
                                                //Dive Kick
                                                draw_sprite(spr_keyboard_font,key_down,anchor_x+4,anchor_y+28)
                                                draw_sprite(spr_keyboard_font,key_a,anchor_x+29,anchor_y+28)
                                                //Cyclone
                                                draw_sprite(spr_keyboard_font,key_b,anchor_x+4,anchor_y+55)
                                                //Down Cyclone
                                                draw_sprite(spr_keyboard_font,key_down,anchor_x+4,anchor_y+83)
                                                draw_sprite(spr_keyboard_font,key_b,anchor_x+29,anchor_y+83)
                                                //Dragon Boost
                                                draw_sprite(spr_keyboard_font,key_c,anchor_x+4,anchor_y+110)
                                                draw_sprite(spr_keyboard_font,key_c,anchor_x+36,anchor_y+110)
                                                draw_sprite(spr_keyboard_font,key_up,anchor_x+61,anchor_y+110)
                                                //Dragon Boost Cancel
                                                if anim_current=anim_lilac_dragon_boost_2
                                                    draw_sprite(spr_keyboard_font,key_c,anchor_x+4,anchor_y+137);
                                                else
                                                    draw_sprite_ext(spr_keyboard_font,key_c,anchor_x+4,anchor_y+137,1,1,0,c_white,0.5);
                                            }
                                        //Joystick
                                        else
                                            {
                                                //Crouch Kick
                                                draw_background(user_joystick_down,anchor_x+4,anchor_y+28)
                                                draw_background(user_joystick_a,anchor_x+29,anchor_y+28)
                                                //Cyclone
                                                draw_background(user_joystick_b,anchor_x+29,anchor_y+55)
                                                //Down Cyclone
                                                draw_background(user_joystick_down,anchor_x+4,anchor_y+83)
                                                draw_background(user_joystick_b,anchor_x+29,anchor_y+83)
                                                //Dragon Boost
                                                draw_background(user_joystick_c,anchor_x+4,anchor_y+110)
                                                draw_background(user_joystick_c,anchor_x+36,anchor_y+110)
                                                draw_background(user_joystick_up,anchor_x+61,anchor_y+110)
                                                //Dragon Boost Cancel
                                                if anim_current=anim_lilac_dragon_boost_2
                                                    draw_background(user_joystick_c,anchor_x+4,anchor_y+137);
                                                else
                                                    draw_background_ext(user_joystick_c,anchor_x+4,anchor_y+137,1,1,0,c_white,0.5);
                                            }
                                    }
                                break;
                            }
                        //Carol
                        case spr_carol:
                            {
                                if bike = 0
                                    {
                                        if gravity_speed = 0
                                            {
                                                draw_sprite(spr_carol_move_list_1,0,anchor_x,anchor_y);
                                                //Keyboard
                                                if user_move_list_control_type = 0
                                                    {
                                                        //Pounce
                                                        draw_sprite(spr_keyboard_font,key_down,anchor_x+60,anchor_y+17)
                                                        draw_sprite(spr_keyboard_font,key_b,anchor_x+85,anchor_y+17)
                                                        //Roll
                                                        draw_sprite(spr_keyboard_font,key_down,anchor_x+85,anchor_y+34)
                                                        //Wild Kick
                                                        draw_sprite(spr_keyboard_font,key_c,anchor_x+85,anchor_y+51)
                                                        //Wild Claw
                                                        draw_sprite(spr_keyboard_font,key_a,anchor_x+85,anchor_y+130)
                                                        //High Kick
                                                        draw_sprite(spr_keyboard_font,key_up,anchor_x+60,anchor_y+68)
                                                        draw_sprite(spr_keyboard_font,key_a,anchor_x+85,anchor_y+68)
                                                    }
                                                //Joystick
                                                else
                                                    {
                                                        //Pounce
                                                        draw_background(user_joystick_down,anchor_x+60,anchor_y+17)
                                                        draw_background(user_joystick_b,anchor_x+85,anchor_y+17)
                                                        //Roll
                                                        draw_background(user_joystick_down,anchor_x+85,anchor_y+34)
                                                        //Wild Kick
                                                        draw_background(user_joystick_c,anchor_x+85,anchor_y+51)
                                                        //Wild Claw
                                                        draw_background(user_joystick_a,anchor_x+85,anchor_y+130)
                                                        //High Kick
                                                        draw_background(user_joystick_up,anchor_x+60,anchor_y+68)
                                                        draw_background(user_joystick_a,anchor_x+85,anchor_y+68)
                                                    }
                                            }
                                        else
                                            {
                                                //Keyboard
                                                if user_move_list_control_type = 0
                                                    {
                                                        if anim_current=anim_carol_crouch_attack
                                                            {
                                                                draw_sprite(spr_carol_move_list_3,0,anchor_x,anchor_y);
                                                                //Pounce
                                                                draw_sprite_ext(spr_keyboard_font,key_b,anchor_x+85,anchor_y+17,1,1,0,c_white,0.5)
                                                                //Roll
                                                                draw_sprite_ext(spr_keyboard_font,key_down,anchor_x+85,anchor_y+34,1,1,0,c_white,0.5)
                                                                //Wild Kick
                                                                draw_sprite(spr_keyboard_font,key_c,anchor_x+85,anchor_y+51)
                                                            }
                                                        else
                                                            {
                                                                draw_sprite(spr_carol_move_list_2,0,anchor_x,anchor_y);
                                                                //Pounce
                                                                draw_sprite(spr_keyboard_font,key_b,anchor_x+85,anchor_y+17)
                                                                //Roll
                                                                draw_sprite_ext(spr_keyboard_font,key_down,anchor_x+85,anchor_y+34,1,1,0,c_white,0.5)
                                                                //Wild Kick
                                                                draw_sprite(spr_keyboard_font,key_c,anchor_x+85,anchor_y+51)
                                                                //High Kick
                                                                draw_sprite(spr_keyboard_font,key_up,anchor_x+60,anchor_y+68)
                                                                draw_sprite(spr_keyboard_font,key_a,anchor_x+85,anchor_y+68)
                                                            }
                                                        //Wild Claw
                                                        draw_sprite(spr_keyboard_font,key_a,anchor_x+43,anchor_y+130)
                                                        //Jump Kick
                                                        draw_sprite(spr_keyboard_font,key_down,anchor_x+60,anchor_y+85)
                                                        draw_sprite(spr_keyboard_font,key_a,anchor_x+85,anchor_y+85)
                                                    }
                                                else
                                                    {
                                                        if anim_current=anim_carol_crouch_attack
                                                            {
                                                                draw_sprite(spr_carol_move_list_3,0,anchor_x,anchor_y);
                                                                //Pounce
                                                                draw_background_ext(user_joystick_b,anchor_x+85,anchor_y+17,1,1,0,c_white,0.5)
                                                                //Roll
                                                                draw_background_ext(user_joystick_down,anchor_x+85,anchor_y+34,1,1,0,c_white,0.5)
                                                                //Wild Kick
                                                                draw_background(user_joystick_c,anchor_x+85,anchor_y+51)
                                                            }
                                                        else
                                                            {
                                                                draw_sprite(spr_carol_move_list_2,0,anchor_x,anchor_y);
                                                                //Pounce
                                                                draw_background(user_joystick_b,anchor_x+85,anchor_y+17)
                                                                //Roll
                                                                draw_background_ext(user_joystick_down,anchor_x+85,anchor_y+34,1,1,0,c_white,0.5)
                                                                //Wild Kick
                                                                draw_background(user_joystick_c,anchor_x+85,anchor_y+51)
                                                                //High Kick
                                                                draw_background(user_joystick_up,anchor_x+60,anchor_y+68)
                                                                draw_background(user_joystick_a,anchor_x+85,anchor_y+68)
                                                            }
                                                        //Wild Claw
                                                        draw_background(user_joystick_a,anchor_x+43,anchor_y+130)
                                                        //Jump Kick
                                                        draw_background(user_joystick_down,anchor_x+60,anchor_y+85)
                                                        draw_background(user_joystick_a,anchor_x+85,anchor_y+85)
                                                    }
                                            }
                                    }
                                else
                                    {
                                        if gravity_speed = 0
                                            {
                                                draw_sprite(spr_carol_bike_moves_list_1,0,anchor_x,anchor_y);
                                                if user_move_list_control_type = 0
                                                    {
                                                        //Dismount
                                                        draw_sprite(spr_keyboard_font,key_down,anchor_x+62,anchor_y+17)
                                                        draw_sprite(spr_keyboard_font,key_b,anchor_x+87,anchor_y+17)
                                                        //Nitro Boost
                                                        draw_sprite(spr_keyboard_font,key_down,anchor_x+87,anchor_y+34)
                                                        //Wild Claw
                                                        draw_sprite(spr_keyboard_font,key_a,anchor_x+87,anchor_y+75)
                                                    }
                                                else
                                                    {
                                                        //Dismount
                                                        draw_background(user_joystick_down,anchor_x+62,anchor_y+17)
                                                        draw_background(user_joystick_b,anchor_x+87,anchor_y+17)
                                                        //Nitro Boost
                                                        draw_background(user_joystick_down,anchor_x+87,anchor_y+34)
                                                        //Wild Claw
                                                        draw_background(user_joystick_a,anchor_x+87,anchor_y+75)
                                                    }
                                            }
                                        else
                                            {
                                                draw_sprite(spr_carol_bike_moves_list_2,0,anchor_x,anchor_y);
                                                if user_move_list_control_type = 0
                                                    {
                                                        //Dismount
                                                        draw_sprite_ext(spr_keyboard_font,key_down,anchor_x+62,anchor_y+17,1,1,0,c_white,0.5)
                                                        draw_sprite_ext(spr_keyboard_font,key_b,anchor_x+87,anchor_y+17,1,1,0,c_white,0.5)
                                                        //Air Spin
                                                        draw_sprite(spr_keyboard_font,key_b,anchor_x+87,anchor_y+34)
                                                        //Wild Claw
                                                        draw_sprite(spr_keyboard_font,key_c,anchor_x+43,anchor_y+76)
                                                    }
                                                else
                                                    {
                                                        //Dismount
                                                        draw_background_ext(user_joystick_down,anchor_x+62,anchor_y+17,1,1,0,c_white,0.5)
                                                        draw_background_ext(user_joystick_b,anchor_x+87,anchor_y+17,1,1,0,c_white,0.5)
                                                        //Air Spin
                                                        draw_background(user_joystick_b,anchor_x+87,anchor_y+34)
                                                        //Wild Claw
                                                        draw_background(user_joystick_c,anchor_x+43,anchor_y+76)
                                                    }
                                            }
                                    }
                                break;
                            }
                        //Milla
                        case spr_milla:
                            {
                                if debug_hud_sensors = 0
                                    {
                                        anchor_x = 9
                                        anchor_y = 33
                                    }
                                else
                                    {
                                        anchor_x = 304
                                        anchor_y = 54
                                        if room = rm_editor anchor_x = 436;
                                    }
                                draw_sprite(spr_milla_moves_list_1,0,anchor_x,anchor_y)
                                if instance_exists(milla_item_id)
                                    {
                                        draw_sprite(spr_milla_moves_pickup_item,0,anchor_x+4,anchor_y+20)
                                        //Render "Puppy Float" At Half-Transparency
                                        if user_move_list_control_type = 0
                                            {
                                                draw_sprite(spr_keyboard_font,key_a,anchor_x+91,anchor_y+17)
                                                draw_sprite_ext(spr_keyboard_font,key_b,anchor_x+91,anchor_y+34,1,1,0,c_white,0.5)
                                                draw_sprite_ext(spr_milla_moves_puppy_float,0,anchor_x+4,anchor_y+37,1,1,0,c_white,0.5)
                                            }
                                        else 
                                            {
                                                draw_background(user_joystick_a,anchor_x+91,anchor_y+17)
                                                draw_background_ext(user_joystick_b,anchor_x+91,anchor_y+34,1,1,0,c_white,0.5)
                                                draw_sprite_ext(spr_milla_moves_puppy_float,0,anchor_x+4,anchor_y+37,1,1,0,c_white,0.5)
                                            }
                                    }
                                else
                                    {
                                        //Only Render "Puppy Float" While Phantom Cubes Aren't In Use
                                        if (milla_phantom_mode = 0) and milla_special_attack = 0
                                            {
                                                if gravity_speed = 0
                                                    {
                                                        //Render "Puppy Float" At Half-Transparency
                                                        if user_move_list_control_type = 0
                                                            {
                                                                draw_sprite_ext(spr_keyboard_font,key_b,anchor_x+91,anchor_y+34,1,1,0,c_white,0.5)
                                                                draw_sprite_ext(spr_milla_moves_puppy_float,0,anchor_x+4,anchor_y+37,1,1,0,c_white,0.5)
                                                            }
                                                        else 
                                                            {
                                                                draw_background_ext(user_joystick_b,anchor_x+91,anchor_y+34,1,1,0,c_white,0.5)
                                                                draw_sprite_ext(spr_milla_moves_puppy_float,0,anchor_x+4,anchor_y+37,1,1,0,c_white,0.5)
                                                            }
                                                    }
                                                else
                                                    {
                                                        //Render "Puppy Float"
                                                        if user_move_list_control_type = 0
                                                            {
                                                                draw_sprite(spr_keyboard_font,key_b,anchor_x+91,anchor_y+34)
                                                                draw_sprite(spr_milla_moves_puppy_float,0,anchor_x+4,anchor_y+37)
                                                            }
                                                        else
                                                            {
                                                                draw_background(user_joystick_b,anchor_x+91,anchor_y+34)
                                                                draw_sprite(spr_milla_moves_puppy_float,0,anchor_x+4,anchor_y+37)
                                                            }
                                                    }
                                            }
                                        if milla_phantom_mode &lt;= 1
                                            {
                                                draw_sprite(spr_milla_moves_summon_cube,0,anchor_x+4,anchor_y+20)
                                                if user_move_list_control_type = 0 draw_sprite(spr_keyboard_font,key_a,anchor_x+91,anchor_y+17);
                                                else                               draw_background(user_joystick_a,anchor_x+91,anchor_y+17);
                                                if milla_phantom_mode = 1
                                                    {
                                                        draw_sprite_ext(spr_milla_moves_puppy_float,0,anchor_x+4,anchor_y+37,1,1,0,c_white,0.5)
                                                        if user_move_list_control_type = 0
                                                                draw_sprite_ext(spr_keyboard_font,key_b,anchor_x+91,anchor_y+34,1,1,0,c_white,0.5);
                                                        else 
                                                                draw_background_ext(user_joystick_b,anchor_x+91,anchor_y+34,1,1,0,c_white,0.5);
                                                    }
                                            }
                                        if milla_phantom_mode = 2 and milla_special_attack = 0
                                            {
                                                if milla_phantom_attack_sprite = spr_cube
                                                    {
                                                        draw_sprite(spr_milla_moves_throw_cube,0,anchor_x+4,anchor_y+20)
                                                        draw_sprite(spr_milla_moves_shield,0,anchor_x+4,anchor_y+37)
                                                        if user_move_list_control_type = 0
                                                            {
                                                                draw_sprite(spr_keyboard_font,key_a,anchor_x+91,anchor_y+17)
                                                                draw_sprite(spr_keyboard_font,key_c,anchor_x+91,anchor_y+34)
                                                            }
                                                        else
                                                            {
                                                                draw_background(user_joystick_a,anchor_x+91,anchor_y+17)
                                                                draw_background(user_joystick_c,anchor_x+91,anchor_y+34)
                                                            }
                                                    }
                                                else
                                                    {
                                                        draw_sprite(spr_milla_moves_throw_item,0,anchor_x+4,anchor_y+20)
                                                        draw_sprite_ext(spr_milla_moves_shield,0,anchor_x+4,anchor_y+37,1,1,0,c_white,0.5)
                                                        if user_move_list_control_type = 0
                                                            {
                                                                draw_sprite(spr_keyboard_font,key_a,anchor_x+91,anchor_y+17)
                                                                draw_sprite_ext(spr_keyboard_font,key_c,anchor_x+91,anchor_y+34,1,1,0,c_white,0.5)
                                                            }
                                                        else
                                                            {
                                                                draw_background(user_joystick_a,anchor_x+91,anchor_y+17)
                                                                draw_background_ext(user_joystick_c,anchor_x+91,anchor_y+34,1,1,0,c_white,0.5)
                                                            }
                                                        
                                                    }
                                            }
                                        if milla_phantom_mode = 3
                                            {
                                                draw_sprite_ext(spr_milla_moves_throw_cube,0,anchor_x+4,anchor_y+20,1,1,0,c_white,0.5)
                                                if user_move_list_control_type = 0 draw_sprite_ext(spr_keyboard_font,key_a,anchor_x+91,anchor_y+17,1,1,0,c_white,0.5)
                                                else                               draw_background_ext(user_joystick_a,anchor_x+91,anchor_y+17,1,1,0,c_white,0.5)
                                            }
                                        if milla_special_attack = 1
                                            {
                                                draw_sprite(spr_milla_moves_shield_burst,0,anchor_x+4,anchor_y+37)
                                                if user_move_list_control_type = 0 draw_sprite(spr_keyboard_font,key_c,anchor_x+91,anchor_y+34);
                                                else                               draw_background(user_joystick_c,anchor_x+91,anchor_y+34)
                                            }
                                        if milla_special_attack = 2
                                            {
                                                draw_sprite_ext(spr_milla_moves_throw_cube,0,anchor_x+4,anchor_y+20,1,1,0,c_white,0.5)
                                                draw_sprite(spr_milla_moves_super_burst,0,anchor_x+4,anchor_y+37)
                                                if user_move_list_control_type = 0
                                                    {
                                                        draw_sprite_ext(spr_keyboard_font,key_a,anchor_x+91,anchor_y+17,1,1,0,c_white,0.5)
                                                        draw_sprite(spr_keyboard_font,key_c,anchor_x+91,anchor_y+34)
                                                    }
                                                else
                                                    {
                                                        draw_background_ext(user_joystick_a,anchor_x+91,anchor_y+17,1,1,0,c_white,0.5)
                                                        draw_background(user_joystick_c,anchor_x+91,anchor_y+34)
                                                    }
                                            }
                                    }
                                break;
                            }
                        //Spade
                        case spr_spade:
                            {
                                anchor_x = 333;
                                var spade_hud_frame = 0;
                                var spade_hud_alpha = 1;
                                if (gravity_speed = 0 or above_water = 0)
                                    {
                                        spade_hud_frame = 1;
                                        spade_hud_alpha = 0.5;
                                    }
                                draw_sprite(spr_spade_move_list,spade_hud_frame,anchor_x,anchor_y);
                                //Keyboard
                                if user_move_list_control_type = 0
                                    {
                                        //Card Throw
                                        draw_sprite(spr_keyboard_font,key_a,anchor_x+29,anchor_y+28)
                                        draw_sprite(spr_ui_spade_input,0,anchor_x+4,anchor_y+28)
                                        //Flash Jump
                                        draw_set_alpha(spade_hud_alpha)
                                        draw_sprite(spr_keyboard_font,key_b,anchor_x+29,anchor_y+55)
                                        draw_sprite(spr_ui_spade_input,0,anchor_x+4,anchor_y+55)
                                        draw_set_alpha(1)
                                        //Dual Crash
                                        draw_sprite(spr_keyboard_font,key_c,anchor_x+4,anchor_y+82)
                                    }
                                else
                                    {
                                        //Card Throw
                                        draw_background(user_joystick_a,anchor_x+29,anchor_y+28)
                                        draw_sprite(spr_ui_spade_input,1,anchor_x+4,anchor_y+28)
                                        //Flash Jump
                                        draw_set_alpha(spade_hud_alpha)
                                        draw_background(user_joystick_b,anchor_x+29,anchor_y+55)
                                        draw_sprite(spr_ui_spade_input,1,anchor_x+4,anchor_y+55)
                                        draw_set_alpha(1)
                                        //Dual Crash
                                        draw_background(user_joystick_c,anchor_x+4,anchor_y+82)
                                    }
                                break;
                            }
                    }
            }
    }
if room != rm_editor
    {
        //Draw Mouse Busy Cursor
        if joy_mouse_button_busy_timer &gt; 0
            {
                draw_sprite_ext(spr_mouse_controller,0,device_mouse_x_to_gui(0),device_mouse_y_to_gui(0),1,1,0,c_white,0.5)
                draw_sprite_ext(spr_mouse_busy,1,device_mouse_x_to_gui(0)+28,device_mouse_y_to_gui(0),1,1,joy_mouse_button_busy_angle,c_white,1)
                draw_sprite(spr_mouse_busy,0,device_mouse_x_to_gui(0)+28,device_mouse_y_to_gui(0))
            }
        //Draw Mouse Cursor
        if joy_mouse_button_switch = 1
            {
                if joy_mouse_button_alpha = 1
                    {
                        //Body
                        draw_sprite(spr_mouse_cursor_region,0,0,0);
                        //Frames
                        draw_sprite(spr_mouse_cursor_region,1,0,-mouse_deadzone_up);
                        draw_sprite(spr_mouse_cursor_region,2,0,mouse_deadzone_down);
                        draw_sprite(spr_mouse_cursor_region,3,-mouse_deadzone_left,0);
                        draw_sprite(spr_mouse_cursor_region,4,mouse_deadzone_right,0);
                    }
                if pause = 1
                    {
                        //Set Font For The Menu
                        draw_sprite(spr_ui_disable_mouse,0,213,26)
                        if user_move_list_control_type = 0
                            draw_sprite(spr_keyboard_font,key_c,205,42);
                        else
                            draw_background(user_joystick_c,205,42);
                    }
                draw_sprite(spr_mouse_controller,joy_mouse_button_frame,device_mouse_x_to_gui(0),device_mouse_y_to_gui(0))
            }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Controller Overlay
//           Debug HID Interface           //
//=========================================//

if joy_overlay = 1 and pause = 0
    {
        var controller_offset = 385;
        var controller_scale = 0.5;
        if room = rm_editor
            {
                controller_offset = 120;
                controller_scale = 0.25;
            }

        //Draw The Controller's Graphic
        draw_sprite_ext(spr_controller_overlay,0,controller_offset,212,controller_scale,controller_scale,0,c_white,1)

        //  Draw Inputs  //
        //---------------//
        
        //Arrow Keys
        if joy_input[0,3] = 1   draw_sprite_ext(spr_controller_overlay,5,controller_offset,212,controller_scale,controller_scale,0,c_white,1); //Joystick Up
        if joy_input[0,0] = 1   draw_sprite_ext(spr_controller_overlay,6,controller_offset,212,controller_scale,controller_scale,0,c_white,1); //Joystick Right
        if joy_input[0,1] = 1   draw_sprite_ext(spr_controller_overlay,7,controller_offset,212,controller_scale,controller_scale,0,c_white,1); //Joystick Down
        if joy_input[0,2] = 1   draw_sprite_ext(spr_controller_overlay,8,controller_offset,212,controller_scale,controller_scale,0,c_white,1); //Joystick Left
        //Action Keys
        if joy_input[1,3] = 1   draw_sprite_ext(spr_controller_overlay,3,controller_offset,212,controller_scale,controller_scale,0,c_white,1); //Joystick A
        if joy_input[1,2] = 1   draw_sprite_ext(spr_controller_overlay,2,controller_offset,212,controller_scale,controller_scale,0,c_white,1); //Joystick B
        if joy_input[1,0] = 1   draw_sprite_ext(spr_controller_overlay,1,controller_offset,212,controller_scale,controller_scale,0,c_white,1); //Joystick C
        if joy_input[1,4] = 1   draw_sprite_ext(spr_controller_overlay,9,controller_offset,212,controller_scale,controller_scale,0,c_white,1); //Joystick D
        //Pause Keys
        if joy_input[2,0] = 1   draw_sprite_ext(spr_controller_overlay,4,controller_offset,212,controller_scale,controller_scale,0,c_white,1); //Joystick Start
    }

//=========Input Mode Notifications=========//

//Controller input mode notifications
if input_timer &gt; 0
    {
        input_timer -= 1
        draw_sprite(spr_input_mode,input_mode,internal_resolution[0]-16,internal_resolution[1]-2)
        draw_set_font(text_font)
        draw_text(internal_resolution[0]-13,internal_resolution[1]-14,string(joy_modern_id))
    }

//Music mute/unmute notifications
if music_notification &gt; 0
    {
        music_notification-=1
        draw_set_halign(fa_right)
        draw_set_font(text_font)
        draw_background(ui_sound_volume,internal_resolution[0]-52,internal_resolution[1]-19)
        draw_text(internal_resolution[0]-2,internal_resolution[1]-18,string(music_volume_percent)+"%")
        draw_set_halign(fa_left)
    }

//Controller input mode notifications
if vblank_notification &gt; 0
    {
        vblank_notification -= 1
        draw_set_font(text_font)
        var vblank_string = "VSYNC Disabled"
        switch(vblank)
            {
                case 0: {vblank_string = "V-SYNC Disabled" break;}
                case 1: {vblank_string = "V-SYNC Enabled" break;}
            }
        draw_set_halign(fa_right)
        draw_text(internal_res_width-2,internal_res_height-18,vblank_string)
        draw_set_halign(fa_left)
    }
///Draw Saving Prompt
if saving_prompt &gt; 0
    {
        draw_set_font(o.menu_font)
        draw_set_halign(fa_right)
        draw_text(424,222,lang_gui[user_language_mode,22])
        draw_set_halign(fa_left)
        saving_prompt -= 1
    }

if room != rm_editor
    {
        if general_notifications[2] &gt; 0 or general_notifications[1] &gt; 0 or general_notifications[0] &gt; 0
            draw_background(ui_dialogue_box,0,179);
        
        if general_notifications[0] &gt; 0
            {
                general_notifications[0] -= 1
                draw_set_font(text_font_academy)
                draw_text(2,222,general_notifications_string[0])
                if general_notifications[0] = 0 general_notifications_string[0] = "";
            }
        
        if general_notifications[1] &gt; 0
            {
                general_notifications[1] -= 1
                draw_set_font(text_font_academy)
                draw_text(2,202,general_notifications_string[1])
                if general_notifications[1] = 0 general_notifications_string[1] = "";
            }
        
        if general_notifications[2] &gt; 0
            {
                general_notifications[2] -= 1
                draw_set_font(text_font_academy)
                draw_text(2,182,general_notifications_string[2])
                if general_notifications[2] = 0 general_notifications_string[2] = "";
            }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Transitions

//============Fade To Or From Black============//

if transition_alpha &gt; 0
    {
        draw_set_color(c_black)
        draw_set_alpha(transition_alpha)
        draw_rectangle(0,0,internal_res_width,internal_res_height,false)
        draw_set_color(c_white)
        draw_set_alpha(1)
    }

//===========Skewed Slice Transition===========//

if transition_active = 1 draw_sprite(spr_transition_skewed,0,transition_position,0);

//Hold the transition over the screen for a few frames longer, after entering a new room
if transition_persistence &gt; 0 or now_loading &gt;= 1 or transition_loading = 1
    {
        if now_loading = 0 draw_sprite(spr_transition_skewed,0,554,0);
        draw_set_font(menu_font)
        draw_set_halign(fa_right)
        draw_text(424,222,"Loading     .     .     .")
        draw_set_halign(fa_left)
    }
if transition_game_over = 1
    {
        draw_set_font(stage_title_font)
        draw_set_halign(fa_center)
        draw_text_transformed(transition_game_over_x,(internal_res_height/2)-22,"Try Again?",1,1,0)
        draw_set_font(menu_font)
        if try_again_menu_selection = 0
            {
                draw_text(transition_game_over_x,(internal_res_height/2)+24,"&gt;Yes");
                draw_text(transition_game_over_x,(internal_res_height/2)+48,"          No");
            }
        if try_again_menu_selection = 1
            {
                draw_text(transition_game_over_x,(internal_res_height/2)+24,"          Yes");
                draw_text(transition_game_over_x,(internal_res_height/2)+48,"&gt;No");
            }
        draw_set_halign(fa_left)

        //Game Over Menu Controls (Keyboard)
        if keyboard_check(key_up)
            try_again_menu_selection = 0;
        if keyboard_check(key_down)
            try_again_menu_selection = 1;
        if keyboard_check(key_b) or keyboard_check(key_start)
            try_again_menu_press += 1;

        //Game Over Menu Controls (Controller)
        if gamepad_is_connected(joy_modern_id)
            {
                if gamepad_button_check(joy_modern_id,joy_up_mod)
                    try_again_menu_selection = 0;
                if gamepad_button_check(joy_modern_id,joy_down_mod)
                    try_again_menu_selection = 1;
                if gamepad_button_check(joy_modern_id,joy_b_mod)
                or gamepad_button_check(joy_modern_id,joy_start_mod)
                    try_again_menu_press += 1;
            }

        if joy_mouse_button_switch = 1
            {
                if device_mouse_x_to_gui(0) &gt;= 175 and device_mouse_x_to_gui(0) &lt;= 238
                    {
                        if device_mouse_y_to_gui(0) &gt;= 139 and device_mouse_y_to_gui(0) &lt;= 162
                            {
                                try_again_menu_selection = 0
                            }
                        if device_mouse_y_to_gui(0) &gt; 162 and device_mouse_y_to_gui(0) &lt;= 186
                            {
                                try_again_menu_selection = 1
                            }
                    }
                if (mouse_check_button(mb_left))
                    {
                        if  device_mouse_x_to_gui(0) &gt;= 175 and device_mouse_x_to_gui(0) &lt;= 238
                        and device_mouse_y_to_gui(0) &gt;= 139 and device_mouse_y_to_gui(0) &lt;= 186
                            try_again_menu_press += 1;
                    }
                draw_sprite(spr_mouse_controller,joy_mouse_button_frame,device_mouse_x_to_gui(0),device_mouse_y_to_gui(0))
            }

        if try_again_menu_press = 1
            {
                scr_set_game_over();
                transition_loading = 1
                if try_again_menu_selection = 1
                    {
                        joy_input[2,6] = 30
                        if room = rm_player
                            {
                                lives = 5
                                targets = 1
                                targets_ready = 0
                                use_maps_load = 0
                                room_goto(rm_main_menu)
                            }
                        if room = rm_campaign
                            {
                                var get_yes = scr_get_restart_map_exceptions_list();
                                var room_id = rm_title_screen;
                                if get_yes = 0
                                    room_id = rm_title_screen;
                                if get_yes = 1
                                    {
                                        if campaign_menu_mode = 3
                                            room_id = rm_sm_character_select
                                        else
                                            {
                                                use_cuts_select = campaign_stage_exit_to
                                                room_id = rm_campaign
                                            }
                                    }
                                if campaign_stage_exit_to = ""
                                    {
                                        room_id = rm_title_screen
                                    }
                                room_goto(room_id)
                            }
                    }
                if try_again_menu_selection = 0
                    {
                        //Reload map if we are in player mode
                        use_maps_load = 1;
                        lives = 5
                        targets = 1
                        targets_ready = 0
                        joy_input[2,6] = 30
                        room_restart();
                    }
            }
    }

//Stage Title Transition
if targets_ready = 4
    {
        draw_set_color(c_black)
        draw_set_alpha(stage_transition_alpha)
        draw_rectangle(0,0,internal_res_width,internal_res_height,false)
        draw_set_color(c_white)
        draw_set_alpha(1)
        var stage_transition_title_text = use_stage_name;
        var stage_transition_subtitle_text = "Defeat     The     Boss!";
        if room = rm_campaign
            {
                stage_transition_title_text = campaign_stage_title_name;
                stage_transition_subtitle_text = campaign_stage_description;
            }
        draw_set_font(stage_title_font)
        draw_set_halign(fa_center)
        draw_text(stage_transition_title_x+stage_transition_title_x_offset,stage_transition_title_y,stage_transition_title_text)
        draw_set_font(menu_font)
        //Custom description text
        if room = rm_player
            stage_transition_subtitle_text = string_replace(use_display_description," ","     ");
        draw_text(stage_transition_subtitle_x+stage_transition_subtitle_x_offset,stage_transition_subtitle_y,stage_transition_subtitle_text)
        draw_set_halign(fa_left)
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Screensaver
if joy_input_screen_saver_alpha!= 0 and room!=rm_editor
    draw_sprite_ext(spr_transition,0,0,0,426,240,0,c_white,joy_input_screen_saver_alpha);

if key_reset_timer &gt; 0 and room != rm_editor
    {
        draw_set_font(menu_font)
        draw_set_color(c_white)
        draw_set_halign(fa_right)
        draw_set_alpha(key_reset_alpha)
        draw_text(424,224,"Resetting.     .     .")
        draw_set_alpha(1)
        draw_set_halign(fa_left)
    }
//Draw Letterbox Offscreen Above The Screen, To Hide Sliding HUD Elements Offscreen
//While The Window Is Maximized At A Non-16:9 Aspect Ratio Resolution
draw_sprite_stretched(spr_transition,0,0,-64,426,64)
draw_sprite_stretched(spr_transition,0,0,-64,0,240)
draw_sprite_stretched(spr_transition,0,0,427,491,240)
draw_sprite_stretched(spr_transition,0,-64,0,64,240)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Moving Platforms

//Draw Rain Effects if set
if use_weather_fade_effect != 0
    {
        if use_weather_conditions != 5
            draw_sprite_stretched_ext(spr_water,0,view_xview[view_port],view_yview[view_port],view_wview[view_port],view_hview[view_port],c_white,use_weather_fade_effect);
        draw_sprite_stretched_ext(spr_thunder,0,view_xview[view_port],view_yview[view_port],view_wview[view_port],view_hview[view_port],c_white,use_thunder_fade_effect);
    }

//           Draw Player Sprites           //
//=========================================//

//Make sure we are not using an alternative play mode first
if user_cursor_mode = 0
    {
        //   Modify Sprite Offset Before Drawing   //
        //-----------------------------------------//
        
        //If we are not on a moving platform, draw as normal
        gravity_fofset = py

        //Check for moving hangbars
        var hangbar_tile_id = -1;
        if ladder_moving = 1 and xcompass = 0 and gravity_speed &gt;= 0
            {
                hangbar_tile_id = tile_layer_find(surface_slopes,px,py-36)

                //Exit Condition
                if (joy_input[1,2] = 1 and joy_input[0,1] = 0 and jump_lock = 1)
                    {
                        //Give us a boost forward, if direction keys were pressed
                        if joy_input[0,0] = 1 and joy_input[0,2] = 0 hsp=2;        //Right
                        if joy_input[0,0] = 0 and joy_input[0,2] = 1 hsp=-2;       //Left
                        gravity_ladder = 0
                        gravity_hang = 0
                        if gravity_speed &gt;= 0
                            gravity_speed = -gravity_jump/2;
                        ladder_moving = 0

                        hangbar_tile_id = -1

                        //Jump animation
                        anim_current=anim_jump
                    }
                //Cancel hangbar clipping
                if (joy_input[0,3] = 0 and joy_input[0,1] = 1 and joy_input[1,2] = 1)
                or (death[0] = 1)
                    {
                        gravity_ladder = 0
                        gravity_hang = 0
                        ladder_moving = 0

                        hangbar_tile_id = -1

                        //Falling animation
                        anim_current=anim_falling
                    }

                if tile_exists(hangbar_tile_id)
                    {
                        var hangbar_tile_bg = tile_get_background(hangbar_tile_id);
                        if hangbar_tile_bg = spr_hangbar_ignore
                            {
                                gravity_x = tile_get_x(hangbar_tile_id)+(tile_get_width(hangbar_tile_id)/2)
                                gravity_y = tile_get_y(hangbar_tile_id)+tile_get_height(hangbar_tile_id)+32
                                gravity_fofset = gravity_y
                                gravity_ladder = 2
                            }
                    }
                else
                    gravity_fofset = py;
            }
        else
            gravity_fofset = py;

        //Update X/Y Coordintes Based on Hangbar Position
        if gravity_ladder = 2
            {
                //Clip to the center of the hangbar
                px = gravity_x
                py = gravity_y
                //Keep movement speeds empty
                hsp = 0;
                if gravity_speed &gt; 0 gravity_speed = 0;
                spring_timer = -1;

                //"Rest" mechanic
                if (stamina &lt; 96) stamina += 0.4;
                //Hanging Animation
                anim_current = anim_hanging_idle;
                //Allow changing player sprite directions despite this
                if joy_input[0,0] = 1 and joy_input[0,2] = 0 xdir=1;        //Right
                if joy_input[0,0] = 0 and joy_input[0,2] = 1 xdir=-1;       //Left
                //Keep attack states empty
                attack[0] = 0; attack[1] = 0; attack[2] = 0; attack[3] = 0;
                bike_jump_roll_speed = 0
                bike_jump_roll = 0
                //Allow another jump button press to satisfy the following exit condition
                if (gravity_hang = 1 and joy_input[1,2] = 0) gravity_hang = 2;
                //Exit Condition
                if (joy_input[1,2] = 1 and joy_input[0,1] = 0 and gravity_hang = 2)
                    {
                        //Give us a boost forward, if direction keys were pressed
                        if joy_input[0,0] = 1 and joy_input[0,2] = 0 hsp=2;        //Right
                        if joy_input[0,0] = 0 and joy_input[0,2] = 1 hsp=-2;       //Left
                        gravity_ladder = 0; gravity_hang = 0; gravity_speed = -gravity_jump/2;
                        ladder_moving = 0
                        //Jump animation
                        anim_current=anim_jump
                    }
                //Cancel hangbar clipping
                if (joy_input[0,3] = 0 and joy_input[0,1] = 1 and joy_input[1,2] = 1 and gravity_hang=2)
                or death[0] = 1
                    {
                        gravity_ladder = 0
                        gravity_hang = 0
                        ladder_moving = 0
                        //Falling animation
                        anim_current=anim_falling
                    }
                if (ground = 1 or wall_collision_left = 1 or wall_collision_right = 1) and death[0] = 0
                    {
                        gravity_ladder = 0
                        gravity_hang = 0
                        ladder_moving = 0
                        //Falling animation
                        anim_current=anim_falling
                        if room = rm_editor
                            {
                                if not audio_is_playing(character_parry)
                                    scr_set_message("Invalid hangbar configuration");
                            }
                    }
            }
            
        //If we are on a moving platform, modify the player's X/Y offsets relative to
        //the platform's. (Because of the priority of execution, player drawing will
        //lag behind the platform otherwise.)
        if (tile_exists(tile_ramp_id) and gravity_fof_validation &gt; 0
        and gravity_slope = 1 and gravity_ladder = 0 and fof_disable = 0 and xcompass = 0)
            {
                //If there is a relative X position to follow, override the player's X
                //position relative to the platform's
                px = tile_get_x(tile_ramp_id) + tile_ramp_pos[0]

                //Override the player's Y position relative to the moving platform's
                py = floor(tile_get_y(tile_ramp_id))+orig_clip[tile_ramp_id_debug,tile_ramp_pos[0]]

                if gravity_fof_validation = 2
                    py = tile_get_y(tile_ramp_id) + 8;

                gravity_fofset = py

                //Update Rotation Axis For Shield Sprites
                shield_rotate_x = px + lengthdir_x(24,angle_a+90)
                shield_rotate_y = py + lengthdir_y(24,angle_a+90)

                //Update the positions Carol's and Milla's tails, so they don't lag behind
                switch(skin)
                    {
                        //Update Lilac's hair sprite positions
                        case spr_lilac:
                            {
                                //Set rotation axis for cyclone sprites
                                lilac_cyclone_x = px + lengthdir_x(32,angle_a+90)
                                lilac_cyclone_y = py + lengthdir_y(32,angle_a+90)
                                break;
                            }
                        //Update Carol's tail sprite positions
                        case spr_carol:
                            {
                                //Set rotation axis for tail sprites
                                carol_tail_x_anchor = px + lengthdir_x(carol_tail_offset_y,angle_a+90)
                                carol_tail_y_anchor = py + lengthdir_y(carol_tail_offset_y,angle_a+90)
                                //Set rotation axis for tail sprites
                                carol_tail_x = carol_tail_x_anchor + lengthdir_x(carol_tail_offset_x*xdir,angle_a)
                                carol_tail_y = carol_tail_y_anchor + lengthdir_y(carol_tail_offset_x*xdir,angle_a)
                                break;
                            }
                        //Update Milla's tail sprite and item positions
                        case spr_milla:
                            {
                                //Set rotation axis for tail sprites
                                milla_tail_x = px + lengthdir_x(milla_tail_offset,angle_a+90)
                                milla_tail_y = py + lengthdir_y(milla_tail_offset,angle_a+90)
                                //Distance from Origin Point (Player's X/Y Coordinates)
                                milla_phantom_length_x = px+lengthdir_x(milla_phantom_cube_offset-milla_phantom_cube_walkset,angle_a+90)
                                milla_phantom_length_y = py+lengthdir_y(milla_phantom_cube_offset-milla_phantom_cube_walkset,angle_a+90)
                                //If we are holding an item instead of a cube, rotate it around the player's head
                                milla_item_length_x = milla_phantom_length_x+lengthdir_x(milla_phantom_cube_offset_x,angle_a)
                                milla_item_length_y = milla_phantom_length_y+lengthdir_y(milla_phantom_cube_offset_x,angle_a)
                                break;
                            }
                    }

            }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Lilac Particles

//Yes, this warranted its own code block. :^P
if skin=spr_lilac and user_cursor_mode = 0
    {
        //=========Character Sprites=========//

        //Draw Lilac's Basic Attack
        if attack[0]!=0 and death[0] = 0 draw_sprite_ext(spr_action,action_frame,action_offset_x,action_offset_y,xdir,1,angle_a,c_white,1);
        script_execute(pal_swap_script,my_pal_sprite,current_pal,false)
        switch(anim_current)
            {
                //Draw Lilac's Cyclone Sprites
                case anim_lilac_cyclone: {draw_sprite_ext(spr_lilac_tail_3,lilac_cyclone_sprite_frame,lilac_cyclone_x,lilac_cyclone_y,1,1,angle_a,c_white,1); break;}
                //If we are rolling, draw her tendrils
                case anim_lilac_dragon_boost_r: {draw_sprite_ext(spr_lilac_tail_1,lilac_tail_frame,px,gravity_fofset,xdir,1,angle_a,c_white,1); break;}
                //If we are on a hangbar, draw her tendrils
                case anim_hanging_idle:
                    {
                        draw_sprite_ext(spr_lilac_tail_0,lilac_tail_frame_1,px-4*xdir,gravity_fofset-14,xdir,1,angle_a,c_white,1)
                        //Iterate Tail Animations
                        if pause = 0 lilac_tail_frame_1 += 0.12*planet_delta;
                        //Reset Tail Animations After They Have Completed
                        if lilac_tail_frame_1 &gt; 14.8 lilac_tail_frame_1 = 3;
                        break;
                    }
            }

        var skin_name = skin;
        var skin_boost = spr_lilac_dragon_boost;
        if alt_skin = 1 skin_name = spr_lilac_old;
        if alt_skin = 2
            {
                skin_name = spr_lilac_new
                skin_boost = spr_lilac_dragon_boost_new
            }

        //Draw Player Sprite
        if lilac_boost_sprite = 0
            draw_sprite_ext(skin_name,frame,px,gravity_fofset,xdir,1,angle_a,c_white,1);
        else
            {
                if ground = 0
                    draw_sprite_ext(skin_boost,lilac_boost_frame,px,gravity_fofset-16,1,lilac_boost_dir,lilac_dragon_boost_angle,c_white,1);
                else
                   draw_sprite_ext(skin_name,frame,px,gravity_fofset,xdir,1,angle_a,c_white,1);
            }
        //Draw glow effect
        if speed_boosted_timer != 0
            {
                draw_set_blend_mode(bm_add)
                if lilac_boost_sprite = 0
                    draw_sprite_ext(skin_name,frame,px,gravity_fofset,xdir,1,angle_a,c_white,speed_boosted_alpha);
                else
                    draw_sprite_ext(spr_lilac_dragon_boost,lilac_boost_frame,px,gravity_fofset-16,lilac_boost_dir,1,angle_a,c_white,speed_boosted_alpha);
                draw_set_blend_mode(bm_normal)
            }
        shader_reset();
        //Draw Lilac's Uppercut Slash Sprites
        if anim_current = anim_lilac_uppercut and frame &gt;= 149 and frame &lt; 152
            {
                if pause = 0 lilac_uppercut_anim_frame += 0.25;
                if lilac_uppercut_anim_frame &lt; 3.8
                    draw_sprite_ext(spr_attack_2,lilac_uppercut_anim_frame,lilac_uppercut_x,lilac_uppercut_y,xdir,1,angle_a,c_white,1);
            }
        //Draw Lilac's Particle Effects
        if particle_frame_1&gt;=0 and particle_frame_1&lt;=7.8 draw_sprite(spr_sparkle,particle_frame_1,particle_x_1,particle_y_1);
        if particle_frame_2&gt;=0 and particle_frame_2&lt;=7.8 draw_sprite(spr_sparkle,particle_frame_2,particle_x_2,particle_y_2);
        if particle_frame_3&gt;=0 and particle_frame_3&lt;=7.8 draw_sprite(spr_sparkle,particle_frame_3,particle_x_3,particle_y_3);
        if particle_frame_4&gt;=0 and particle_frame_4&lt;=7.8 draw_sprite(spr_sparkle,particle_frame_4,particle_x_4,particle_y_4);
        if particle_frame_5&gt;=0 and particle_frame_5&lt;=7.8 draw_sprite(spr_sparkle,particle_frame_5,particle_x_5,particle_y_5);
        //If we are dragon boosting, draw particles
        if lilac_particle_frame[10]!=-128
            {
                var lilac_count = 0;
                while(lilac_count &lt; 10)
                    {
                        if lilac_particle_frame[lilac_count] &gt;=0 and lilac_particle_frame[lilac_count] &lt;=7.8
                            draw_sprite(spr_sparkle,lilac_particle_frame[lilac_count],lilac_particle_x[lilac_count],lilac_particle_y[lilac_count]);
                        lilac_count += 1
                    }
            }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Carol Particles

if skin=spr_carol and user_cursor_mode = 0
    {
        //Draw Carol's Tail
        script_execute(pal_swap_script,my_pal_sprite,current_pal,false)
        if (bike = 0 and death[0] = 0) draw_sprite_ext(carol_tail_sprite,carol_tail_sprite_frame,carol_tail_x,carol_tail_y,carol_tail_dir,1,angle_a,c_white,1);

        //Draw Carol's Attack Sprites
        if (anim_current = anim_carol_bike_roll and alt_skin = 0) draw_sprite_ext(spr_attack_4,bike_attack_sprite_frame,px-20*xdir,py-42,xdir,1,0,c_white,1);
        var skin_name = skin;
        if alt_skin = 1 skin_name = spr_carol_old;
        if alt_skin = 2 skin_name = spr_carol_new;
        //Draw Player Sprite
        draw_sprite_ext(skin_name,frame,px,gravity_fofset,xdir,1,angle_a,c_white,1);
        //Draw glow effect
        if speed_boosted_timer != 0
            {
                draw_set_blend_mode(bm_add)
                draw_sprite_ext(skin_name,frame,px,gravity_fofset,xdir,1,angle_a,c_yellow,speed_boosted_alpha);
                draw_set_blend_mode(bm_normal)
            }
        shader_reset();
        //Draw Attack Particle Sprites
        switch(anim_current)
            {
                case anim_carol_attack_1: {if carol_attack_frame &lt; carol_attack_frame_repeat+0.9 {draw_sprite_ext(spr_attack_2,carol_attack_frame,action_offset_x,action_offset_y,xdir,1,angle_a,c_white,1);} break;}
                case anim_carol_attack_2: {if carol_attack_frame &lt; carol_attack_frame_repeat+0.9 {draw_sprite_ext(spr_attack_3,carol_attack_frame,action_offset_x,action_offset_y,xdir,1,angle_a,c_white,1);} break;}
                case anim_carol_attack_3: {if carol_attack_frame &lt; carol_attack_frame_repeat+0.9 {draw_sprite_ext(spr_attack_2,carol_attack_frame,action_offset_x,action_offset_y,xdir,-1,angle_a,c_white,1);} break;}
            }
        //Draw Attack Particle Sprites
        if anim_current=anim_carol_wildclaws
            {
                switch(carol_wildclaws_stage)
                    {
                        case 0: {draw_sprite_ext(spr_attack_2,carol_attack_frame,action_offset_x,action_offset_y,xdir,1,angle_a,c_white,1); break;}
                        case 1: {draw_sprite_ext(spr_attack_3,carol_attack_frame,action_offset_x,action_offset_y,xdir,1,angle_a,c_white,1); break;}
                        case 2: {draw_sprite_ext(spr_carol_wildkicks,carol_attack_frame,action_offset_x,action_offset_y,xdir,1,angle_a,c_white,1); break;}
                        case 3: {draw_sprite_ext(spr_attack_2,carol_attack_frame,action_offset_x,action_offset_y,xdir,1,angle_a,c_white,1); break;}
                    }
            }
        //Draw Golden Claw Particle Sprites
        if (anim_current=anim_carol_goldenclaws or anim_current=anim_carol_attack_super_wild_claw) and carol_attack_frame &lt; carol_attack_frame_repeat+0.9
            {
                var claw_offset_y = 0;
                if anim_current=anim_carol_attack_super_wild_claw
                    claw_offset_y = -8;
                draw_sprite_ext(spr_carol_wildclaws,carol_attack_frame,action_offset_x,action_offset_y+claw_offset_y,xdir,1,angle_a,c_white,1);
            }
        //Draw Bike Tile If We Have Dismounted From The Bike
        script_execute(pal_swap_script,my_pal_sprite,current_pal,false)
        if bike_x != -1
            {
                if alt_skin = 0
                    draw_sprite_ext(spr_carols_bike,0,bike_x,bike_y,bike_dir,1,bike_angle,c_white,1);
                if alt_skin = 2
                    draw_sprite_ext(spr_carol_new,75,bike_x,bike_y,bike_dir,1,bike_angle,c_white,1);
            }
        shader_reset();
        //Draw Bike Sparkle Particles
        if (carol_particle_frame[0] &gt;=0 and carol_particle_frame[0] &lt;=12.8) draw_sprite_ext(spr_carol_bike_particles,carol_particle_frame[0],carol_particle_x[0],carol_particle_y[0],1,1,carol_particle_angle,c_white,1);
        if (carol_particle_frame[1] &gt;=0 and carol_particle_frame[1] &lt;=7.8) draw_sprite(spr_sparkle,carol_particle_frame[1],carol_particle_x[1],carol_particle_y[1]);
        if (carol_particle_frame[2] &gt;=0 and carol_particle_frame[2] &lt;=7.8) draw_sprite(spr_sparkle,carol_particle_frame[2],carol_particle_x[2],carol_particle_y[2]);
        if (carol_particle_frame[3] &gt;=0 and carol_particle_frame[3] &lt;=7.8) draw_sprite(spr_sparkle,carol_particle_frame[3],carol_particle_x[3],carol_particle_y[3]);
        if (carol_particle_frame[4] &gt;=0 and carol_particle_frame[4] &lt;=7.8) draw_sprite(spr_sparkle,carol_particle_frame[4],carol_particle_x[4],carol_particle_y[4]);
        if performance_profile = 1
            {
                if (carol_particle_frame[5] &gt;=0 and carol_particle_frame[5] &lt;=7.8) draw_sprite(spr_sparkle,carol_particle_frame[5],carol_particle_x[5],carol_particle_y[5]);
                if (carol_particle_frame[6] &gt;=0 and carol_particle_frame[6] &lt;=7.8) draw_sprite(spr_sparkle,carol_particle_frame[6],carol_particle_x[6],carol_particle_y[6]);
                if (carol_particle_frame[7] &gt;=0 and carol_particle_frame[7] &lt;=7.8) draw_sprite(spr_sparkle,carol_particle_frame[7],carol_particle_x[7],carol_particle_y[7]);
                if (carol_particle_frame[8] &gt;=0 and carol_particle_frame[8] &lt;=7.8) draw_sprite(spr_sparkle,carol_particle_frame[8],carol_particle_x[8],carol_particle_y[8]);
                if (carol_particle_frame[9] &gt;=0 and carol_particle_frame[9] &lt;=7.8) draw_sprite(spr_sparkle,carol_particle_frame[9],carol_particle_x[9],carol_particle_y[9]);
            }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Milla Particles

if skin=spr_milla and user_cursor_mode = 0
    {
        var skin_name = skin;
        if alt_skin = 1
            skin_name = spr_milla_new;
        else
            script_execute(pal_swap_script,my_pal_sprite,current_pal,false);
        //Draw Milla's Tail
        if (milla_tail_visible = 1 and death[0] = 0) draw_sprite_ext(spr_millas_tail,milla_tail_sprite_frame,milla_tail_x,milla_tail_y,milla_tail_dir,1,angle_a,c_white,1);
        //Draw Item Behind The Player (If we are holding an item)
        if milla_special_attack != 2
            {
                switch(milla_phantom_mode)
                    {
                        //Held cube
                        case 2:
                            {
                                if milla_phantom_cube_confirm != 0
                                    {
                                        draw_sprite_ext(milla_phantom_attack_sprite,milla_phantom_attack_frame,milla_phantom_length_x,milla_phantom_length_y+milla_phantom_cube_offset_y,1,1,angle_a,c_white,1);
                                        //Draw Gem Flower's Particle Sprite
                                        if (milla_phantom_attack_sprite = spr_flower_0_copy or milla_phantom_attack_sprite = spr_crystal_gold_flower)
                                        draw_sprite(spr_sparkle,milla_gem_flower_particle,milla_gem_flower_x+milla_gem_flower_x2-16,milla_gem_flower_y+milla_gem_flower_z);
                                    }
                                break;
                            }
                        //Thrown cube
                        case 3:
                            {
                                if milla_phantom_cube_confirm != 0 draw_sprite_ext(milla_phantom_attack_sprite,milla_phantom_attack_frame,milla_phantom_cube_x,milla_phantom_cube_y+milla_phantom_cube_offset_y,1,1,milla_phantom_cube_angle,c_white,1);
                                break;
                            }
                    }
            }
        //Draw Player Sprite
        draw_sprite_ext(skin_name,frame,px,gravity_fofset,xdir,1,angle_a,c_white,1);
        //Draw glow effect
        if speed_boosted_timer != 0
            {
                draw_set_blend_mode(bm_add)
                draw_sprite_ext(skin,frame,px,gravity_fofset,xdir,1,angle_a,c_yellow,speed_boosted_alpha);
                draw_set_blend_mode(bm_normal)
            }
        shader_reset();
        //Draw Shield Burst Attack
        switch(milla_special_attack)
            {
                case 1:
                    {
                        script_execute(pal_swap_script,my_pal_sprite,current_pal,false)
                        var milla_shield_skin = spr_shield_small;
                        if alt_skin = 1
                            milla_shield_skin = spr_shield_small_new;
                        if milla_phantom_attack_sprite = spr_cube_alt
                            milla_shield_skin = spr_shield_alt;
                        draw_sprite_ext(milla_shield_skin,milla_special_shield_frame,milla_special_length_x2,milla_special_length_y2,milla_xdir,1,angle_a+milla_special_shield_angle,c_white,1);
                        shader_reset();
                        break;
                    }
                case 2:
                    {
                        script_execute(pal_swap_script,my_pal_sprite,current_pal,false)
                        var milla_shield_skin = spr_shield_large;
                        if alt_skin = 1
                            milla_shield_skin = spr_shield_large_new;
                        draw_sprite_ext(milla_shield_skin,milla_special_shield_frame,milla_special_length_x2,milla_special_length_y2,milla_xdir,1,angle_a+milla_special_shield_angle,c_white,1);
                        shader_reset();
                        break;
                    }
                case 3:
                    {
                        script_execute(pal_swap_script,my_pal_sprite,current_pal,false)
                        var milla_beam_skin   = spr_shield_burst;
                        if alt_skin = 1
                            milla_beam_skin = spr_shield_burst_new;
                        if milla_phantom_attack_sprite = spr_cube_alt
                            milla_beam_skin   = spr_shield_beam_alt;
                        draw_sprite_ext(milla_beam_skin,milla_special_shield_frame,milla_special_length_x2,milla_special_length_y2,milla_xdir,1,angle_a+milla_special_shield_angle,c_white,1);
                        shader_reset();
                        break;
                    }
                case 4:
                    {
                        script_execute(pal_swap_script,my_pal_sprite,current_pal,false)
                        var milla_shield_skin = spr_shield_beam;
                        if alt_skin = 1
                            milla_shield_skin = spr_shield_beam_new;
                        draw_sprite_ext(milla_shield_skin,milla_special_shield_frame,milla_special_length_x2,milla_special_length_y2,milla_xdir,1,angle_a+milla_special_shield_angle,c_white,1);
                        shader_reset();
                        break;
                    }
            }
        //Draw Phantom Cube (If we are not holding a super shield)
        if milla_special_attack != 2
            {
                switch(milla_phantom_mode)
                    {
                        //Spawning cube
                        case 1:
                            {
                                script_execute(pal_swap_script,my_pal_sprite,current_pal,false)
                                var milla_cube_spawning_effect = spr_effect;
                                if alt_skin = 1
                                    milla_cube_spawning_effect = spr_effect_new;
                                if milla_phantom_attack_sprite = spr_cube_alt
                                    milla_cube_spawning_effect = spr_effect_alt;
                                draw_sprite_ext(milla_cube_spawning_effect,milla_phantom_attack_frame,milla_phantom_length_x,milla_phantom_length_y,1,1,angle_a,c_white,1);
                                shader_reset();
                                break;
                            }
                        //Held cube
                        case 2:
                            {
                                if milla_phantom_cube_confirm = 0
                                    {
                                        script_execute(pal_swap_script,my_pal_sprite,current_pal,false)
                                        var milla_shield_skin = milla_phantom_attack_sprite;
                                        if alt_skin = 1 and milla_phantom_attack_sprite = spr_cube
                                            milla_shield_skin = spr_cube_new;
                                        draw_sprite_ext(milla_shield_skin,milla_phantom_attack_frame,milla_phantom_length_x,milla_phantom_length_y+milla_phantom_cube_offset_y,1,1,angle_a,c_white,1);
                                        shader_reset();
                                    }
                                break;
                            }
                        //Thrown cube
                        case 3:
                            {
                                if milla_phantom_cube_confirm = 0
                                    {
                                        script_execute(pal_swap_script,my_pal_sprite,current_pal,false)
                                        draw_sprite_ext(milla_phantom_attack_sprite,milla_phantom_attack_frame,milla_phantom_cube_x,milla_phantom_cube_y+milla_phantom_cube_offset_y,1,1,milla_phantom_cube_angle,c_white,1);
                                        shader_reset();
                                    }
                                break;
                            }
                    }
            }
        //Draw Bomb Cube's Sprite
        if milla_phantom_attack_sprite=spr_cube_alt and milla_phantom_mode = 2
            draw_sprite_ext(spr_cube_alt_3x,0,milla_phantom_length_x,milla_phantom_length_y+milla_phantom_cube_offset_y,milla_attack_bomb_cube_scale/3,milla_attack_bomb_cube_scale/3,angle_a,c_white,1);
        //Draw Explosion Particles
        if milla_particle_frame &gt; -1 draw_sprite(spr_explosion_1,milla_particle_frame,milla_phantom_cube_x,milla_phantom_cube_y);
        //Draw Phantom Cube Particles
        if milla_particle_frame_1&gt;=0 and milla_particle_frame_1&lt;=13.8 draw_sprite(spr_cube_pop_large,milla_particle_frame_1,milla_particle_x_1,milla_particle_y_1);
        if milla_particle_frame_2&gt;=0 and milla_particle_frame_2&lt;=9.8 draw_sprite(spr_cube_pop_small,milla_particle_frame_2,milla_particle_x_2,milla_particle_y_2);
        if milla_particle_frame_3&gt;=0 and milla_particle_frame_3&lt;=9.8 draw_sprite(spr_cube_pop_small,milla_particle_frame_3,milla_particle_x_3,milla_particle_y_3);
        if milla_particle_frame_4&gt;=0 and milla_particle_frame_4&lt;=9.8 draw_sprite(spr_cube_pop_small,milla_particle_frame_4,milla_particle_x_4,milla_particle_y_4);
        if milla_particle_frame_5&gt;=0 and milla_particle_frame_5&lt;=9.8 draw_sprite(spr_cube_pop_small,milla_particle_frame_5,milla_particle_x_5,milla_particle_y_5);
        if milla_particle_frame_6&gt;=0.5 and milla_particle_frame_6&lt;=5.8 draw_sprite_ext(spr_shield_burst,milla_particle_frame_6,milla_particle_x_6,milla_particle_y_6,xdir,1,milla_particle_x_6_ang,c_white,1);
        //Animations for held items
        if performance_profile = 1 and milla_phantom_attack_sprite!=spr_cube and milla_phantom_attack_sprite!=spr_cube_alt and (milla_phantom_mode=2 or milla_phantom_mode=3)
            {
                //Set Additive Blending Mode For Shield Sprites
                draw_set_blend_mode(bm_add);
                //Create higher orbital point above the player
                if milla_phantom_mode=2
                    {
                        milla_shield_x = milla_phantom_length_x+lengthdir_x(18,angle_a+90)
                        milla_shield_y = milla_phantom_length_y+lengthdir_y(18,angle_a+90)
                        milla_shield_angle = angle_a
                    }
                if milla_phantom_mode=3
                    {
                        milla_shield_x = milla_phantom_cube_x+lengthdir_x(18,angle_a+90)
                        milla_shield_y = milla_phantom_cube_y+lengthdir_y(18,angle_a+90)
                        milla_shield_angle = milla_phantom_cube_angle
                    }
                //Draw shield sprites
                switch(milla_phantom_attack_sprite)
                    {
                        case spr_flower_2_copy:     {draw_sprite_ext(spr_shield_wood,milla_phantom_attack_frame3,milla_shield_x,milla_shield_y+milla_phantom_cube_offset_y,1,1,milla_shield_angle,c_white,0.75); break;}
                        case spr_flower_3_copy:     {draw_sprite_ext(spr_shield_water,milla_phantom_attack_frame3,milla_shield_x,milla_shield_y+milla_phantom_cube_offset_y,1,1,milla_shield_angle,c_white,0.75); break;}
                        case spr_flower_4_copy:     {draw_sprite_ext(spr_shield_earth,milla_phantom_attack_frame3,milla_shield_x,milla_shield_y+milla_phantom_cube_offset_y,1,1,milla_shield_angle,c_white,0.75); break;}
                        case spr_flower_5_copy:     {draw_sprite_ext(spr_shield_fire_front,milla_phantom_attack_frame3,milla_shield_x,milla_shield_y+milla_phantom_cube_offset_y,1,1,milla_shield_angle,c_white,0.75); break;}
                        case spr_flower_6_copy:     {draw_sprite_ext(spr_shield_metal,milla_phantom_attack_frame3,milla_shield_x,milla_shield_y+milla_phantom_cube_offset_y,1,1,milla_shield_angle,c_white,0.75); break;}
                        case spr_flower_10_copy:    {draw_sprite_ext(spr_shield_rock,milla_phantom_attack_frame3,milla_shield_x,milla_shield_y+milla_phantom_cube_offset_y,1,1,milla_shield_angle,c_white,0.75); break;}
                        default:                    {break;}
                    }
                draw_set_blend_mode(bm_normal)
            }
        if milla_digging_x != 0
            draw_background(milla_digging_index,milla_digging_x,milla_digging_y);
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Spade Particles
if skin=spr_spade and user_cursor_mode = 0
    {
        script_execute(pal_swap_script,my_pal_sprite,current_pal,false)
        //Draw Player Sprite
        draw_sprite_ext(skin,frame,px,gravity_fofset,xdir,1,angle_a,c_white,1);
        //Draw glow effect
        if speed_boosted_timer != 0
            {
                draw_set_blend_mode(bm_add)
                draw_sprite_ext(skin,frame,px,gravity_fofset,xdir,1,angle_a,c_yellow,speed_boosted_alpha);
                draw_set_blend_mode(bm_normal)
            }
        shader_reset();
        if spade_explosion_effect_frame &gt; -1
            {
                if pause = 0 spade_explosion_effect_frame += 0.25;
                draw_set_blend_mode(bm_add)
                draw_sprite(spr_explosion_1,spade_explosion_effect_frame,spade_explosion_effect_x,spade_explosion_effect_y)
                draw_set_blend_mode(bm_normal)
                if spade_explosion_effect_frame &gt; 6.8
                    spade_explosion_effect_frame = -1;
            }
        var var_count = 0;
        var var_frame = 55;
        if anim_current = anim_spade_dashing_ver
            var_frame = 57;
        while(var_count &lt; 3)
            {
                if spade_affect_effects_alpha[var_count] &gt; 0
                    {
                        script_execute(pal_swap_script,my_pal_sprite,current_pal,false)
                        draw_sprite_ext(spr_spade,var_frame,spade_affect_effects_x[var_count],spade_affect_effects_y[var_count],spade_affect_effects_xdir[var_count],1,spade_affect_effects_angle[var_count],c_white,spade_affect_effects_alpha[var_count])
                        if pause = 0 spade_affect_effects_alpha[var_count] -= 0.025;
                        shader_reset();
                    }
                var_count += 1
            }
        var var_count = 0;
        while(var_count &lt; 3)
            {
                if spade_sparkle_effects_frame[var_count] &gt; -1
                    {
                        draw_sprite(spr_sparkle,spade_sparkle_effects_frame[var_count],spade_sparkle_effects_x[var_count],spade_sparkle_effects_y[var_count])
                        if pause = 0 spade_sparkle_effects_frame[var_count] += 0.25;
                        if spade_sparkle_effects_frame[var_count] &gt; 7.5
                            spade_sparkle_effects_frame[var_count] = -1;
                    }
                var_count += 1
            }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Shield And Particle Sprites

//Only Draw The Shield In Player Mode
if user_cursor_mode = 0
    {
        //Draw Shield Flash
        if shield_flash&gt;=-1 draw_sprite_ext(spr_shield_break,shield_flash,px,py-24,1,-1,0,c_white,1);
        if shield_flash_trigger = 1 draw_sprite_ext(spr_shield_break,shield_flash_frame,shield_flash_x,shield_flash_y,1,-1,0,c_white,1);
        
        //Draw Shield
        if shield_active = 1 and invuln_hud_acti = 0
            {
                //Set Additive Blending Mode For Shield Sprites And Particles
                draw_set_blend_mode(bm_add)
                //Draw Fire Shield Background Layer
                if shield = spr_shield_fire_front
                    draw_sprite_ext(spr_shield_fire_back,shield_frame,px+lengthdir_x(24,angle_a+90),py+lengthdir_y(24,angle_a+90),1,1,0,c_white,0.75);
                //Draw Petal Particles For Wood Shield
                if shield = spr_shield_wood
                    {
                        //Create an orbital point above the player's feet for the particles to center themselves onto
                        var wood_particle_x = px+lengthdir_x(24,angle_a+90)
                        var wood_particle_y = py+lengthdir_y(24,angle_a+90)
                        //Group 1
                        draw_sprite_ext(spr_shield_wood_petal,0,wood_particle_x+petal_x[0],wood_particle_y+24-petal_y[0],1,1,petal_angle[0],c_white,1-petal_alpha[0])
                        draw_sprite_ext(spr_shield_wood_petal,0,wood_particle_x+petal_x[1],wood_particle_y+24-petal_y[1],1,1,petal_angle[1],c_white,1-petal_alpha[1])
                        draw_sprite_ext(spr_shield_wood_petal,0,wood_particle_x+petal_x[2],wood_particle_y+24-petal_y[2],1,1,petal_angle[2],c_white,1-petal_alpha[2])
                        draw_sprite_ext(spr_shield_wood_petal,0,wood_particle_x+petal_x[3],wood_particle_y+24-petal_y[3],1,1,petal_angle[3],c_white,1-petal_alpha[3])
                        draw_sprite_ext(spr_shield_wood_petal,0,wood_particle_x+petal_x[4],wood_particle_y+24-petal_y[4],1,1,petal_angle[4],c_white,1-petal_alpha[4])
                        //Group 2
                        draw_sprite_ext(spr_shield_wood_petal,0,wood_particle_x+petal_x[5],wood_particle_y+24-petal_y[5],1,1,petal_angle[5],c_white,1-petal_alpha[5])
                        draw_sprite_ext(spr_shield_wood_petal,0,wood_particle_x+petal_x[6],wood_particle_y+24-petal_y[6],1,1,petal_angle[6],c_white,1-petal_alpha[6])
                        draw_sprite_ext(spr_shield_wood_petal,0,wood_particle_x+petal_x[7],wood_particle_y+24-petal_y[7],1,1,petal_angle[7],c_white,1-petal_alpha[7])
                        draw_sprite_ext(spr_shield_wood_petal,0,wood_particle_x+petal_x[8],wood_particle_y+24-petal_y[8],1,1,petal_angle[8],c_white,1-petal_alpha[8])
                        draw_sprite_ext(spr_shield_wood_petal,0,wood_particle_x+petal_x[9],wood_particle_y+24-petal_y[9],1,1,petal_angle[9],c_white,1-petal_alpha[9])
                    }
                //Draw Bubble Particles for Water Shield
                if shield = spr_shield_water
                    {
                        //Create an orbital point above the player's feet for the particles to center themselves onto
                        var water_particle_x = px+lengthdir_x(24,angle_a+90)
                        var water_particle_y = py+lengthdir_y(24,angle_a+90)
                        draw_sprite_ext(spr_shield_water_bubble,0,water_particle_x+bubble_x,water_particle_y+24-bubble_y,1,1,0,c_white,1-bubble_alpha)
                        draw_sprite_ext(spr_shield_water_bubble,0,water_particle_x+bubble_x2,water_particle_y+24-bubble_y,1,1,0,c_white,1-bubble_alpha)
                    }
                //Draw Shield Sprites
                draw_sprite_ext(shield,shield_frame,shield_rotate_x,shield_rotate_y,1,1,shield_rotate,c_white,0.75)
                //Reset Blending Mode To Normal
                draw_set_blend_mode(bm_normal)
            }
        
        //Draw Heart Particles When Hurt
        if hurt[0] = 1 and hurt[1] &gt; 0 and hurt[1] &lt; 16 and death[0] = 0
            {
                draw_sprite_ext(spr_shield_wood_petal,0,petal_offset_x[0]+petal_hurt_x[0],petal_offset_y[0]+petal_hurt_y[0],1,1,petal_hurt_ang[0],c_white,1)
                draw_sprite_ext(spr_shield_wood_petal,0,petal_offset_x[1]+petal_hurt_x[1],petal_offset_y[1]+petal_hurt_y[1],1,1,petal_hurt_ang[1],c_white,1)
                draw_sprite_ext(spr_shield_wood_petal,0,petal_offset_x[2]+petal_hurt_x[2],petal_offset_y[2]+petal_hurt_y[2],1,1,petal_hurt_ang[2],c_white,1)
                draw_sprite_ext(spr_shield_wood_petal,0,petal_offset_x[3]+petal_hurt_x[3],petal_offset_y[3]+petal_hurt_y[3],1,1,petal_hurt_ang[3],c_white,1)
                draw_sprite_ext(spr_shield_wood_petal,0,petal_offset_x[4]+petal_hurt_x[4],petal_offset_y[4]+petal_hurt_y[4],1,1,petal_hurt_ang[4],c_white,1)
            }
        
        //Draw Skid Particles
        if skid_animation_frame[0] &gt; 0 draw_sprite_ext(spr_skidding,skid_animation_frame[0],skid_offset_x[0]+skid_animation_offset_x,skid_offset_y[0]+skid_animation_offset_y,1,1,0,c_white,0.40);
        if skid_animation_frame[4] &gt; 0 draw_sprite_ext(spr_skidding,skid_animation_frame[4],skid_offset_x[4]+skid_animation_offset_x,skid_offset_y[4]+skid_animation_offset_y,1,1,0,c_white,0.40);
        if skid_animation_frame[8] &gt; 0 draw_sprite_ext(spr_skidding,skid_animation_frame[8],skid_offset_x[8]+skid_animation_offset_x,skid_offset_y[8]+skid_animation_offset_y,1,1,0,c_white,0.40);
        //Only draw other particles for the bike based on input
        if (bike = 0) or (bike = 1 and (joy_input[0,2] = 1 or joy_input[0,0] = 1)) or (bike = 1 and hsp != 0)
            {
                if skid_animation_frame[1] &gt; 0 draw_sprite_ext(spr_skidding,skid_animation_frame[1],skid_offset_x[1]+skid_animation_offset_x,skid_offset_y[1]+skid_animation_offset_y,1,1,0,c_white,0.40);
                if skid_animation_frame[2] &gt; 0 draw_sprite_ext(spr_skidding,skid_animation_frame[2],skid_offset_x[2]+skid_animation_offset_x,skid_offset_y[2]+skid_animation_offset_y,1,1,0,c_white,0.40);
                if skid_animation_frame[3] &gt; 0 draw_sprite_ext(spr_skidding,skid_animation_frame[3],skid_offset_x[3]+skid_animation_offset_x,skid_offset_y[3]+skid_animation_offset_y,1,1,0,c_white,0.40);
                if skid_animation_frame[4] &gt; 0 draw_sprite_ext(spr_skidding,skid_animation_frame[4],skid_offset_x[4]+skid_animation_offset_x,skid_offset_y[4]+skid_animation_offset_y,1,1,0,c_white,0.40);
                if performance_profile = 1
                    {
                        if skid_animation_frame[5] &gt; 0 draw_sprite_ext(spr_skidding,skid_animation_frame[5],skid_offset_x[5]+skid_animation_offset_x,skid_offset_y[5]+skid_animation_offset_y,1,1,0,c_white,0.40);
                        if skid_animation_frame[6] &gt; 0 draw_sprite_ext(spr_skidding,skid_animation_frame[6],skid_offset_x[6]+skid_animation_offset_x,skid_offset_y[6]+skid_animation_offset_y,1,1,0,c_white,0.40);
                        if skid_animation_frame[7] &gt; 0 draw_sprite_ext(spr_skidding,skid_animation_frame[7],skid_offset_x[7]+skid_animation_offset_x,skid_offset_y[7]+skid_animation_offset_y,1,1,0,c_white,0.40);
                        if skid_animation_frame[9] &gt; 0 draw_sprite_ext(spr_skidding,skid_animation_frame[9],skid_offset_x[9]+skid_animation_offset_x,skid_offset_y[9]+skid_animation_offset_y,1,1,0,c_white,0.40);
                    }
            }

        //Draw Bubble Particles
        if py &gt; water_height+16
            {
                if bubble_visibility[0] &gt; 0   draw_sprite(spr_bubbles,0,bubble_offset_x[0],bubble_offset_y[0]);
                if bubble_visibility[1] &gt; 180 draw_sprite(spr_bubbles,0,bubble_offset_x[1],bubble_offset_y[1]);
                if bubble_visibility[2] &gt; 360 draw_sprite(spr_bubbles,0,bubble_offset_x[2],bubble_offset_y[2]);
            }
        
        //Invincibility
        if (invuln_hud_time &gt; 0 and invuln_hud_time &lt; 2620)
            {
                //Draw Particles
                if performance_profile = 1
                    {
                        draw_set_blend_mode(bm_add);
                        if part_frame[0]&lt;=7 draw_sprite(spr_sparkle,part_frame[0],position_offset[0],sparkle_offset[0]+16+frame_speed[0]);
                        if part_frame[1]&lt;=7 draw_sprite(spr_sparkle,part_frame[1],position_offset[1],sparkle_offset[1]+8+frame_speed[1]);
                        if part_frame[2]&lt;=7 draw_sprite(spr_sparkle,part_frame[2],position_offset[2],sparkle_offset[2]+16+frame_speed[2]);
                        if part_frame[3]&lt;=7 draw_sprite(spr_sparkle,part_frame[3],position_offset[3],sparkle_offset[3]+8+frame_speed[3]);
                        if part_frame[4]&lt;=7 draw_sprite(spr_sparkle,part_frame[4],position_offset[4],sparkle_offset[4]-4+frame_speed[4]);
                    }
                if part_frame[5]&lt;=7 draw_sprite(spr_sparkle,part_frame[5],position_offset[5],sparkle_offset[5]+12+frame_speed[5]);
                if part_frame[6]&lt;=7 draw_sprite(spr_sparkle,part_frame[6],position_offset[6],sparkle_offset[6]+4+frame_speed[6]);
                if part_frame[7]&lt;=7 draw_sprite(spr_sparkle,part_frame[7],position_offset[7],sparkle_offset[7]+12+frame_speed[7]);
                if part_frame[8]&lt;=7 draw_sprite(spr_sparkle,part_frame[8],position_offset[8],sparkle_offset[8]+4+frame_speed[8]);
                if part_frame[9]&lt;=7 draw_sprite(spr_sparkle,part_frame[9],position_offset[9],sparkle_offset[9]+frame_speed[9]);
                draw_set_blend_mode(bm_normal)
            }
        //Rail Grinding Particles
        if gravity_rail_check = 1
            {
                var gravity_rail_count = 0;
                while(gravity_rail_count &lt;= 5)
                    {
                        draw_sprite_ext(spr_rail_spark,0,rail_grinding_particle_x[gravity_rail_count],rail_grinding_particle_y[gravity_rail_count],0.5,0.5,rail_grinding_particle_ang[gravity_rail_count],c_white,1)
                        gravity_rail_count += 1
                    }
            }
        //Rain Particles
        if xcompass = 0 and use_weather_conditions &gt; 0 and above_water = 1
            {
                var rain_particle_offset = 0;
                if ground = 0 
                    rain_particle_offset = -32;
                //Splatter Animations
                if pause = 0
                    {
                        weather_rain_particles_frame += use_weather_conditions*0.20
                    }
                if weather_rain_particles_frame &gt; 3.8
                    weather_rain_particles_frame = 0;
                draw_sprite_ext(spr_rain_particles,weather_rain_particles_frame,px,py+rain_particle_offset,1,1,angle_a,c_white,1)
            }
        
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Global Water Surface

//Draw Rain Effects if set
if use_weather_conditions &gt; 0
    {
        if use_weather_conditions = 1
        or use_weather_conditions = 2
        or use_weather_conditions = 4
        or use_weather_conditions = 5
            {
                var sprite_x = 0;
                var sprite_y = 0;
                var sprite_rain = 0;
                if use_weather_conditions = 4
                    sprite_rain = 1;
                while (sprite_y &lt; water_height)
                    {
                        draw_sprite(spr_rain,sprite_rain,view_xview[view_port]+sprite_x,sprite_y+use_weather_y_0)
                        draw_sprite(spr_rain,sprite_rain,view_xview[view_port]+sprite_x,sprite_y+use_weather_y_0-240)
                        sprite_x += sprite_get_width(spr_rain)
                        if sprite_x &gt; view_wview[view_port]
                            {
                                sprite_x = 0
                                sprite_y += sprite_get_height(spr_rain)
                            }
                    }
                var sprite_x = 0;
                while(sprite_x &lt; view_wview[view_port])
                    {
                        draw_sprite(spr_explosion_3,use_weather_timer,view_xview[view_port]+sprite_x,water_height)
                        draw_sprite(spr_explosion_3,use_weather_timer+0.15,view_xview[view_port]+sprite_x-24,water_height-4)
                        sprite_x += 32
                    }
            }
        //Tempest
        if use_weather_conditions = 3
            {
                var sprite_x = 0;
                var sprite_y = 0;
                if view_yview[view_port] &lt; water_height
                    {
                        while (sprite_y &lt; water_height)
                            {
                                draw_sprite_ext(spr_rain,0,view_xview[view_port]+sprite_x+use_weather_x_0,sprite_y+use_weather_y_0,1,1,-90,c_white,1)
                                draw_sprite_ext(spr_rain,0,view_xview[view_port]+sprite_x+use_weather_x_0,sprite_y+use_weather_y_0-240,1,1,-90,c_white,1)
                                draw_sprite_ext(spr_rain,0,view_xview[view_port]+sprite_x+use_weather_x_0,sprite_y+use_weather_y_0-168,1,1,-90,c_white,1)
                                draw_sprite_ext(spr_rain,0,view_xview[view_port]+sprite_x+use_weather_x_0,sprite_y+use_weather_y_0-64,1,1,-90,c_white,1)
                                sprite_x += sprite_get_width(spr_rain)
                                if sprite_x &gt; view_wview[view_port]
                                    {
                                        sprite_x = 0
                                        sprite_y += sprite_get_height(spr_rain)
                                    }
                            }
                    }
                var sprite_x = 0;
                while(sprite_x &lt; view_wview[view_port])
                    {
                        draw_sprite(spr_explosion_3,use_weather_timer,view_xview[view_port]+sprite_x,water_height)
                        draw_sprite(spr_explosion_3,use_weather_timer+0.15,view_xview[view_port]+sprite_x-24,water_height-4)
                        sprite_x += 32
                    }
            }
    }

//=============================================//
//Create Ocean Water if it is defined in the Room Start Event
//=============================================//

//Fill screen with water, if we are below the waterline
if view_yview[view_port]&gt;water_height
    {
        draw_sprite_stretched_ext(water_index,0,view_xview[view_port],view_yview[view_port],view_wview[view_port],view_hview[view_port],c_white,0.25);
    }

//Render the waterline, and fill the screen with water based on how high above its surface the camera is
if view_yview[view_port]&lt;=water_height
    {
        //Tile The Surface Of The Water Horizontally For Other Zoom Levels
        //Water Foreground
        draw_sprite_stretched_ext(water_index,0,view_xview[view_port],water_height+water_offset,2130,1200,c_white,water_alpha)
        //Waterline
        if performance_profile = 1 draw_set_blend_mode(bm_add);
        draw_sprite(waterline_index,water_timer,view_xview[0],water_height+water_offset)
        draw_sprite(waterline_index,water_timer,view_xview[0]+512,water_height+water_offset)
        draw_sprite(waterline_index,water_timer,view_xview[0]+1024,water_height+water_offset)
        draw_sprite(waterline_index,water_timer,view_xview[0]+1536,water_height+water_offset)
        draw_sprite(waterline_index,water_timer,view_xview[0]+2048,water_height+water_offset)
        //Otherwise, Draw The Surface Of The Water Normally
        //else
        //    {
                //Water Foreground
                //draw_sprite_stretched_ext(spr_water,0,view_xview[view_port],water_height+water_offset,internal_resolution[0],internal_resolution[1],c_white,0.25)
                //Waterline
                //if performance_profile = 1 draw_set_blend_mode(bm_add);
                //draw_sprite(spr_waterline,water_timer,view_xview[0],water_height+water_offset)
        //    }
        //Reset Blending Mode To Normal
        draw_set_blend_mode(bm_normal)
    } //End of Water Height Check

//Splash Particle Effect
if (splash_frame&gt;0 and splash_frame&lt;9 and user_cursor_mode = 0) draw_sprite_ext(spr_water_splash_2x,splash_frame,splash_x,water_height,sfactor,sfactor,0,c_white,1);

//=============Drown Alarm Timer=============//

if (alarm_timer &gt; 0 and alarm_timer &lt; 660) draw_sprite(spr_breath_warning,alarm_frame,px-16+alarm_shake_x,py-84+alarm_shake_y);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Advanced Debug Sensors

//Draw Positions of Collision Sensors in "Advanced Mode"
if debug_hud_sensors = 1
    {
        //Slope Surface Sensors
        draw_sprite(spr_surface_sensors,6,px,py)                                                             //Floor Sensor
        draw_sprite(spr_surface_sensors,7,px+lengthdir_x(27,angle_c+122),py+lengthdir_y(27,angle_c+122))     //Left Sensor
        draw_sprite(spr_surface_sensors,5,px+lengthdir_x(27,angle_c+57),py+lengthdir_y(27,angle_c+57))       //Right Sensor
        draw_sprite(spr_surface_sensors,4,px+lengthdir_x(27,tile_angle+90),py+lengthdir_y(27,tile_angle+90)) //Ceiling Sensor

        //Flat Surface Sensors
        if tile_surface_ceiling_disable = 0
            {
                if not (tile_angle &gt; 45 and tile_angle &lt;= 315)
                    {
                        draw_sprite(spr_surface_sensors,2,px,py)       //Floor Sensor
                        draw_sprite(spr_surface_sensors,0,px,py-27)    //Ceiling Sensor
                    }
                if tile_angle=0
                    {
                        draw_sprite(spr_surface_sensors,3,px-17,py-15) //Left Sensor
                        draw_sprite(spr_surface_sensors,1,px+17,py-15) //Right Sensor
                    }
                //Tile Companion Surface Sensors
                if tile_ramp_id=-1 and tile_angle=0
                    {
                        draw_sprite(spr_surface_sensors,8,px-8,py) //Left Sensor
                        draw_sprite(spr_surface_sensors,9,px+8,py) //Right Sensor
                    }
            }

        //Flat Wall Running Sensors
        switch(tile_surface_wall_xcompass)
            {
                //Floor Mode
                case 0:
                    {
                        draw_sprite(spr_surface_sensors,14,px+15,py-32) //Wall Sensor (Forward)
                        draw_sprite(spr_surface_sensors,14,px-15,py-32) //Wall Sensor (Backward)
                        break;
                    }
                //Wall Mode (Right)
                case 90:
                    {
                        draw_sprite(spr_surface_sensors,14,px,py)      //Bottom Collision Sensor
                        draw_sprite(spr_surface_sensors,14,px+4,py-8)  //Top Collision Sensor
                        draw_sprite(spr_surface_sensors,14,px+8,py+16) //Downward Slope Sensor
                        break;
                    }
                //Ceiling Mode
                case 180:
                    {
                        draw_sprite(spr_surface_sensors,14,px,py-8)    //Top and Bottom Collision Sensors
                        draw_sprite(spr_surface_sensors,14,px-15,py+8) //Flat Wall Sensor (Forward)
                        draw_sprite(spr_surface_sensors,14,px+15,py+8) //Flat Wall Sensor (Backward)
                        break;
                    }
                //Wall Mode (Left)
                case 270:
                    {
                        draw_sprite(spr_surface_sensors,14,px,py)       //Bottom Collision Sensor
                        draw_sprite(spr_surface_sensors,14,px-4,py-8)   //Top Collision Sensor
                        draw_sprite(spr_surface_sensors,14,px-15,py+16) //Downward Slope Sensor
                        break;
                    }
            }
        //Flat Wall Running Sensors (Contextual Sensors)
        if (xcompass = 90 or xcompass = 270)
            {
                //=========Flat Wall Collisions=========//

                var tile_surface_wall_direction = abs(hsp)
                var tile_surface_wall_vertical  = -abs(hsp)

                //Search for flat wall surfaces towards the left
                if xcompass = 270 tile_surface_wall_direction = -abs(hsp);

                //Search for flat wall surfaces towards the floor
                if (xcompass = 270 and hsp &gt;= 0) or (xcompass = 90 and hsp &lt;= 0)
                    {
                        tile_surface_wall_vertical = abs(hsp)
                    }
                //Draw Wall Running Sensor
                draw_sprite(spr_surface_sensors,15,px+tile_surface_wall_direction,py+tile_surface_wall_vertical)
            }
        //Flat Ceiling Running Sensors (Contextual Sensors)
        if (xcompass = 180)
            {
                var tile_surface_wall_direction = -16;
                if hsp &lt; 0 {tile_surface_wall_direction = 16;}
                //Draw Ceiling Running Sensor
                draw_sprite(spr_surface_sensors,15,px+tile_surface_wall_direction,py-16)
            }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
