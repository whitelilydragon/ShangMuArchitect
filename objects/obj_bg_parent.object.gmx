<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_logic_processor</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>100</depth>
  <persistent>0</persistent>
  <parentName>obj_activate_parent</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize Variables
frame = 0
frame_floor = 0
frame_index = mu_bg_5
frame_resolution_x = 2130
frame_resolution_y = 1200
weather_scroll_x = 0
mud_water_id = -1
water_bg_index = mu_bg_40
water_bg_line = mu_bg_45
water_bg_surface = spr_water_surface_shang_mu_city_west
//Are We Allowed To Hold Items?
give_item = 0
item = 0
zoom = obj_game_logic.use_zoom_multiplier
overzoom = 1
weather_clouds_enable = 1
weather_clouds_x_1 = 0
weather_clouds_x_2 = 0
weather_clouds_x_3 = 0
weather_clouds_x_4 = 0
global_frame = 0
global_frame_cap = 3.8
led_arrow_frame = 0

bubble_x[0] = random_range(8,16)
bubble_y[0] = view_yview[view_port]+view_hview[view_port]
bubble_speed[0] = 2
bubble_x[1] = random_range(32,120)
bubble_y[1] = view_yview[view_port]+view_hview[view_port]
bubble_speed[1] = 3.2
bubble_x[2] = random_range(16,64)
bubble_y[2] = view_yview[view_port]+view_hview[view_port]
bubble_speed[2] = 2.4
bubble_x[3] = random_range(8,16)
bubble_y[3] = view_yview[view_port]+view_hview[view_port]
bubble_speed[3] = 1.2
bubble_x[4] = random_range(96,120)
bubble_y[4] = view_yview[view_port]+view_hview[view_port]
bubble_speed[4] = 2.4
bubble_x[5] = random_range(48,64)
bubble_y[5] = view_yview[view_port]+view_hview[view_port]
bubble_speed[5] = 2.4
bubble_x[6] = 0
bubble_y[6] = view_yview[view_port]+view_hview[view_port]
bubble_speed[6] = 2.4

bubble_x[7] = random_range(8,16)
bubble_y[7] = view_yview[view_port]+view_hview[view_port]
bubble_speed[7] = 2
bubble_x[8] = random_range(32,120)
bubble_y[8] = view_yview[view_port]+view_hview[view_port]
bubble_speed[8] = 3.2
bubble_x[9] = random_range(16,64)
bubble_y[9] = view_yview[view_port]+view_hview[view_port]
bubble_speed[9] = 2.4
bubble_x[10] = random_range(8,16)
bubble_y[10] = view_yview[view_port]+view_hview[view_port]
bubble_speed[10] = 1.2
bubble_x[11] = random_range(96,120)
bubble_y[11] = view_yview[view_port]+view_hview[view_port]
bubble_speed[11] = 2.4
bubble_x[12] = random_range(48,64)
bubble_y[12] = view_yview[view_port]+view_hview[view_port]
bubble_speed[12] = 2.4
bubble_x[13] = random_range(48,64)
bubble_y[13] = view_yview[view_port]+view_hview[view_port]
bubble_speed[13] = 2.4

clouds_x_left = 0
petal_rotation = 0
petal_heal_timer = 0
mud_water_id = tile_add(tile_water_running,0,0,background_get_width(tile_water_running),24,0,obj_game_logic.water_height,200000)
tile_set_visible(mud_water_id,false)
mud_water_timer = 0

water_splash_x[0] = -128
water_splash_y[0] = -128
water_splash_frame[0] = 0
water_splash_x[1] = -128
water_splash_y[1] = -128
water_splash_frame[1] = 0
water_splash_x[2] = -128
water_splash_y[2] = -128
water_splash_frame[2] = 0
water_splash_x[3] = -128
water_splash_y[3] = -128
water_splash_frame[3] = 0
water_splash_x[4] = -128
water_splash_y[4] = -128
water_splash_frame[4] = 0
water_splash_x[5] = -128
water_splash_y[5] = -128
water_splash_frame[5] = 0
water_splash_x[6] = -128
water_splash_y[6] = -128
water_splash_frame[6] = 0
water_splash_x[7] = -128
water_splash_y[7] = -128
water_splash_frame[7] = 0
water_splash_x[8] = -128
water_splash_y[8] = -128
water_splash_frame[8] = 0
water_splash_number = 0
water_splash_wave = 0
water_splash_enable = 0

weather_slime_timer = 0
wt_storm_clouds = wt_stormy_clouds

//Increase The Background's Depth While In Editor Mode
if room = rm_editor depth = 100010;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if tile_exists(mud_water_id) tile_delete(mud_water_id);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Animate and Zoom Background
if obj_game_logic.pause = 0
    {
        //Global Animation Frames For Animated Tiles
        global_frame += 0.15
        if global_frame &gt; global_frame_cap
            global_frame = 0;
        if obj_game_logic.use_weather_conditions &gt; 0
            {
                wt_storm_clouds = wt_stormy_clouds
                if obj_game_logic.use_weather_conditions = 4
                    wt_storm_clouds = bg_slime_clouds_2x;
                //weather_scroll_x -= (obj_game_logic.use_weather_conditions+1)*0.25
                //Scroll Clouds
                weather_clouds_x_1 += (obj_game_logic.use_weather_conditions+1)*0.25;
                if weather_clouds_x_1 &gt;= background_get_width(wt_storm_clouds)*overzoom
                    weather_clouds_x_1 = 0;
                weather_clouds_x_2 += (obj_game_logic.use_weather_conditions+1)*0.25;
                if weather_clouds_x_2 &gt;= background_get_width(wt_storm_clouds)*overzoom
                    weather_clouds_x_2 = 0;
                weather_clouds_x_3 += (obj_game_logic.use_weather_conditions+1)*0.50;
                if weather_clouds_x_3 &gt;= background_get_width(wt_storm_clouds)*overzoom
                    weather_clouds_x_3 = 0;
                weather_clouds_x_4 += (obj_game_logic.use_weather_conditions+1)*0.50;
                if weather_clouds_x_4 &gt;= background_get_width(wt_storm_clouds)*overzoom
                    weather_clouds_x_4 = 0;
            }
        if obj_game_logic.cube_rain_timer &gt; 0
            {
                weather_slime_timer += 1
                obj_game_logic.cube_rain_timer -= 1
                if weather_slime_timer &gt;= 8
                    {
                        var weather_problems = floor(random_range(0,4));
                        var weather_problems_index = obj_player_cube;
                        switch(weather_problems)
                            {
                                case 0: {weather_problems_index = obj_player_cube; break;}
                                case 1: {weather_problems_index = obj_mega_rogue_cube; break;}
                                case 2: {weather_problems_index = obj_mega_bouncy; break;}
                                case 3: {weather_problems_index = obj_player_cube_alt; break;}
                                case 4: {weather_problems_index = obj_player_cube; break;}
                            }
                        instance_create(view_xview[view_port]+(random_range(-16,view_wview[view_port])),view_yview[view_port]-32,weather_problems_index)
                        weather_slime_timer = 0
                    }
            }
        if instance_exists(obj_led_arrows)
            {
                led_arrow_frame += 0.16
                if led_arrow_frame &gt; 8.8
                    led_arrow_frame = 0;
                obj_led_arrows.frame = led_arrow_frame
            }
    }

//If the camera is within visibility of the water's surface, allow it to manipulate the position of the water's horizon
if view_yview[view_port]+150 &gt;= obj_game_logic.water_height-96 and view_yview[view_port]+150 &lt;= obj_game_logic.water_height+96
    {
        obj_game_logic.water_stretch = view_yview[view_port]+150
    }
//Otherwise keep a static position either above or below the surface of the water
else
    {
        if (view_yview[view_port]+150 &lt; obj_game_logic.water_height-96) obj_game_logic.water_stretch = obj_game_logic.water_height-96;
        if (view_yview[view_port]+150 &gt; obj_game_logic.water_height+96) obj_game_logic.water_stretch = obj_game_logic.water_height+96;
    }
//Adjust background zooming for 150% and 200% zoom levels
zoom = obj_game_logic.use_zoom_multiplier;
if room = rm_editor
    {
        if obj_game_logic.use_zoom_scale_factor = 0.75
        or obj_game_logic.use_zoom_scale_factor = 0.5
            overzoom = lerp(overzoom,1,0.5);
        if obj_game_logic.use_zoom_scale_factor = 1
            overzoom = lerp(overzoom,obj_game_logic.use_zoom_multiplier,0.25);
        if obj_game_logic.use_zoom_scale_factor &gt; 1
            overzoom = obj_game_logic.use_zoom_multiplier;
    }
else overzoom = zoom;

if tile_exists(mud_water_id)
    {
        if (obj_game_logic.waterline_index != spr_oil_waterline)
            {
                if obj_game_logic.user_cursor_mode = 0
                    tile_set_position(mud_water_id,obj_game_logic.px-32,obj_game_logic.water_height-12);
                else
                    tile_set_position(mud_water_id,-200000,obj_game_logic.water_height-8);
            }
        if obj_game_logic.pause = 0
            {
                mud_water_timer += 1
                if mud_water_timer = 4
                    {
                        if (obj_game_logic.waterline_index != spr_oil_waterline)
                            {
                                //Modify collision layer depth based on speed
                                if (abs(obj_game_logic.hsp) &gt;= 7
                                and obj_game_logic.py &lt;= obj_game_logic.water_height+8)
                                and obj_game_logic.tile_angle = 0
                                    {
                                        if  obj_game_logic.py &gt;= obj_game_logic.water_height-8
                                        and obj_game_logic.py &lt;= obj_game_logic.water_height+8
                                            {
                                                water_splash_x[water_splash_number] = obj_game_logic.px
                                                water_splash_y[water_splash_number] = obj_game_logic.water_height
                                                water_splash_frame[water_splash_number] = 0
                                                water_splash_number += 1
                                                if water_splash_number &gt; 8
                                                    water_splash_number = 0;
                                                water_splash_enable = 1
                                                audio_play_sound(character_splash,50,false)
                                            }
                                    }
                                else
                                    {
                                        water_splash_enable = 0
                                    }
                            }
                    }
                if mud_water_timer &gt; 8
                    {
                        if (obj_game_logic.waterline_index != spr_oil_waterline)
                        and (obj_game_logic.tile_angle = 0)
                            {
                                //Modify collision layer depth based on speed
                                if  abs(obj_game_logic.hsp) &gt;= 7
                                and obj_game_logic.py &lt;= obj_game_logic.water_height+8
                                    tile_set_depth(mud_water_id,surface_slopes);
                                if abs(obj_game_logic.hsp) &lt; 7
                                    tile_set_depth(mud_water_id,200000);
                            }
                        else
                            tile_set_depth(mud_water_id,200000);
                        mud_water_timer = 0
                    }
                if water_splash_enable = 1
                    {
                        if (obj_game_logic.ground = 0 or abs(obj_game_logic.hsp) &lt; 7)
                            water_splash_enable = 0;
                    }
                //Exit Conditions
                if (tile_get_depth(mud_water_id) = surface_slopes and (obj_game_logic.tile_angle != 0))
                or (obj_game_logic.py &lt; obj_game_logic.water_height - 2 and obj_game_logic.gravity_speed &lt;= 0)
                    tile_set_depth(mud_water_id,200000);
                if tile_exists(obj_game_logic.tile_ramp_id)
                    {
                        if (tile_get_background(obj_game_logic.tile_ramp_id) != tile_water_running)
                            tile_set_depth(mud_water_id,200000);
                    }
            }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Background Drawing/Weather/Scrolling

if view_current = view_port
    {
        if obj_game_logic.use_weather_conditions &gt; 0
            {
                if weather_clouds_enable = 1
                    {
                        draw_background_tiled_ext(wt_storm_clouds,view_xview[view_port]-weather_clouds_x_1,view_yview[view_port]-view_yview[view_port]/(36*zoom),overzoom,overzoom,c_white,0.80)
                        draw_background_tiled_ext(wt_storm_clouds,view_xview[view_port]+weather_clouds_x_2,view_yview[view_port]-view_yview[view_port]/(42*zoom),overzoom,overzoom,c_white,0.80)
                        if obj_game_logic.use_weather_conditions = 3
                            {
                                draw_background_tiled_ext(wt_storm_clouds,view_xview[view_port]-(weather_clouds_x_3+256),view_yview[view_port]-view_yview[view_port]/(32*zoom),overzoom,overzoom,c_white,0.70);
                                draw_background_tiled_ext(wt_storm_clouds,view_xview[view_port]-(weather_clouds_x_4-256),view_yview[view_port]-view_yview[view_port]/(42*zoom),overzoom,overzoom,c_white,0.70);
                            }
                    }
                if obj_game_logic.use_thunder_timer &gt; 1 and obj_game_logic.use_thunder_timer &lt; 8
                    draw_background_tiled_ext(wt_lightning,view_xview[view_port]-view_xview[view_port]/(96*zoom),view_yview[view_port]-view_yview[view_port]/(36*zoom),overzoom,overzoom,c_white,1);
            }

        //Draw The Water's Surface
        if view_yview[view_port]+frame_resolution_y &gt;= obj_game_logic.water_height-150
            {
                //Tile The Pool's Background Horizontally
                var tile_x = 0;
                while (tile_x &lt; room_width)
                    {
                        draw_background(water_bg_index,view_xview[view_port]/4+tile_x,obj_game_logic.water_stretch-320)
                        draw_background_stretched(water_bg_line,view_xview[view_port]/4+tile_x,obj_game_logic.water_stretch+320,background_get_width(water_bg_line),4000)
                        tile_x += background_get_width(water_bg_index)
                    }
                //Horizontally Tiling By Cheating With The Internal Resolution :^P Only Use For Theoretical Performance Gains
                //draw_background_tiled(mu_bg_8,view_xview[view_port]/4,obj_game_logic.water_stretch-320)
                draw_sprite_pos(water_bg_surface,0,view_xview[view_port],obj_game_logic.water_height,view_xview[view_port]+frame_resolution_x,obj_game_logic.water_height,
                view_xview[view_port]+frame_resolution_x,obj_game_logic.water_stretch,view_xview[view_port],obj_game_logic.water_stretch,0.80)
        
                if obj_game_logic.water_index = spr_water_petals
                    {
                        //Petal Bubbles
                        var count = 0;
                        while(count &lt;= 11)
                            {
                                if obj_game_logic.pause = 0
                                    bubble_y[count] -= bubble_speed[count];
                                if bubble_y[count] &lt; obj_game_logic.water_height
                                    {
                                        bubble_y[count] = view_yview[view_port]+view_hview[view_port]+64
                                        bubble_x[count] = view_xview[view_port]+random_range(8,view_wview[view_port]-8)
                                        bubble_speed[count] = random_range(0.8,1.6)
                                    }
                                draw_set_blend_mode(bm_add)
                                draw_sprite_ext(spr_shield_wood_petal,0,x+bubble_x[count],y+bubble_y[count],1,1,petal_rotation+(count*15),c_white,0.5)
                                draw_set_blend_mode(bm_normal)
                                count += 1
                                if obj_game_logic.pause = 0
                                    petal_rotation += 0.5;
                            }
                        if (obj_game_logic.pause = 0 and obj_game_logic.user_cursor_mode = 0)
                            petal_heal_timer += 1;
                        if (petal_heal_timer &gt; 60 and obj_game_logic.py &gt; obj_game_logic.water_height)
                            {
                                instance_create(obj_game_logic.universal_player_x,obj_game_logic.universal_player_y,obj_petal_pickup)
                                petal_heal_timer = 0
                            }
                    }
                else
                    petal_heal_timer = 0;

                //Draw a textured sprite gradient for the water's surface
                if obj_game_logic.water_index = spr_slime_water
                    {
                        //Slime Bubbles
                        var count = 0;
                        while(count &lt;= 11)
                            {
                                if obj_game_logic.pause = 0
                                    bubble_y[count] -= bubble_speed[count];
                                if bubble_y[count] &lt; obj_game_logic.water_height
                                    {
                                        bubble_y[count] = view_yview[view_port]+view_hview[view_port]+64
                                        bubble_x[count] = view_xview[view_port]+random_range(8,view_wview[view_port]-8)
                                        bubble_speed[count] = random_range(2.4,3.2)
                                    }
                                draw_sprite(spr_bubbles,0,x+bubble_x[count],y+bubble_y[count])
                                count += 1
                            }
                        var tile_x = 0;
                        if obj_game_logic.pause = 0
                            clouds_x_left -= 0.5;
                        while (tile_x &lt; room_width)
                            {
                                draw_background(bg_slime_parallax,clouds_x_left+(view_xview[view_port]/4+tile_x),obj_game_logic.water_height)
                                tile_x += background_get_width(bg_slime_parallax)
                            }
                    }
            }
        if instance_exists(obj_level_editor)
            {
                if obj_level_editor.use_grid_toggle_mouse = 1 draw_background_tiled_ext(ui_grid_32px,0,0,1,1,c_white,0.50);
            }
        var splash_count = 0;
        while(splash_count &lt;= 8)
            {
                draw_sprite_ext(spr_water_splash_2x,water_splash_frame[splash_count],water_splash_x[splash_count],water_splash_y[splash_count],0.5,1,0,c_white,1)
               if obj_game_logic.pause = 0
                    { 
                        water_splash_frame[splash_count] += 0.25
                        if water_splash_frame[splash_count] &gt; 8.8
                            {
                                water_splash_frame[splash_count] = 0
                                water_splash_x[splash_count] = -128
                            }
                    }
                splash_count += 1
            }
        if water_splash_enable = 1
            {
                if obj_game_logic.pause = 0
                    water_splash_wave += 0.50;
                if water_splash_wave &gt; 5.8
                    water_splash_wave = 0;

                var water_splash_index = spr_player_wave;
                switch(obj_game_logic.water_index)
                    {
                        case spr_slime_water: {water_splash_index = spr_player_wave_slime; break;}
                        case spr_water_petals: {water_splash_index = spr_player_wave_petal; break;}
                    }
                if obj_game_logic.waterline_index = spr_mud_waterline
                    water_splash_index = spr_player_wave_mud;

                draw_sprite_ext(water_splash_index,water_splash_wave,obj_game_logic.px,obj_game_logic.py,obj_game_logic.xdir,1,0,c_white,1)
            }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
